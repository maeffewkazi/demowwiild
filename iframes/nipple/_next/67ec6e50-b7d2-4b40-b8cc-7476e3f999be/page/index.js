module.exports = __NEXT_REGISTER_PAGE("/", function() {
    return {
        page: webpackJsonp([0], [, , , , , , , , , , , , , , function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.ColorRange = t.NumberRange = t.Range = t.Number = t.Control = t.Label = t.Row = void 0;
            var r = l(n(245)),
                i = l(n(246)),
                o = l(n(247)),
                a = l(n(123)),
                s = l(n(124)),
                u = l(n(125)),
                c = l(n(249));

            function l(e) { return e && e.__esModule ? e : { default: e } }
            t.Row = r.default, t.Label = i.default, t.Control = o.default, t.Number = a.default, t.Range = s.default, t.NumberRange = u.default, t.ColorRange = c.default
        }, , , , , , , , , , , , , , , , , , , , , , , function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = n(243);
            Object.keys(r).forEach(function(e) { "default" !== e && "__esModule" !== e && Object.defineProperty(t, e, { enumerable: !0, get: function() { return r[e] } }) })
        }, , , , , , , , , , , , , function(e, t, n) {
            "use strict";
            t.__esModule = !0, t.default = function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }
        }, function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var r, i = n(234),
                o = (r = i) && r.__esModule ? r : { default: r };
            t.default = function() {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), (0, o.default)(e, r.key, r)
                    }
                }
                return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
            }()
        }, function(e, t, n) {
            "use strict";

            function r() {}
            Object.defineProperty(t, "__esModule", { value: !0 }), n.d(t, "WebGLRenderTargetCube", function() { return pn }), n.d(t, "WebGLRenderTarget", function() { return hn }), n.d(t, "WebGLRenderer", function() { return $i }), n.d(t, "ShaderLib", function() { return An }), n.d(t, "UniformsLib", function() { return Tn }), n.d(t, "UniformsUtils", function() { return wn }), n.d(t, "ShaderChunk", function() { return bn }), n.d(t, "FogExp2", function() { return Qi }), n.d(t, "Fog", function() { return eo }), n.d(t, "Scene", function() { return to }), n.d(t, "Sprite", function() { return oo }), n.d(t, "LOD", function() { return ao }), n.d(t, "SkinnedMesh", function() { return co }), n.d(t, "Skeleton", function() { return so }), n.d(t, "Bone", function() { return uo }), n.d(t, "Mesh", function() { return Sr }), n.d(t, "LineSegments", function() { return po }), n.d(t, "LineLoop", function() { return fo }), n.d(t, "Line", function() { return ho }), n.d(t, "Points", function() { return vo }), n.d(t, "Group", function() { return qi }), n.d(t, "VideoTexture", function() { return go }), n.d(t, "DataTexture", function() { return dn }), n.d(t, "DataTexture3D", function() { return Pr }), n.d(t, "CompressedTexture", function() { return yo }), n.d(t, "CubeTexture", function() { return Ar }), n.d(t, "CanvasTexture", function() { return _o }), n.d(t, "DepthTexture", function() { return xo }), n.d(t, "Texture", function() { return cn }), n.d(t, "CompressedTextureLoader", function() { return Ja }), n.d(t, "DataTextureLoader", function() { return Ka }), n.d(t, "CubeTextureLoader", function() { return Qa }), n.d(t, "TextureLoader", function() { return es }), n.d(t, "ObjectLoader", function() { return au }), n.d(t, "MaterialLoader", function() { return Js }), n.d(t, "BufferGeometryLoader", function() { return Ks }), n.d(t, "DefaultLoadingManager", function() { return qa }), n.d(t, "LoadingManager", function() { return Xa }), n.d(t, "JSONLoader", function() { return ou }), n.d(t, "ImageLoader", function() { return $a }), n.d(t, "ImageBitmapLoader", function() { return hu }), n.d(t, "FontLoader", function() { return mu }), n.d(t, "FileLoader", function() { return Za }), n.d(t, "Loader", function() { return ru }), n.d(t, "LoaderUtils", function() { return iu }), n.d(t, "Cache", function() { return Wa }), n.d(t, "AudioLoader", function() { return Au }), n.d(t, "SpotLightShadow", function() { return As }), n.d(t, "SpotLight", function() { return Ps }), n.d(t, "PointLight", function() { return Rs }), n.d(t, "RectAreaLight", function() { return Ds }), n.d(t, "HemisphereLight", function() { return Ss }), n.d(t, "DirectionalLightShadow", function() { return Cs }), n.d(t, "DirectionalLight", function() { return Os }), n.d(t, "AmbientLight", function() { return Is }), n.d(t, "LightShadow", function() { return Ts }), n.d(t, "Light", function() { return Es }), n.d(t, "StereoCamera", function() { return Pu }), n.d(t, "PerspectiveCamera", function() { return Zi }), n.d(t, "OrthographicCamera", function() { return Ls }), n.d(t, "CubeCamera", function() { return Ru }), n.d(t, "ArrayCamera", function() { return Ji }), n.d(t, "Camera", function() { return Yi }), n.d(t, "AudioListener", function() { return Lu }), n.d(t, "PositionalAudio", function() { return Ou }), n.d(t, "AudioContext", function() { return Tu }), n.d(t, "AudioAnalyser", function() { return Iu }), n.d(t, "Audio", function() { return Cu }), n.d(t, "VectorKeyframeTrack", function() { return qs }), n.d(t, "StringKeyframeTrack", function() { return Xs }), n.d(t, "QuaternionKeyframeTrack", function() { return Ws }), n.d(t, "NumberKeyframeTrack", function() { return Hs }), n.d(t, "ColorKeyframeTrack", function() { return js }), n.d(t, "BooleanKeyframeTrack", function() { return Gs }), n.d(t, "PropertyMixer", function() { return Du }), n.d(t, "PropertyBinding", function() { return Ku }), n.d(t, "KeyframeTrack", function() { return ks }), n.d(t, "AnimationUtils", function() { return Us }), n.d(t, "AnimationObjectGroup", function() { return $u }), n.d(t, "AnimationMixer", function() { return ec }), n.d(t, "AnimationClip", function() { return Ys }), n.d(t, "Uniform", function() { return tc }), n.d(t, "InstancedBufferGeometry", function() { return nc }), n.d(t, "BufferGeometry", function() { return nr }), n.d(t, "Geometry", function() { return jn }), n.d(t, "InterleavedBufferAttribute", function() { return ro }), n.d(t, "InstancedInterleavedBuffer", function() { return rc }), n.d(t, "InterleavedBuffer", function() { return no }), n.d(t, "InstancedBufferAttribute", function() { return ic }), n.d(t, "Face3", function() { return Ln }), n.d(t, "Object3D", function() { return Bn }), n.d(t, "Raycaster", function() { return oc }), n.d(t, "Layers", function() { return On }), n.d(t, "EventDispatcher", function() { return r }), n.d(t, "Clock", function() { return uc }), n.d(t, "QuaternionLinearInterpolant", function() { return Vs }), n.d(t, "LinearInterpolant", function() { return Bs }), n.d(t, "DiscreteInterpolant", function() { return zs }), n.d(t, "CubicInterpolant", function() { return Ns }), n.d(t, "Interpolant", function() { return Fs }), n.d(t, "Triangle", function() { return Mr }), n.d(t, "Math", function() { return Zt }), n.d(t, "Spherical", function() { return cc }), n.d(t, "Cylindrical", function() { return lc }), n.d(t, "Plane", function() { return vn }), n.d(t, "Frustum", function() { return gn }), n.d(t, "Sphere", function() { return mn }), n.d(t, "Ray", function() { return wr }), n.d(t, "Matrix4", function() { return Kt }), n.d(t, "Matrix3", function() { return en }), n.d(t, "Box3", function() { return fn }), n.d(t, "Box2", function() { return hc }), n.d(t, "Line3", function() { return pc }), n.d(t, "Euler", function() { return Cn }), n.d(t, "Vector4", function() { return ln }), n.d(t, "Vector3", function() { return Qt }), n.d(t, "Vector2", function() { return Jt }), n.d(t, "Quaternion", function() { return $t }), n.d(t, "Color", function() { return En }), n.d(t, "ImmediateRenderObject", function() { return dc }), n.d(t, "VertexNormalsHelper", function() { return fc }), n.d(t, "SpotLightHelper", function() { return mc }), n.d(t, "SkeletonHelper", function() { return vc }), n.d(t, "PointLightHelper", function() { return gc }), n.d(t, "RectAreaLightHelper", function() { return yc }), n.d(t, "HemisphereLightHelper", function() { return _c }), n.d(t, "GridHelper", function() { return xc }), n.d(t, "PolarGridHelper", function() { return bc }), n.d(t, "FaceNormalsHelper", function() { return wc }), n.d(t, "DirectionalLightHelper", function() { return Mc }), n.d(t, "CameraHelper", function() { return Ec }), n.d(t, "BoxHelper", function() { return Sc }), n.d(t, "Box3Helper", function() { return Tc }), n.d(t, "PlaneHelper", function() { return Ac }), n.d(t, "ArrowHelper", function() { return Pc }), n.d(t, "AxesHelper", function() { return Rc }), n.d(t, "Shape", function() { return Ms }), n.d(t, "Path", function() { return ws }), n.d(t, "ShapePath", function() { return pu }), n.d(t, "Font", function() { return du }), n.d(t, "CurvePath", function() { return bs }), n.d(t, "Curve", function() { return ts }), n.d(t, "ImageUtils", function() { return sn }), n.d(t, "ShapeUtils", function() { return ua }), n.d(t, "WebGLUtils", function() { return Xi }), n.d(t, "WireframeGeometry", function() { return bo }), n.d(t, "ParametricGeometry", function() { return wo }), n.d(t, "ParametricBufferGeometry", function() { return Mo }), n.d(t, "TetrahedronGeometry", function() { return To }), n.d(t, "TetrahedronBufferGeometry", function() { return Ao }), n.d(t, "OctahedronGeometry", function() { return Po }), n.d(t, "OctahedronBufferGeometry", function() { return Ro }), n.d(t, "IcosahedronGeometry", function() { return Lo }), n.d(t, "IcosahedronBufferGeometry", function() { return Co }), n.d(t, "DodecahedronGeometry", function() { return Oo }), n.d(t, "DodecahedronBufferGeometry", function() { return Io }), n.d(t, "PolyhedronGeometry", function() { return Eo }), n.d(t, "PolyhedronBufferGeometry", function() { return So }), n.d(t, "TubeGeometry", function() { return Do }), n.d(t, "TubeBufferGeometry", function() { return Uo }), n.d(t, "TorusKnotGeometry", function() { return Fo }), n.d(t, "TorusKnotBufferGeometry", function() { return No }), n.d(t, "TorusGeometry", function() { return Bo }), n.d(t, "TorusBufferGeometry", function() { return zo }), n.d(t, "TextGeometry", function() { return ma }), n.d(t, "TextBufferGeometry", function() { return va }), n.d(t, "SphereGeometry", function() { return ga }), n.d(t, "SphereBufferGeometry", function() { return ya }), n.d(t, "RingGeometry", function() { return _a }), n.d(t, "RingBufferGeometry", function() { return xa }), n.d(t, "PlaneGeometry", function() { return or }), n.d(t, "PlaneBufferGeometry", function() { return ar }), n.d(t, "LatheGeometry", function() { return ba }), n.d(t, "LatheBufferGeometry", function() { return wa }), n.d(t, "ShapeGeometry", function() { return Ma }), n.d(t, "ShapeBufferGeometry", function() { return Ea }), n.d(t, "ExtrudeGeometry", function() { return ha }), n.d(t, "ExtrudeBufferGeometry", function() { return pa }), n.d(t, "EdgesGeometry", function() { return Ta }), n.d(t, "ConeGeometry", function() { return Ra }), n.d(t, "ConeBufferGeometry", function() { return La }), n.d(t, "CylinderGeometry", function() { return Aa }), n.d(t, "CylinderBufferGeometry", function() { return Pa }), n.d(t, "CircleGeometry", function() { return Ca }), n.d(t, "CircleBufferGeometry", function() { return Oa }), n.d(t, "BoxGeometry", function() { return rr }), n.d(t, "BoxBufferGeometry", function() { return ir }), n.d(t, "ShadowMaterial", function() { return Da }), n.d(t, "SpriteMaterial", function() { return io }), n.d(t, "RawShaderMaterial", function() { return Ua }), n.d(t, "ShaderMaterial", function() { return br }), n.d(t, "PointsMaterial", function() { return mo }), n.d(t, "MeshPhysicalMaterial", function() { return Na }), n.d(t, "MeshStandardMaterial", function() { return Fa }), n.d(t, "MeshPhongMaterial", function() { return Ba }), n.d(t, "MeshToonMaterial", function() { return za }), n.d(t, "MeshNormalMaterial", function() { return ka }), n.d(t, "MeshLambertMaterial", function() { return Ga }), n.d(t, "MeshDepthMaterial", function() { return ji }), n.d(t, "MeshDistanceMaterial", function() { return Hi }), n.d(t, "MeshBasicMaterial", function() { return Er }), n.d(t, "MeshMatcapMaterial", function() { return ja }), n.d(t, "LineDashedMaterial", function() { return Ha }), n.d(t, "LineBasicMaterial", function() { return lo }), n.d(t, "Material", function() { return xr }), n.d(t, "Float64BufferAttribute", function() { return $n }), n.d(t, "Float32BufferAttribute", function() { return Kn }), n.d(t, "Uint32BufferAttribute", function() { return Jn }), n.d(t, "Int32BufferAttribute", function() { return Zn }), n.d(t, "Uint16BufferAttribute", function() { return Yn }), n.d(t, "Int16BufferAttribute", function() { return qn }), n.d(t, "Uint8ClampedBufferAttribute", function() { return Xn }), n.d(t, "Uint8BufferAttribute", function() { return Wn }), n.d(t, "Int8BufferAttribute", function() { return Vn }), n.d(t, "BufferAttribute", function() { return Hn }), n.d(t, "ArcCurve", function() { return rs }), n.d(t, "CatmullRomCurve3", function() { return cs }), n.d(t, "CubicBezierCurve", function() { return ds }), n.d(t, "CubicBezierCurve3", function() { return fs }), n.d(t, "EllipseCurve", function() { return ns }), n.d(t, "LineCurve", function() { return ms }), n.d(t, "LineCurve3", function() { return vs }), n.d(t, "QuadraticBezierCurve", function() { return gs }), n.d(t, "QuadraticBezierCurve3", function() { return ys }), n.d(t, "SplineCurve", function() { return _s }), n.d(t, "REVISION", function() { return m }), n.d(t, "MOUSE", function() { return v }), n.d(t, "CullFaceNone", function() { return g }), n.d(t, "CullFaceBack", function() { return y }), n.d(t, "CullFaceFront", function() { return _ }), n.d(t, "CullFaceFrontBack", function() { return x }), n.d(t, "FrontFaceDirectionCW", function() { return b }), n.d(t, "FrontFaceDirectionCCW", function() { return w }), n.d(t, "BasicShadowMap", function() { return M }), n.d(t, "PCFShadowMap", function() { return E }), n.d(t, "PCFSoftShadowMap", function() { return S }), n.d(t, "FrontSide", function() { return T }), n.d(t, "BackSide", function() { return A }), n.d(t, "DoubleSide", function() { return P }), n.d(t, "FlatShading", function() { return R }), n.d(t, "SmoothShading", function() { return L }), n.d(t, "NoColors", function() { return C }), n.d(t, "FaceColors", function() { return O }), n.d(t, "VertexColors", function() { return I }), n.d(t, "NoBlending", function() { return D }), n.d(t, "NormalBlending", function() { return U }), n.d(t, "AdditiveBlending", function() { return F }), n.d(t, "SubtractiveBlending", function() { return N }), n.d(t, "MultiplyBlending", function() { return B }), n.d(t, "CustomBlending", function() { return z }), n.d(t, "AddEquation", function() { return k }), n.d(t, "SubtractEquation", function() { return G }), n.d(t, "ReverseSubtractEquation", function() { return j }), n.d(t, "MinEquation", function() { return H }), n.d(t, "MaxEquation", function() { return V }), n.d(t, "ZeroFactor", function() { return W }), n.d(t, "OneFactor", function() { return X }), n.d(t, "SrcColorFactor", function() { return q }), n.d(t, "OneMinusSrcColorFactor", function() { return Y }), n.d(t, "SrcAlphaFactor", function() { return Z }), n.d(t, "OneMinusSrcAlphaFactor", function() { return J }), n.d(t, "DstAlphaFactor", function() { return K }), n.d(t, "OneMinusDstAlphaFactor", function() { return $ }), n.d(t, "DstColorFactor", function() { return Q }), n.d(t, "OneMinusDstColorFactor", function() { return ee }), n.d(t, "SrcAlphaSaturateFactor", function() { return te }), n.d(t, "NeverDepth", function() { return ne }), n.d(t, "AlwaysDepth", function() { return re }), n.d(t, "LessDepth", function() { return ie }), n.d(t, "LessEqualDepth", function() { return oe }), n.d(t, "EqualDepth", function() { return ae }), n.d(t, "GreaterEqualDepth", function() { return se }), n.d(t, "GreaterDepth", function() { return ue }), n.d(t, "NotEqualDepth", function() { return ce }), n.d(t, "MultiplyOperation", function() { return le }), n.d(t, "MixOperation", function() { return he }), n.d(t, "AddOperation", function() { return pe }), n.d(t, "NoToneMapping", function() { return de }), n.d(t, "LinearToneMapping", function() { return fe }), n.d(t, "ReinhardToneMapping", function() { return me }), n.d(t, "Uncharted2ToneMapping", function() { return ve }), n.d(t, "CineonToneMapping", function() { return ge }), n.d(t, "UVMapping", function() { return ye }), n.d(t, "CubeReflectionMapping", function() { return _e }), n.d(t, "CubeRefractionMapping", function() { return xe }), n.d(t, "EquirectangularReflectionMapping", function() { return be }), n.d(t, "EquirectangularRefractionMapping", function() { return we }), n.d(t, "SphericalReflectionMapping", function() { return Me }), n.d(t, "CubeUVReflectionMapping", function() { return Ee }), n.d(t, "CubeUVRefractionMapping", function() { return Se }), n.d(t, "RepeatWrapping", function() { return Te }), n.d(t, "ClampToEdgeWrapping", function() { return Ae }), n.d(t, "MirroredRepeatWrapping", function() { return Pe }), n.d(t, "NearestFilter", function() { return Re }), n.d(t, "NearestMipMapNearestFilter", function() { return Le }), n.d(t, "NearestMipMapLinearFilter", function() { return Ce }), n.d(t, "LinearFilter", function() { return Oe }), n.d(t, "LinearMipMapNearestFilter", function() { return Ie }), n.d(t, "LinearMipMapLinearFilter", function() { return De }), n.d(t, "UnsignedByteType", function() { return Ue }), n.d(t, "ByteType", function() { return Fe }), n.d(t, "ShortType", function() { return Ne }), n.d(t, "UnsignedShortType", function() { return Be }), n.d(t, "IntType", function() { return ze }), n.d(t, "UnsignedIntType", function() { return ke }), n.d(t, "FloatType", function() { return Ge }), n.d(t, "HalfFloatType", function() { return je }), n.d(t, "UnsignedShort4444Type", function() { return He }), n.d(t, "UnsignedShort5551Type", function() { return Ve }), n.d(t, "UnsignedShort565Type", function() { return We }), n.d(t, "UnsignedInt248Type", function() { return Xe }), n.d(t, "AlphaFormat", function() { return qe }), n.d(t, "RGBFormat", function() { return Ye }), n.d(t, "RGBAFormat", function() { return Ze }), n.d(t, "LuminanceFormat", function() { return Je }), n.d(t, "LuminanceAlphaFormat", function() { return Ke }), n.d(t, "RGBEFormat", function() { return $e }), n.d(t, "DepthFormat", function() { return Qe }), n.d(t, "DepthStencilFormat", function() { return et }), n.d(t, "RedFormat", function() { return tt }), n.d(t, "RGB_S3TC_DXT1_Format", function() { return nt }), n.d(t, "RGBA_S3TC_DXT1_Format", function() { return rt }), n.d(t, "RGBA_S3TC_DXT3_Format", function() { return it }), n.d(t, "RGBA_S3TC_DXT5_Format", function() { return ot }), n.d(t, "RGB_PVRTC_4BPPV1_Format", function() { return at }), n.d(t, "RGB_PVRTC_2BPPV1_Format", function() { return st }), n.d(t, "RGBA_PVRTC_4BPPV1_Format", function() { return ut }), n.d(t, "RGBA_PVRTC_2BPPV1_Format", function() { return ct }), n.d(t, "RGB_ETC1_Format", function() { return lt }), n.d(t, "RGBA_ASTC_4x4_Format", function() { return ht }), n.d(t, "RGBA_ASTC_5x4_Format", function() { return pt }), n.d(t, "RGBA_ASTC_5x5_Format", function() { return dt }), n.d(t, "RGBA_ASTC_6x5_Format", function() { return ft }), n.d(t, "RGBA_ASTC_6x6_Format", function() { return mt }), n.d(t, "RGBA_ASTC_8x5_Format", function() { return vt }), n.d(t, "RGBA_ASTC_8x6_Format", function() { return gt }), n.d(t, "RGBA_ASTC_8x8_Format", function() { return yt }), n.d(t, "RGBA_ASTC_10x5_Format", function() { return _t }), n.d(t, "RGBA_ASTC_10x6_Format", function() { return xt }), n.d(t, "RGBA_ASTC_10x8_Format", function() { return bt }), n.d(t, "RGBA_ASTC_10x10_Format", function() { return wt }), n.d(t, "RGBA_ASTC_12x10_Format", function() { return Mt }), n.d(t, "RGBA_ASTC_12x12_Format", function() { return Et }), n.d(t, "LoopOnce", function() { return St }), n.d(t, "LoopRepeat", function() { return Tt }), n.d(t, "LoopPingPong", function() { return At }), n.d(t, "InterpolateDiscrete", function() { return Pt }), n.d(t, "InterpolateLinear", function() { return Rt }), n.d(t, "InterpolateSmooth", function() { return Lt }), n.d(t, "ZeroCurvatureEnding", function() { return Ct }), n.d(t, "ZeroSlopeEnding", function() { return Ot }), n.d(t, "WrapAroundEnding", function() { return It }), n.d(t, "TrianglesDrawMode", function() { return Dt }), n.d(t, "TriangleStripDrawMode", function() { return Ut }), n.d(t, "TriangleFanDrawMode", function() { return Ft }), n.d(t, "LinearEncoding", function() { return Nt }), n.d(t, "sRGBEncoding", function() { return Bt }), n.d(t, "GammaEncoding", function() { return zt }), n.d(t, "RGBEEncoding", function() { return kt }), n.d(t, "LogLuvEncoding", function() { return Gt }), n.d(t, "RGBM7Encoding", function() { return jt }), n.d(t, "RGBM16Encoding", function() { return Ht }), n.d(t, "RGBDEncoding", function() { return Vt }), n.d(t, "BasicDepthPacking", function() { return Wt }), n.d(t, "RGBADepthPacking", function() { return Xt }), n.d(t, "TangentSpaceNormalMap", function() { return qt }), n.d(t, "ObjectSpaceNormalMap", function() { return Yt }), n.d(t, "CubeGeometry", function() { return rr }), n.d(t, "Face4", function() { return Lc }), n.d(t, "LineStrip", function() { return Cc }), n.d(t, "LinePieces", function() { return Oc }), n.d(t, "MeshFaceMaterial", function() { return Ic }), n.d(t, "MultiMaterial", function() { return Dc }), n.d(t, "PointCloud", function() { return Uc }), n.d(t, "Particle", function() { return Fc }), n.d(t, "ParticleSystem", function() { return Nc }), n.d(t, "PointCloudMaterial", function() { return Bc }), n.d(t, "ParticleBasicMaterial", function() { return zc }), n.d(t, "ParticleSystemMaterial", function() { return kc }), n.d(t, "Vertex", function() { return Gc }), n.d(t, "DynamicBufferAttribute", function() { return jc }), n.d(t, "Int8Attribute", function() { return Hc }), n.d(t, "Uint8Attribute", function() { return Vc }), n.d(t, "Uint8ClampedAttribute", function() { return Wc }), n.d(t, "Int16Attribute", function() { return Xc }), n.d(t, "Uint16Attribute", function() { return qc }), n.d(t, "Int32Attribute", function() { return Yc }), n.d(t, "Uint32Attribute", function() { return Zc }), n.d(t, "Float32Attribute", function() { return Jc }), n.d(t, "Float64Attribute", function() { return Kc }), n.d(t, "ClosedSplineCurve3", function() { return $c }), n.d(t, "SplineCurve3", function() { return Qc }), n.d(t, "Spline", function() { return el }), n.d(t, "AxisHelper", function() { return tl }), n.d(t, "BoundingBoxHelper", function() { return nl }), n.d(t, "EdgesHelper", function() { return rl }), n.d(t, "WireframeHelper", function() { return il }), n.d(t, "XHRLoader", function() { return ol }), n.d(t, "BinaryTextureLoader", function() { return al }), n.d(t, "GeometryUtils", function() { return sl }), n.d(t, "Projector", function() { return ul }), n.d(t, "CanvasRenderer", function() { return cl }), n.d(t, "SceneUtils", function() { return ll }), n.d(t, "LensFlare", function() { return hl }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e }), void 0 === Math.sign && (Math.sign = function(e) { return e < 0 ? -1 : e > 0 ? 1 : +e }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function() { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function(e) {
                if (void 0 === e || null === e) throw new TypeError("Cannot convert undefined or null to object");
                for (var t = Object(e), n = 1; n < arguments.length; n++) {
                    var r = arguments[n];
                    if (void 0 !== r && null !== r)
                        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
                }
                return t
            }), Object.assign(r.prototype, {
                addEventListener: function(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                },
                hasEventListener: function(e, t) { if (void 0 === this._listeners) return !1; var n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) },
                removeEventListener: function(e, t) { if (void 0 !== this._listeners) { var n = this._listeners[e]; if (void 0 !== n) { var r = n.indexOf(t); - 1 !== r && n.splice(r, 1) } } },
                dispatchEvent: function(e) { if (void 0 !== this._listeners) { var t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e) } } }
            });
            var i, o, a, s, u, c, l, h, p, d, f, m = "97",
                v = { LEFT: 0, MIDDLE: 1, RIGHT: 2 },
                g = 0,
                y = 1,
                _ = 2,
                x = 3,
                b = 0,
                w = 1,
                M = 0,
                E = 1,
                S = 2,
                T = 0,
                A = 1,
                P = 2,
                R = 1,
                L = 2,
                C = 0,
                O = 1,
                I = 2,
                D = 0,
                U = 1,
                F = 2,
                N = 3,
                B = 4,
                z = 5,
                k = 100,
                G = 101,
                j = 102,
                H = 103,
                V = 104,
                W = 200,
                X = 201,
                q = 202,
                Y = 203,
                Z = 204,
                J = 205,
                K = 206,
                $ = 207,
                Q = 208,
                ee = 209,
                te = 210,
                ne = 0,
                re = 1,
                ie = 2,
                oe = 3,
                ae = 4,
                se = 5,
                ue = 6,
                ce = 7,
                le = 0,
                he = 1,
                pe = 2,
                de = 0,
                fe = 1,
                me = 2,
                ve = 3,
                ge = 4,
                ye = 300,
                _e = 301,
                xe = 302,
                be = 303,
                we = 304,
                Me = 305,
                Ee = 306,
                Se = 307,
                Te = 1e3,
                Ae = 1001,
                Pe = 1002,
                Re = 1003,
                Le = 1004,
                Ce = 1005,
                Oe = 1006,
                Ie = 1007,
                De = 1008,
                Ue = 1009,
                Fe = 1010,
                Ne = 1011,
                Be = 1012,
                ze = 1013,
                ke = 1014,
                Ge = 1015,
                je = 1016,
                He = 1017,
                Ve = 1018,
                We = 1019,
                Xe = 1020,
                qe = 1021,
                Ye = 1022,
                Ze = 1023,
                Je = 1024,
                Ke = 1025,
                $e = Ze,
                Qe = 1026,
                et = 1027,
                tt = 1028,
                nt = 33776,
                rt = 33777,
                it = 33778,
                ot = 33779,
                at = 35840,
                st = 35841,
                ut = 35842,
                ct = 35843,
                lt = 36196,
                ht = 37808,
                pt = 37809,
                dt = 37810,
                ft = 37811,
                mt = 37812,
                vt = 37813,
                gt = 37814,
                yt = 37815,
                _t = 37816,
                xt = 37817,
                bt = 37818,
                wt = 37819,
                Mt = 37820,
                Et = 37821,
                St = 2200,
                Tt = 2201,
                At = 2202,
                Pt = 2300,
                Rt = 2301,
                Lt = 2302,
                Ct = 2400,
                Ot = 2401,
                It = 2402,
                Dt = 0,
                Ut = 1,
                Ft = 2,
                Nt = 3e3,
                Bt = 3001,
                zt = 3007,
                kt = 3002,
                Gt = 3003,
                jt = 3004,
                Ht = 3005,
                Vt = 3006,
                Wt = 3200,
                Xt = 3201,
                qt = 0,
                Yt = 1,
                Zt = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        for (var e = [], t = 0; t < 256; t++) e[t] = (t < 16 ? "0" : "") + t.toString(16);
                        return function() {
                            var t = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0;
                            return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & n] + e[n >> 8 & 255] + "-" + e[n >> 16 & 15 | 64] + e[n >> 24 & 255] + "-" + e[63 & r | 128] + e[r >> 8 & 255] + "-" + e[r >> 16 & 255] + e[r >> 24 & 255] + e[255 & i] + e[i >> 8 & 255] + e[i >> 16 & 255] + e[i >> 24 & 255]).toUpperCase()
                        }
                    }(),
                    clamp: function(e, t, n) { return Math.max(t, Math.min(n, e)) },
                    euclideanModulo: function(e, t) { return (e % t + t) % t },
                    mapLinear: function(e, t, n, r, i) { return r + (e - t) * (i - r) / (n - t) },
                    lerp: function(e, t, n) { return (1 - n) * e + n * t },
                    smoothstep: function(e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) },
                    smootherstep: function(e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) },
                    randInt: function(e, t) { return e + Math.floor(Math.random() * (t - e + 1)) },
                    randFloat: function(e, t) { return e + Math.random() * (t - e) },
                    randFloatSpread: function(e) { return e * (.5 - Math.random()) },
                    degToRad: function(e) { return e * Zt.DEG2RAD },
                    radToDeg: function(e) { return e * Zt.RAD2DEG },
                    isPowerOfTwo: function(e) { return 0 == (e & e - 1) && 0 !== e },
                    ceilPowerOfTwo: function(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) },
                    floorPowerOfTwo: function(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }
                };

            function Jt(e, t) { this.x = e || 0, this.y = t || 0 }

            function Kt() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") }

            function $t(e, t, n, r) { this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1 }

            function Qt(e, t, n) { this.x = e || 0, this.y = t || 0, this.z = n || 0 }

            function en() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") }
            Object.defineProperties(Jt.prototype, { width: { get: function() { return this.x }, set: function(e) { this.x = e } }, height: { get: function() { return this.y }, set: function(e) { this.y = e } } }), Object.assign(Jt.prototype, {
                isVector2: !0,
                set: function(e, t) { return this.x = e, this.y = t, this },
                setScalar: function(e) { return this.x = e, this.y = e, this },
                setX: function(e) { return this.x = e, this },
                setY: function(e) { return this.y = e, this },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() { return new this.constructor(this.x, this.y) },
                copy: function(e) { return this.x = e.x, this.y = e.y, this },
                add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) },
                addScalar: function(e) { return this.x += e, this.y += e, this },
                addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this },
                addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this },
                sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) },
                subScalar: function(e) { return this.x -= e, this.y -= e, this },
                subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this },
                multiply: function(e) { return this.x *= e.x, this.y *= e.y, this },
                multiplyScalar: function(e) { return this.x *= e, this.y *= e, this },
                divide: function(e) { return this.x /= e.x, this.y /= e.y, this },
                divideScalar: function(e) { return this.multiplyScalar(1 / e) },
                applyMatrix3: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                },
                min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this },
                max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this },
                clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this },
                clampScalar: (i = new Jt, o = new Jt, function(e, t) { return i.set(e, e), o.set(t, t), this.clamp(i, o) }),
                clampLength: function(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) },
                floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this },
                ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this },
                round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this },
                roundToZero: function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this },
                negate: function() { return this.x = -this.x, this.y = -this.y, this },
                dot: function(e) { return this.x * e.x + this.y * e.y },
                cross: function(e) { return this.x * e.y - this.y * e.x },
                lengthSq: function() { return this.x * this.x + this.y * this.y },
                length: function() { return Math.sqrt(this.x * this.x + this.y * this.y) },
                manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) },
                normalize: function() { return this.divideScalar(this.length() || 1) },
                angle: function() { var e = Math.atan2(this.y, this.x); return e < 0 && (e += 2 * Math.PI), e },
                distanceTo: function(e) { return Math.sqrt(this.distanceToSquared(e)) },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                },
                manhattanDistanceTo: function(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) },
                setLength: function(e) { return this.normalize().multiplyScalar(e) },
                lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this },
                lerpVectors: function(e, t, n) { return this.subVectors(t, e).multiplyScalar(n).add(e) },
                equals: function(e) { return e.x === this.x && e.y === this.y },
                fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this },
                toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e },
                fromBufferAttribute: function(e, t, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this },
                rotateAround: function(e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = this.x - e.x,
                        o = this.y - e.y;
                    return this.x = i * n - o * r + e.x, this.y = i * r + o * n + e.y, this
                }
            }), Object.assign(Kt.prototype, {
                isMatrix4: !0,
                set: function(e, t, n, r, i, o, a, s, u, c, l, h, p, d, f, m) { var v = this.elements; return v[0] = e, v[4] = t, v[8] = n, v[12] = r, v[1] = i, v[5] = o, v[9] = a, v[13] = s, v[2] = u, v[6] = c, v[10] = l, v[14] = h, v[3] = p, v[7] = d, v[11] = f, v[15] = m, this },
                identity: function() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this },
                clone: function() { return (new Kt).fromArray(this.elements) },
                copy: function(e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                },
                copyPosition: function(e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                },
                extractBasis: function(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this },
                makeBasis: function(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this },
                extractRotation: (d = new Qt, function(e) {
                    var t = this.elements,
                        n = e.elements,
                        r = 1 / d.setFromMatrixColumn(e, 0).length(),
                        i = 1 / d.setFromMatrixColumn(e, 1).length(),
                        o = 1 / d.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }),
                makeRotationFromEuler: function(e) {
                    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z,
                        o = Math.cos(n),
                        a = Math.sin(n),
                        s = Math.cos(r),
                        u = Math.sin(r),
                        c = Math.cos(i),
                        l = Math.sin(i);
                    if ("XYZ" === e.order) {
                        var h = o * c,
                            p = o * l,
                            d = a * c,
                            f = a * l;
                        t[0] = s * c, t[4] = -s * l, t[8] = u, t[1] = p + d * u, t[5] = h - f * u, t[9] = -a * s, t[2] = f - h * u, t[6] = d + p * u, t[10] = o * s
                    } else if ("YXZ" === e.order) {
                        var m = s * c,
                            v = s * l,
                            g = u * c,
                            y = u * l;
                        t[0] = m + y * a, t[4] = g * a - v, t[8] = o * u, t[1] = o * l, t[5] = o * c, t[9] = -a, t[2] = v * a - g, t[6] = y + m * a, t[10] = o * s
                    } else if ("ZXY" === e.order) {
                        m = s * c, v = s * l, g = u * c, y = u * l;
                        t[0] = m - y * a, t[4] = -o * l, t[8] = g + v * a, t[1] = v + g * a, t[5] = o * c, t[9] = y - m * a, t[2] = -o * u, t[6] = a, t[10] = o * s
                    } else if ("ZYX" === e.order) {
                        h = o * c, p = o * l, d = a * c, f = a * l;
                        t[0] = s * c, t[4] = d * u - p, t[8] = h * u + f, t[1] = s * l, t[5] = f * u + h, t[9] = p * u - d, t[2] = -u, t[6] = a * s, t[10] = o * s
                    } else if ("YZX" === e.order) {
                        var _ = o * s,
                            x = o * u,
                            b = a * s,
                            w = a * u;
                        t[0] = s * c, t[4] = w - _ * l, t[8] = b * l + x, t[1] = l, t[5] = o * c, t[9] = -a * c, t[2] = -u * c, t[6] = x * l + b, t[10] = _ - w * l
                    } else if ("XZY" === e.order) {
                        _ = o * s, x = o * u, b = a * s, w = a * u;
                        t[0] = s * c, t[4] = -l, t[8] = u * c, t[1] = _ * l + w, t[5] = o * c, t[9] = x * l - b, t[2] = b * l - x, t[6] = a * c, t[10] = w * l + _
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                makeRotationFromQuaternion: (h = new Qt(0, 0, 0), p = new Qt(1, 1, 1), function(e) { return this.compose(h, e, p) }),
                lookAt: (u = new Qt, c = new Qt, l = new Qt, function(e, t, n) { var r = this.elements; return l.subVectors(e, t), 0 === l.lengthSq() && (l.z = 1), l.normalize(), u.crossVectors(n, l), 0 === u.lengthSq() && (1 === Math.abs(n.z) ? l.x += 1e-4 : l.z += 1e-4, l.normalize(), u.crossVectors(n, l)), u.normalize(), c.crossVectors(l, u), r[0] = u.x, r[4] = c.x, r[8] = l.x, r[1] = u.y, r[5] = c.y, r[9] = l.y, r[2] = u.z, r[6] = c.z, r[10] = l.z, this }),
                multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) },
                premultiply: function(e) { return this.multiplyMatrices(e, this) },
                multiplyMatrices: function(e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        u = n[12],
                        c = n[1],
                        l = n[5],
                        h = n[9],
                        p = n[13],
                        d = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        _ = n[11],
                        x = n[15],
                        b = r[0],
                        w = r[4],
                        M = r[8],
                        E = r[12],
                        S = r[1],
                        T = r[5],
                        A = r[9],
                        P = r[13],
                        R = r[2],
                        L = r[6],
                        C = r[10],
                        O = r[14],
                        I = r[3],
                        D = r[7],
                        U = r[11],
                        F = r[15];
                    return i[0] = o * b + a * S + s * R + u * I, i[4] = o * w + a * T + s * L + u * D, i[8] = o * M + a * A + s * C + u * U, i[12] = o * E + a * P + s * O + u * F, i[1] = c * b + l * S + h * R + p * I, i[5] = c * w + l * T + h * L + p * D, i[9] = c * M + l * A + h * C + p * U, i[13] = c * E + l * P + h * O + p * F, i[2] = d * b + f * S + m * R + v * I, i[6] = d * w + f * T + m * L + v * D, i[10] = d * M + f * A + m * C + v * U, i[14] = d * E + f * P + m * O + v * F, i[3] = g * b + y * S + _ * R + x * I, i[7] = g * w + y * T + _ * L + x * D, i[11] = g * M + y * A + _ * C + x * U, i[15] = g * E + y * P + _ * O + x * F, this
                },
                multiplyScalar: function(e) { var t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this },
                applyToBufferAttribute: function() { var e = new Qt; return function(t) { for (var n = 0, r = t.count; n < r; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix4(this), t.setXYZ(n, e.x, e.y, e.z); return t } }(),
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[4],
                        r = e[8],
                        i = e[12],
                        o = e[1],
                        a = e[5],
                        s = e[9],
                        u = e[13],
                        c = e[2],
                        l = e[6],
                        h = e[10],
                        p = e[14];
                    return e[3] * (+i * s * l - r * u * l - i * a * h + n * u * h + r * a * p - n * s * p) + e[7] * (+t * s * p - t * u * h + i * o * h - r * o * p + r * u * c - i * s * c) + e[11] * (+t * u * l - t * a * p - i * o * l + n * o * p + i * a * c - n * u * c) + e[15] * (-r * a * c - t * s * l + t * a * h + r * o * l - n * o * h + n * s * c)
                },
                transpose: function() { var e, t = this.elements; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this },
                setPosition: function(e) { var t = this.elements; return t[12] = e.x, t[13] = e.y, t[14] = e.z, this },
                getInverse: function(e, t) {
                    var n = this.elements,
                        r = e.elements,
                        i = r[0],
                        o = r[1],
                        a = r[2],
                        s = r[3],
                        u = r[4],
                        c = r[5],
                        l = r[6],
                        h = r[7],
                        p = r[8],
                        d = r[9],
                        f = r[10],
                        m = r[11],
                        v = r[12],
                        g = r[13],
                        y = r[14],
                        _ = r[15],
                        x = d * y * h - g * f * h + g * l * m - c * y * m - d * l * _ + c * f * _,
                        b = v * f * h - p * y * h - v * l * m + u * y * m + p * l * _ - u * f * _,
                        w = p * g * h - v * d * h + v * c * m - u * g * m - p * c * _ + u * d * _,
                        M = v * d * l - p * g * l - v * c * f + u * g * f + p * c * y - u * d * y,
                        E = i * x + o * b + a * w + s * M;
                    if (0 === E) { var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"; if (!0 === t) throw new Error(S); return console.warn(S), this.identity() }
                    var T = 1 / E;
                    return n[0] = x * T, n[1] = (g * f * s - d * y * s - g * a * m + o * y * m + d * a * _ - o * f * _) * T, n[2] = (c * y * s - g * l * s + g * a * h - o * y * h - c * a * _ + o * l * _) * T, n[3] = (d * l * s - c * f * s - d * a * h + o * f * h + c * a * m - o * l * m) * T, n[4] = b * T, n[5] = (p * y * s - v * f * s + v * a * m - i * y * m - p * a * _ + i * f * _) * T, n[6] = (v * l * s - u * y * s - v * a * h + i * y * h + u * a * _ - i * l * _) * T, n[7] = (u * f * s - p * l * s + p * a * h - i * f * h - u * a * m + i * l * m) * T, n[8] = w * T, n[9] = (v * d * s - p * g * s - v * o * m + i * g * m + p * o * _ - i * d * _) * T, n[10] = (u * g * s - v * c * s + v * o * h - i * g * h - u * o * _ + i * c * _) * T, n[11] = (p * c * s - u * d * s - p * o * h + i * d * h + u * o * m - i * c * m) * T, n[12] = M * T, n[13] = (p * g * a - v * d * a + v * o * f - i * g * f - p * o * y + i * d * y) * T, n[14] = (v * c * a - u * g * a - v * o * l + i * g * l + u * o * y - i * c * y) * T, n[15] = (u * d * a - p * c * a + p * o * l - i * d * l - u * o * f + i * c * f) * T, this
                },
                scale: function(e) {
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z;
                    return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                },
                getMaxScaleOnAxis: function() {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, r))
                },
                makeTranslation: function(e, t, n) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this },
                makeRotationX: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 - n,
                        o = e.x,
                        a = e.y,
                        s = e.z,
                        u = i * o,
                        c = i * a;
                    return this.set(u * o + n, u * a - r * s, u * s + r * a, 0, u * a + r * s, c * a + n, c * s - r * o, 0, u * s - r * a, c * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this },
                makeShear: function(e, t, n) { return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this },
                compose: function(e, t, n) {
                    var r = this.elements,
                        i = t._x,
                        o = t._y,
                        a = t._z,
                        s = t._w,
                        u = i + i,
                        c = o + o,
                        l = a + a,
                        h = i * u,
                        p = i * c,
                        d = i * l,
                        f = o * c,
                        m = o * l,
                        v = a * l,
                        g = s * u,
                        y = s * c,
                        _ = s * l,
                        x = n.x,
                        b = n.y,
                        w = n.z;
                    return r[0] = (1 - (f + v)) * x, r[1] = (p + _) * x, r[2] = (d - y) * x, r[3] = 0, r[4] = (p - _) * b, r[5] = (1 - (h + v)) * b, r[6] = (m + g) * b, r[7] = 0, r[8] = (d + y) * w, r[9] = (m - g) * w, r[10] = (1 - (h + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                },
                decompose: (a = new Qt, s = new Kt, function(e, t, n) {
                    var r = this.elements,
                        i = a.set(r[0], r[1], r[2]).length(),
                        o = a.set(r[4], r[5], r[6]).length(),
                        u = a.set(r[8], r[9], r[10]).length();
                    this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], s.copy(this);
                    var c = 1 / i,
                        l = 1 / o,
                        h = 1 / u;
                    return s.elements[0] *= c, s.elements[1] *= c, s.elements[2] *= c, s.elements[4] *= l, s.elements[5] *= l, s.elements[6] *= l, s.elements[8] *= h, s.elements[9] *= h, s.elements[10] *= h, t.setFromRotationMatrix(s), n.x = i, n.y = o, n.z = u, this
                }),
                makePerspective: function(e, t, n, r, i, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * i / (t - e),
                        u = 2 * i / (n - r),
                        c = (t + e) / (t - e),
                        l = (n + r) / (n - r),
                        h = -(o + i) / (o - i),
                        p = -2 * o * i / (o - i);
                    return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = u, a[9] = l, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function(e, t, n, r, i, o) {
                    var a = this.elements,
                        s = 1 / (t - e),
                        u = 1 / (n - r),
                        c = 1 / (o - i),
                        l = (t + e) * s,
                        h = (n + r) * u,
                        p = (o + i) * c;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -l, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function(e, t) { void 0 === t && (t = 0); for (var n = 0; n < 16; n++) this.elements[n] = e[n + t]; return this },
                toArray: function(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e }
            }), Object.assign($t, {
                slerp: function(e, t, n, r) { return n.copy(e).slerp(t, r) },
                slerpFlat: function(e, t, n, r, i, o, a) {
                    var s = n[r + 0],
                        u = n[r + 1],
                        c = n[r + 2],
                        l = n[r + 3],
                        h = i[o + 0],
                        p = i[o + 1],
                        d = i[o + 2],
                        f = i[o + 3];
                    if (l !== f || s !== h || u !== p || c !== d) {
                        var m = 1 - a,
                            v = s * h + u * p + c * d + l * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var _ = Math.sqrt(y),
                                x = Math.atan2(_, v * g);
                            m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                        }
                        var b = a * g;
                        if (s = s * m + h * b, u = u * m + p * b, c = c * m + d * b, l = l * m + f * b, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + u * u + c * c + l * l);
                            s *= w, u *= w, c *= w, l *= w
                        }
                    }
                    e[t] = s, e[t + 1] = u, e[t + 2] = c, e[t + 3] = l
                }
            }), Object.defineProperties($t.prototype, { x: { get: function() { return this._x }, set: function(e) { this._x = e, this.onChangeCallback() } }, y: { get: function() { return this._y }, set: function(e) { this._y = e, this.onChangeCallback() } }, z: { get: function() { return this._z }, set: function(e) { this._z = e, this.onChangeCallback() } }, w: { get: function() { return this._w }, set: function(e) { this._w = e, this.onChangeCallback() } } }), Object.assign($t.prototype, {
                isQuaternion: !0,
                set: function(e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._w = r, this.onChangeCallback(), this },
                clone: function() { return new this.constructor(this._x, this._y, this._z, this._w) },
                copy: function(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this },
                setFromEuler: function(e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        o = e.order,
                        a = Math.cos,
                        s = Math.sin,
                        u = a(n / 2),
                        c = a(r / 2),
                        l = a(i / 2),
                        h = s(n / 2),
                        p = s(r / 2),
                        d = s(i / 2);
                    return "XYZ" === o ? (this._x = h * c * l + u * p * d, this._y = u * p * l - h * c * d, this._z = u * c * d + h * p * l, this._w = u * c * l - h * p * d) : "YXZ" === o ? (this._x = h * c * l + u * p * d, this._y = u * p * l - h * c * d, this._z = u * c * d - h * p * l, this._w = u * c * l + h * p * d) : "ZXY" === o ? (this._x = h * c * l - u * p * d, this._y = u * p * l + h * c * d, this._z = u * c * d + h * p * l, this._w = u * c * l - h * p * d) : "ZYX" === o ? (this._x = h * c * l - u * p * d, this._y = u * p * l + h * c * d, this._z = u * c * d - h * p * l, this._w = u * c * l + h * p * d) : "YZX" === o ? (this._x = h * c * l + u * p * d, this._y = u * p * l + h * c * d, this._z = u * c * d - h * p * l, this._w = u * c * l - h * p * d) : "XZY" === o && (this._x = h * c * l - u * p * d, this._y = u * p * l - h * c * d, this._z = u * c * d + h * p * l, this._w = u * c * l + h * p * d), !1 !== t && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(e, t) {
                    var n = t / 2,
                        r = Math.sin(n);
                    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(e) {
                    var t, n = e.elements,
                        r = n[0],
                        i = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        u = n[9],
                        c = n[2],
                        l = n[6],
                        h = n[10],
                        p = r + s + h;
                    return p > 0 ? (t = .5 / Math.sqrt(p + 1), this._w = .25 / t, this._x = (l - u) * t, this._y = (o - c) * t, this._z = (a - i) * t) : r > s && r > h ? (t = 2 * Math.sqrt(1 + r - s - h), this._w = (l - u) / t, this._x = .25 * t, this._y = (i + a) / t, this._z = (o + c) / t) : s > h ? (t = 2 * Math.sqrt(1 + s - r - h), this._w = (o - c) / t, this._x = (i + a) / t, this._y = .25 * t, this._z = (u + l) / t) : (t = 2 * Math.sqrt(1 + h - r - s), this._w = (a - i) / t, this._x = (o + c) / t, this._y = (u + l) / t, this._z = .25 * t), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() { var e, t = new Qt; return function(n, r) { return void 0 === t && (t = new Qt), (e = n.dot(r) + 1) < 1e-6 ? (e = 0, Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, r), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize() } }(),
                angleTo: function(e) { return 2 * Math.acos(Math.abs(Zt.clamp(this.dot(e), -1, 1))) },
                rotateTowards: function(e, t) { var n = this.angleTo(e); if (0 === n) return this; var r = Math.min(1, t / n); return this.slerp(e, r), this },
                inverse: function() { return this.conjugate() },
                conjugate: function() { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this },
                dot: function(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w },
                lengthSq: function() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w },
                length: function() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) },
                normalize: function() { var e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this },
                multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) },
                premultiply: function(e) { return this.multiplyQuaternions(e, this) },
                multiplyQuaternions: function(e, t) {
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        o = e._w,
                        a = t._x,
                        s = t._y,
                        u = t._z,
                        c = t._w;
                    return this._x = n * c + o * a + r * u - i * s, this._y = r * c + o * s + i * a - n * u, this._z = i * c + o * u + n * s - r * a, this._w = o * c - n * a - r * s - i * u, this.onChangeCallback(), this
                },
                slerp: function(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        r = this._y,
                        i = this._z,
                        o = this._w,
                        a = o * e._w + n * e._x + r * e._y + i * e._z;
                    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) { var u = 1 - t; return this._w = u * o + t * this._w, this._x = u * n + t * this._x, this._y = u * r + t * this._y, this._z = u * i + t * this._z, this.normalize() }
                    var c = Math.sqrt(s),
                        l = Math.atan2(c, a),
                        h = Math.sin((1 - t) * l) / c,
                        p = Math.sin(t * l) / c;
                    return this._w = o * h + this._w * p, this._x = n * h + this._x * p, this._y = r * h + this._y * p, this._z = i * h + this._z * p, this.onChangeCallback(), this
                },
                equals: function(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w },
                fromArray: function(e, t) { return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this },
                toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e },
                onChange: function(e) { return this.onChangeCallback = e, this },
                onChangeCallback: function() {}
            }), Object.assign(Qt.prototype, {
                isVector3: !0,
                set: function(e, t, n) { return this.x = e, this.y = t, this.z = n, this },
                setScalar: function(e) { return this.x = e, this.y = e, this.z = e, this },
                setX: function(e) { return this.x = e, this },
                setY: function(e) { return this.y = e, this },
                setZ: function(e) { return this.z = e, this },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() { return new this.constructor(this.x, this.y, this.z) },
                copy: function(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this },
                add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) },
                addScalar: function(e) { return this.x += e, this.y += e, this.z += e, this },
                addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this },
                addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this },
                sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) },
                subScalar: function(e) { return this.x -= e, this.y -= e, this.z -= e, this },
                subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this },
                multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) },
                multiplyScalar: function(e) { return this.x *= e, this.y *= e, this.z *= e, this },
                multiplyVectors: function(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this },
                applyEuler: (f = new $t, function(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(f.setFromEuler(e)) }),
                applyAxisAngle: function() { var e = new $t; return function(t, n) { return this.applyQuaternion(e.setFromAxisAngle(t, n)) } }(),
                applyMatrix3: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                },
                applyMatrix4: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements,
                        o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o, this
                },
                applyQuaternion: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.x,
                        o = e.y,
                        a = e.z,
                        s = e.w,
                        u = s * t + o * r - a * n,
                        c = s * n + a * t - i * r,
                        l = s * r + i * n - o * t,
                        h = -i * t - o * n - a * r;
                    return this.x = u * s + h * -i + c * -a - l * -o, this.y = c * s + h * -o + l * -i - u * -a, this.z = l * s + h * -a + u * -o - c * -i, this
                },
                project: function(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) },
                unproject: function() { var e = new Kt; return function(t) { return this.applyMatrix4(e.getInverse(t.projectionMatrix)).applyMatrix4(t.matrixWorld) } }(),
                transformDirection: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                },
                divide: function(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this },
                divideScalar: function(e) { return this.multiplyScalar(1 / e) },
                min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this },
                max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this },
                clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this },
                clampScalar: function() {
                    var e = new Qt,
                        t = new Qt;
                    return function(n, r) { return e.set(n, n, n), t.set(r, r, r), this.clamp(e, t) }
                }(),
                clampLength: function(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) },
                floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this },
                ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this },
                round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this },
                roundToZero: function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this },
                negate: function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this },
                dot: function(e) { return this.x * e.x + this.y * e.y + this.z * e.z },
                lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z },
                length: function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) },
                manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) },
                normalize: function() { return this.divideScalar(this.length() || 1) },
                setLength: function(e) { return this.normalize().multiplyScalar(e) },
                lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this },
                lerpVectors: function(e, t, n) { return this.subVectors(t, e).multiplyScalar(n).add(e) },
                cross: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) },
                crossVectors: function(e, t) {
                    var n = e.x,
                        r = e.y,
                        i = e.z,
                        o = t.x,
                        a = t.y,
                        s = t.z;
                    return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
                },
                projectOnVector: function(e) { var t = e.dot(this) / e.lengthSq(); return this.copy(e).multiplyScalar(t) },
                projectOnPlane: function() { var e = new Qt; return function(t) { return e.copy(this).projectOnVector(t), this.sub(e) } }(),
                reflect: function() { var e = new Qt; return function(t) { return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t))) } }(),
                angleTo: function(e) { var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()); return Math.acos(Zt.clamp(t, -1, 1)) },
                distanceTo: function(e) { return Math.sqrt(this.distanceToSquared(e)) },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        n = this.y - e.y,
                        r = this.z - e.z;
                    return t * t + n * n + r * r
                },
                manhattanDistanceTo: function(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) },
                setFromSpherical: function(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) },
                setFromSphericalCoords: function(e, t, n) { var r = Math.sin(t) * e; return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this },
                setFromCylindrical: function(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) },
                setFromCylindricalCoords: function(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this },
                setFromMatrixPosition: function(e) { var t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this },
                setFromMatrixScale: function(e) {
                    var t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = r, this
                },
                setFromMatrixColumn: function(e, t) { return this.fromArray(e.elements, 4 * t) },
                equals: function(e) { return e.x === this.x && e.y === this.y && e.z === this.z },
                fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this },
                toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e },
                fromBufferAttribute: function(e, t, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this }
            }), Object.assign(en.prototype, {
                isMatrix3: !0,
                set: function(e, t, n, r, i, o, a, s, u) { var c = this.elements; return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = i, c[5] = s, c[6] = n, c[7] = o, c[8] = u, this },
                identity: function() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this },
                clone: function() { return (new this.constructor).fromArray(this.elements) },
                copy: function(e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                },
                setFromMatrix4: function(e) { var t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this },
                applyToBufferAttribute: function() { var e = new Qt; return function(t) { for (var n = 0, r = t.count; n < r; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix3(this), t.setXYZ(n, e.x, e.y, e.z); return t } }(),
                multiply: function(e) { return this.multiplyMatrices(this, e) },
                premultiply: function(e) { return this.multiplyMatrices(e, this) },
                multiplyMatrices: function(e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[3],
                        s = n[6],
                        u = n[1],
                        c = n[4],
                        l = n[7],
                        h = n[2],
                        p = n[5],
                        d = n[8],
                        f = r[0],
                        m = r[3],
                        v = r[6],
                        g = r[1],
                        y = r[4],
                        _ = r[7],
                        x = r[2],
                        b = r[5],
                        w = r[8];
                    return i[0] = o * f + a * g + s * x, i[3] = o * m + a * y + s * b, i[6] = o * v + a * _ + s * w, i[1] = u * f + c * g + l * x, i[4] = u * m + c * y + l * b, i[7] = u * v + c * _ + l * w, i[2] = h * f + p * g + d * x, i[5] = h * m + p * y + d * b, i[8] = h * v + p * _ + d * w, this
                },
                multiplyScalar: function(e) { var t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this },
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        o = e[4],
                        a = e[5],
                        s = e[6],
                        u = e[7],
                        c = e[8];
                    return t * o * c - t * a * u - n * i * c + n * a * s + r * i * u - r * o * s
                },
                getInverse: function(e, t) {
                    e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = e.elements,
                        r = this.elements,
                        i = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        u = n[4],
                        c = n[5],
                        l = n[6],
                        h = n[7],
                        p = n[8],
                        d = p * u - c * h,
                        f = c * l - p * s,
                        m = h * s - u * l,
                        v = i * d + o * f + a * m;
                    if (0 === v) { var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"; if (!0 === t) throw new Error(g); return console.warn(g), this.identity() }
                    var y = 1 / v;
                    return r[0] = d * y, r[1] = (a * h - p * o) * y, r[2] = (c * o - a * u) * y, r[3] = f * y, r[4] = (p * i - a * l) * y, r[5] = (a * s - c * i) * y, r[6] = m * y, r[7] = (o * l - h * i) * y, r[8] = (u * i - o * s) * y, this
                },
                transpose: function() { var e, t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this },
                getNormalMatrix: function(e) { return this.setFromMatrix4(e).getInverse(this).transpose() },
                transposeIntoArray: function(e) { var t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this },
                setUvTransform: function(e, t, n, r, i, o, a) {
                    var s = Math.cos(i),
                        u = Math.sin(i);
                    this.set(n * s, n * u, -n * (s * o + u * a) + o + e, -r * u, r * s, -r * (-u * o + s * a) + a + t, 0, 0, 1)
                },
                scale: function(e, t) { var n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this },
                rotate: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e),
                        r = this.elements,
                        i = r[0],
                        o = r[3],
                        a = r[6],
                        s = r[1],
                        u = r[4],
                        c = r[7];
                    return r[0] = t * i + n * s, r[3] = t * o + n * u, r[6] = t * a + n * c, r[1] = -n * i + t * s, r[4] = -n * o + t * u, r[7] = -n * a + t * c, this
                },
                translate: function(e, t) { var n = this.elements; return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this },
                equals: function(e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function(e, t) { void 0 === t && (t = 0); for (var n = 0; n < 9; n++) this.elements[n] = e[n + t]; return this },
                toArray: function(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e }
            });
            var tn, nn, rn, on, an, sn = {
                    getDataURL: function(e) {
                        var t;
                        if (e instanceof HTMLCanvasElement) t = e;
                        else {
                            (t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = e.width, t.height = e.height;
                            var n = t.getContext("2d");
                            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height)
                        }
                        return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                    }
                },
                un = 0;

            function cn(e, t, n, r, i, o, a, s, u, c) { Object.defineProperty(this, "id", { value: un++ }), this.uuid = Zt.generateUUID(), this.name = "", this.image = void 0 !== e ? e : cn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : cn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : Ae, this.wrapT = void 0 !== r ? r : Ae, this.magFilter = void 0 !== i ? i : Oe, this.minFilter = void 0 !== o ? o : De, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== a ? a : Ze, this.type = void 0 !== s ? s : Ue, this.offset = new Jt(0, 0), this.repeat = new Jt(1, 1), this.center = new Jt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new en, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : Nt, this.version = 0, this.onUpdate = null }

            function ln(e, t, n, r) { this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1 }

            function hn(e, t, n) { this.width = e, this.height = t, this.scissor = new ln(0, 0, e, t), this.scissorTest = !1, this.viewport = new ln(0, 0, e, t), void 0 === (n = n || {}).minFilter && (n.minFilter = Oe), this.texture = new cn(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.generateMipmaps = void 0 === n.generateMipmaps || n.generateMipmaps, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null }

            function pn(e, t, n) { hn.call(this, e, t, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0 }

            function dn(e, t, n, r, i, o, a, s, u, c, l, h) { cn.call(this, null, o, a, s, u, c, r, i, l, h), this.image = { data: e, width: t, height: n }, this.magFilter = void 0 !== u ? u : Re, this.minFilter = void 0 !== c ? c : Re, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 }

            function fn(e, t) { this.min = void 0 !== e ? e : new Qt(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Qt(-1 / 0, -1 / 0, -1 / 0) }

            function mn(e, t) { this.center = void 0 !== e ? e : new Qt, this.radius = void 0 !== t ? t : 0 }

            function vn(e, t) { this.normal = void 0 !== e ? e : new Qt(1, 0, 0), this.constant = void 0 !== t ? t : 0 }

            function gn(e, t, n, r, i, o) { this.planes = [void 0 !== e ? e : new vn, void 0 !== t ? t : new vn, void 0 !== n ? n : new vn, void 0 !== r ? r : new vn, void 0 !== i ? i : new vn, void 0 !== o ? o : new vn] }
            cn.DEFAULT_IMAGE = void 0, cn.DEFAULT_MAPPING = ye, cn.prototype = Object.assign(Object.create(r.prototype), {
                constructor: cn,
                isTexture: !0,
                updateMatrix: function() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this },
                toJSON: function(e) {
                    var t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    var n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY };
                    if (void 0 !== this.image) {
                        var r = this.image;
                        if (void 0 === r.uuid && (r.uuid = Zt.generateUUID()), !t && void 0 === e.images[r.uuid]) {
                            var i;
                            if (Array.isArray(r)) { i = []; for (var o = 0, a = r.length; o < a; o++) i.push(sn.getDataURL(r[o])) } else i = sn.getDataURL(r);
                            e.images[r.uuid] = { uuid: r.uuid, url: i }
                        }
                        n.image = r.uuid
                    }
                    return t || (e.textures[this.uuid] = n), n
                },
                dispose: function() { this.dispatchEvent({ type: "dispose" }) },
                transformUv: function(e) {
                    if (this.mapping !== ye) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case Te:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case Ae:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case Pe:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case Te:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case Ae:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case Pe:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
            }), Object.defineProperty(cn.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(ln.prototype, {
                isVector4: !0,
                set: function(e, t, n, r) { return this.x = e, this.y = t, this.z = n, this.w = r, this },
                setScalar: function(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this },
                setX: function(e) { return this.x = e, this },
                setY: function(e) { return this.y = e, this },
                setZ: function(e) { return this.z = e, this },
                setW: function(e) { return this.w = e, this },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() { return new this.constructor(this.x, this.y, this.z, this.w) },
                copy: function(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this },
                add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) },
                addScalar: function(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this },
                addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this },
                addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this },
                sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) },
                subScalar: function(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this },
                subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this },
                multiplyScalar: function(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this },
                applyMatrix4: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        o = e.elements;
                    return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i, this
                },
                divideScalar: function(e) { return this.multiplyScalar(1 / e) },
                setAxisAngleFromQuaternion: function(e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this },
                setAxisAngleFromRotationMatrix: function(e) {
                    var t, n, r, i, o = e.elements,
                        a = o[0],
                        s = o[4],
                        u = o[8],
                        c = o[1],
                        l = o[5],
                        h = o[9],
                        p = o[2],
                        d = o[6],
                        f = o[10];
                    if (Math.abs(s - c) < .01 && Math.abs(u - p) < .01 && Math.abs(h - d) < .01) {
                        if (Math.abs(s + c) < .1 && Math.abs(u + p) < .1 && Math.abs(h + d) < .1 && Math.abs(a + l + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var m = (a + 1) / 2,
                            v = (l + 1) / 2,
                            g = (f + 1) / 2,
                            y = (s + c) / 4,
                            _ = (u + p) / 4,
                            x = (h + d) / 4;
                        return m > v && m > g ? m < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = y / (n = Math.sqrt(m)), i = _ / n) : v > g ? v < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = y / (r = Math.sqrt(v)), i = x / r) : g < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = _ / (i = Math.sqrt(g)), r = x / i), this.set(n, r, i, t), this
                    }
                    var b = Math.sqrt((d - h) * (d - h) + (u - p) * (u - p) + (c - s) * (c - s));
                    return Math.abs(b) < .001 && (b = 1), this.x = (d - h) / b, this.y = (u - p) / b, this.z = (c - s) / b, this.w = Math.acos((a + l + f - 1) / 2), this
                },
                min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this },
                max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this },
                clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this },
                clampScalar: function() { var e, t; return function(n, r) { return void 0 === e && (e = new ln, t = new ln), e.set(n, n, n, n), t.set(r, r, r, r), this.clamp(e, t) } }(),
                clampLength: function(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) },
                floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this },
                ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this },
                round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this },
                roundToZero: function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this },
                negate: function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this },
                dot: function(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w },
                lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w },
                length: function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) },
                manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) },
                normalize: function() { return this.divideScalar(this.length() || 1) },
                setLength: function(e) { return this.normalize().multiplyScalar(e) },
                lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this },
                lerpVectors: function(e, t, n) { return this.subVectors(t, e).multiplyScalar(n).add(e) },
                equals: function(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w },
                fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this },
                toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e },
                fromBufferAttribute: function(e, t, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this }
            }), hn.prototype = Object.assign(Object.create(r.prototype), { constructor: hn, isWebGLRenderTarget: !0, setSize: function(e, t) { this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), pn.prototype = Object.create(hn.prototype), pn.prototype.constructor = pn, pn.prototype.isWebGLRenderTargetCube = !0, dn.prototype = Object.create(cn.prototype), dn.prototype.constructor = dn, dn.prototype.isDataTexture = !0, Object.assign(fn.prototype, {
                isBox3: !0,
                set: function(e, t) { return this.min.copy(e), this.max.copy(t), this },
                setFromArray: function(e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, u = e.length; s < u; s += 3) {
                        var c = e[s],
                            l = e[s + 1],
                            h = e[s + 2];
                        c < t && (t = c), l < n && (n = l), h < r && (r = h), c > i && (i = c), l > o && (o = l), h > a && (a = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, o, a), this
                },
                setFromBufferAttribute: function(e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, u = e.count; s < u; s++) {
                        var c = e.getX(s),
                            l = e.getY(s),
                            h = e.getZ(s);
                        c < t && (t = c), l < n && (n = l), h < r && (r = h), c > i && (i = c), l > o && (o = l), h > a && (a = h)
                    }
                    return this.min.set(t, n, r), this.max.set(i, o, a), this
                },
                setFromPoints: function(e) { this.makeEmpty(); for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]); return this },
                setFromCenterAndSize: function() { var e = new Qt; return function(t, n) { var r = e.copy(n).multiplyScalar(.5); return this.min.copy(t).sub(r), this.max.copy(t).add(r), this } }(),
                setFromObject: function(e) { return this.makeEmpty(), this.expandByObject(e) },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.min.copy(e.min), this.max.copy(e.max), this },
                makeEmpty: function() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this },
                isEmpty: function() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z },
                getCenter: function(e) { return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Qt), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) },
                getSize: function(e) { return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Qt), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) },
                expandByPoint: function(e) { return this.min.min(e), this.max.max(e), this },
                expandByVector: function(e) { return this.min.sub(e), this.max.add(e), this },
                expandByScalar: function(e) { return this.min.addScalar(-e), this.max.addScalar(e), this },
                expandByObject: function() {
                    var e, t, n, r = new Qt;

                    function i(i) {
                        var o = i.geometry;
                        if (void 0 !== o)
                            if (o.isGeometry) { var a = o.vertices; for (t = 0, n = a.length; t < n; t++) r.copy(a[t]), r.applyMatrix4(i.matrixWorld), e.expandByPoint(r) } else if (o.isBufferGeometry) {
                            var s = o.attributes.position;
                            if (void 0 !== s)
                                for (t = 0, n = s.count; t < n; t++) r.fromBufferAttribute(s, t).applyMatrix4(i.matrixWorld), e.expandByPoint(r)
                        }
                    }
                    return function(t) { return e = this, t.updateMatrixWorld(!0), t.traverse(i), this }
                }(),
                containsPoint: function(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) },
                containsBox: function(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z },
                getParameter: function(e, t) { return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Qt), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) },
                intersectsBox: function(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) },
                intersectsSphere: (nn = new Qt, function(e) { return this.clampPoint(e.center, nn), nn.distanceToSquared(e.center) <= e.radius * e.radius }),
                intersectsPlane: function(e) { var t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant },
                intersectsTriangle: function() {
                    var e = new Qt,
                        t = new Qt,
                        n = new Qt,
                        r = new Qt,
                        i = new Qt,
                        o = new Qt,
                        a = new Qt,
                        s = new Qt,
                        u = new Qt,
                        c = new Qt;

                    function l(r) {
                        var i, o;
                        for (i = 0, o = r.length - 3; i <= o; i += 3) {
                            a.fromArray(r, i);
                            var s = u.x * Math.abs(a.x) + u.y * Math.abs(a.y) + u.z * Math.abs(a.z),
                                c = e.dot(a),
                                l = t.dot(a),
                                h = n.dot(a);
                            if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > s) return !1
                        }
                        return !0
                    }
                    return function(a) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(s), u.subVectors(this.max, s), e.subVectors(a.a, s), t.subVectors(a.b, s), n.subVectors(a.c, s), r.subVectors(t, e), i.subVectors(n, t), o.subVectors(e, n);
                        var h = [0, -r.z, r.y, 0, -i.z, i.y, 0, -o.z, o.y, r.z, 0, -r.x, i.z, 0, -i.x, o.z, 0, -o.x, -r.y, r.x, 0, -i.y, i.x, 0, -o.y, o.x, 0];
                        return !!l(h) && (!!l(h = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (c.crossVectors(r, i), l(h = [c.x, c.y, c.z])))
                    }
                }(),
                clampPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Qt), t.copy(e).clamp(this.min, this.max) },
                distanceToPoint: function() { var e = new Qt; return function(t) { return e.copy(t).clamp(this.min, this.max).sub(t).length() } }(),
                getBoundingSphere: function() { var e = new Qt; return function(t) { return void 0 === t && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), t = new mn), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t } }(),
                intersect: function(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this },
                union: function(e) { return this.min.min(e.min), this.max.max(e.max), this },
                applyMatrix4: (tn = [new Qt, new Qt, new Qt, new Qt, new Qt, new Qt, new Qt, new Qt], function(e) { return this.isEmpty() ? this : (tn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), tn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), tn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), tn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), tn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), tn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), tn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), tn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(tn), this) }),
                translate: function(e) { return this.min.add(e), this.max.add(e), this },
                equals: function(e) { return e.min.equals(this.min) && e.max.equals(this.max) }
            }), Object.assign(mn.prototype, {
                set: function(e, t) { return this.center.copy(e), this.radius = t, this },
                setFromPoints: (rn = new fn, function(e, t) {
                    var n = this.center;
                    void 0 !== t ? n.copy(t) : rn.setFromPoints(e).getCenter(n);
                    for (var r = 0, i = 0, o = e.length; i < o; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                    return this.radius = Math.sqrt(r), this
                }),
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.center.copy(e.center), this.radius = e.radius, this },
                empty: function() { return this.radius <= 0 },
                containsPoint: function(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius },
                distanceToPoint: function(e) { return e.distanceTo(this.center) - this.radius },
                intersectsSphere: function(e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t },
                intersectsBox: function(e) { return e.intersectsSphere(this) },
                intersectsPlane: function(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius },
                clampPoint: function(e, t) { var n = this.center.distanceToSquared(e); return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Qt), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t },
                getBoundingBox: function(e) { return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new fn), e.set(this.center, this.center), e.expandByScalar(this.radius), e },
                applyMatrix4: function(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this },
                translate: function(e) { return this.center.add(e), this },
                equals: function(e) { return e.center.equals(this.center) && e.radius === this.radius }
            }), Object.assign(vn.prototype, {
                set: function(e, t) { return this.normal.copy(e), this.constant = t, this },
                setComponents: function(e, t, n, r) { return this.normal.set(e, t, n), this.constant = r, this },
                setFromNormalAndCoplanarPoint: function(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this },
                setFromCoplanarPoints: function() {
                    var e = new Qt,
                        t = new Qt;
                    return function(n, r, i) { var o = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize(); return this.setFromNormalAndCoplanarPoint(o, n), this }
                }(),
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.normal.copy(e.normal), this.constant = e.constant, this },
                normalize: function() { var e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this },
                negate: function() { return this.constant *= -1, this.normal.negate(), this },
                distanceToPoint: function(e) { return this.normal.dot(e) + this.constant },
                distanceToSphere: function(e) { return this.distanceToPoint(e.center) - e.radius },
                projectPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Qt), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) },
                intersectLine: function() {
                    var e = new Qt;
                    return function(t, n) {
                        void 0 === n && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new Qt);
                        var r = t.delta(e),
                            i = this.normal.dot(r);
                        if (0 === i) return 0 === this.distanceToPoint(t.start) ? n.copy(t.start) : void 0;
                        var o = -(t.start.dot(this.normal) + this.constant) / i;
                        return o < 0 || o > 1 ? void 0 : n.copy(r).multiplyScalar(o).add(t.start)
                    }
                }(),
                intersectsLine: function(e) {
                    var t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                },
                intersectsBox: function(e) { return e.intersectsPlane(this) },
                intersectsSphere: function(e) { return e.intersectsPlane(this) },
                coplanarPoint: function(e) { return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Qt), e.copy(this.normal).multiplyScalar(-this.constant) },
                applyMatrix4: function() {
                    var e = new Qt,
                        t = new en;
                    return function(n, r) {
                        var i = r || t.getNormalMatrix(n),
                            o = this.coplanarPoint(e).applyMatrix4(n),
                            a = this.normal.applyMatrix3(i).normalize();
                        return this.constant = -o.dot(a), this
                    }
                }(),
                translate: function(e) { return this.constant -= e.dot(this.normal), this },
                equals: function(e) { return e.normal.equals(this.normal) && e.constant === this.constant }
            }), Object.assign(gn.prototype, {
                set: function(e, t, n, r, i, o) { var a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]); return this },
                setFromMatrix: function(e) {
                    var t = this.planes,
                        n = e.elements,
                        r = n[0],
                        i = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        u = n[5],
                        c = n[6],
                        l = n[7],
                        h = n[8],
                        p = n[9],
                        d = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return t[0].setComponents(a - r, l - s, f - h, y - m).normalize(), t[1].setComponents(a + r, l + s, f + h, y + m).normalize(), t[2].setComponents(a + i, l + u, f + p, y + v).normalize(), t[3].setComponents(a - i, l - u, f - p, y - v).normalize(), t[4].setComponents(a - o, l - c, f - d, y - g).normalize(), t[5].setComponents(a + o, l + c, f + d, y + g).normalize(), this
                },
                intersectsObject: (an = new mn, function(e) { var t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), an.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(an) }),
                intersectsSprite: function() { var e = new mn; return function(t) { return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e) } }(),
                intersectsSphere: function(e) { for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) { if (t[i].distanceToPoint(n) < r) return !1 } return !0 },
                intersectsBox: (on = new Qt, function(e) { for (var t = this.planes, n = 0; n < 6; n++) { var r = t[n]; if (on.x = r.normal.x > 0 ? e.max.x : e.min.x, on.y = r.normal.y > 0 ? e.max.y : e.min.y, on.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(on) < 0) return !1 } return !0 }),
                containsPoint: function(e) {
                    for (var t = this.planes, n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            });
            var yn, _n, xn, bn = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "\nvec3 transformed = vec3( position );\n", beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n", bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n", envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n", gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n", lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n", normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n", dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n", background_vert: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n", cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n" },
                wn = {
                    merge: function(e) { for (var t = {}, n = 0; n < e.length; n++) { var r = this.clone(e[n]); for (var i in r) t[i] = r[i] } return t },
                    clone: function(e) {
                        var t = {};
                        for (var n in e)
                            for (var r in t[n] = {}, e[n]) {
                                var i = e[n][r];
                                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                            }
                        return t
                    }
                },
                Mn = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };

            function En(e, t, n) { return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n) }
            Object.assign(En.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this },
                setScalar: function(e) { return this.r = e, this.g = e, this.b = e, this },
                setHex: function(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this },
                setRGB: function(e, t, n) { return this.r = e, this.g = t, this.b = n, this },
                setHSL: function() {
                    function e(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e }
                    return function(t, n, r) {
                        if (t = Zt.euclideanModulo(t, 1), n = Zt.clamp(n, 0, 1), r = Zt.clamp(r, 0, 1), 0 === n) this.r = this.g = this.b = r;
                        else {
                            var i = r <= .5 ? r * (1 + n) : r + n - r * n,
                                o = 2 * r - i;
                            this.r = e(o, i, t + 1 / 3), this.g = e(o, i, t), this.b = e(o, i, t - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(e) {
                    function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                        var r, i = n[1],
                            o = n[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, t(r[5]), this;
                                if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, t(r[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(r[1]) / 360,
                                        s = parseInt(r[2], 10) / 100,
                                        u = parseInt(r[3], 10) / 100;
                                    return t(r[5]), this.setHSL(a, s, u)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) { var c, l = (c = n[1]).length; if (3 === l) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this; if (6 === l) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this }
                    e && e.length > 0 && (void 0 !== (c = Mn[e]) ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + e));
                    return this
                },
                clone: function() { return new this.constructor(this.r, this.g, this.b) },
                copy: function(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this },
                copyGammaToLinear: function(e, t) { return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this },
                copyLinearToGamma: function(e, t) { void 0 === t && (t = 2); var n = t > 0 ? 1 / t : 1; return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this },
                convertGammaToLinear: function(e) { return this.copyGammaToLinear(this, e), this },
                convertLinearToGamma: function(e) { return this.copyLinearToGamma(this, e), this },
                copySRGBToLinear: function() {
                    function e(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) }
                    return function(t) { return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this }
                }(),
                copyLinearToSRGB: function() {
                    function e(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 }
                    return function(t) { return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this }
                }(),
                convertSRGBToLinear: function() { return this.copySRGBToLinear(this), this },
                convertLinearToSRGB: function() { return this.copyLinearToSRGB(this), this },
                getHex: function() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 },
                getHexString: function() { return ("000000" + this.getHex().toString(16)).slice(-6) },
                getHSL: function(e) {
                    void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 });
                    var t, n, r = this.r,
                        i = this.g,
                        o = this.b,
                        a = Math.max(r, i, o),
                        s = Math.min(r, i, o),
                        u = (s + a) / 2;
                    if (s === a) t = 0, n = 0;
                    else {
                        var c = a - s;
                        switch (n = u <= .5 ? c / (a + s) : c / (2 - a - s), a) {
                            case r:
                                t = (i - o) / c + (i < o ? 6 : 0);
                                break;
                            case i:
                                t = (o - r) / c + 2;
                                break;
                            case o:
                                t = (r - i) / c + 4
                        }
                        t /= 6
                    }
                    return e.h = t, e.s = n, e.l = u, e
                },
                getStyle: function() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" },
                offsetHSL: (xn = {}, function(e, t, n) { return this.getHSL(xn), xn.h += e, xn.s += t, xn.l += n, this.setHSL(xn.h, xn.s, xn.l), this }),
                add: function(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this },
                addColors: function(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this },
                addScalar: function(e) { return this.r += e, this.g += e, this.b += e, this },
                sub: function(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this },
                multiply: function(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this },
                multiplyScalar: function(e) { return this.r *= e, this.g *= e, this.b *= e, this },
                lerp: function(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this },
                lerpHSL: (yn = { h: 0, s: 0, l: 0 }, _n = { h: 0, s: 0, l: 0 }, function(e, t) {
                    this.getHSL(yn), e.getHSL(_n);
                    var n = Zt.lerp(yn.h, _n.h, t),
                        r = Zt.lerp(yn.s, _n.s, t),
                        i = Zt.lerp(yn.l, _n.l, t);
                    return this.setHSL(n, r, i), this
                }),
                equals: function(e) { return e.r === this.r && e.g === this.g && e.b === this.b },
                fromArray: function(e, t) { return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this },
                toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e },
                toJSON: function() { return this.getHex() }
            });
            var Sn, Tn = { common: { diffuse: { value: new En(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new en }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Jt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new En(16777215) } }, lights: { ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new En(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new en } }, sprite: { diffuse: { value: new En(15658734) }, opacity: { value: 1 }, center: { value: new Jt(.5, .5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new en } } },
                An = { basic: { uniforms: wn.merge([Tn.common, Tn.specularmap, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.fog]), vertexShader: bn.meshbasic_vert, fragmentShader: bn.meshbasic_frag }, lambert: { uniforms: wn.merge([Tn.common, Tn.specularmap, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.emissivemap, Tn.fog, Tn.lights, { emissive: { value: new En(0) } }]), vertexShader: bn.meshlambert_vert, fragmentShader: bn.meshlambert_frag }, phong: { uniforms: wn.merge([Tn.common, Tn.specularmap, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.emissivemap, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, Tn.gradientmap, Tn.fog, Tn.lights, { emissive: { value: new En(0) }, specular: { value: new En(1118481) }, shininess: { value: 30 } }]), vertexShader: bn.meshphong_vert, fragmentShader: bn.meshphong_frag }, standard: { uniforms: wn.merge([Tn.common, Tn.envmap, Tn.aomap, Tn.lightmap, Tn.emissivemap, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, Tn.roughnessmap, Tn.metalnessmap, Tn.fog, Tn.lights, { emissive: { value: new En(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: bn.meshphysical_vert, fragmentShader: bn.meshphysical_frag }, matcap: { uniforms: wn.merge([Tn.common, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, Tn.fog, { matcap: { value: null } }]), vertexShader: bn.meshmatcap_vert, fragmentShader: bn.meshmatcap_frag }, points: { uniforms: wn.merge([Tn.points, Tn.fog]), vertexShader: bn.points_vert, fragmentShader: bn.points_frag }, dashed: { uniforms: wn.merge([Tn.common, Tn.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: bn.linedashed_vert, fragmentShader: bn.linedashed_frag }, depth: { uniforms: wn.merge([Tn.common, Tn.displacementmap]), vertexShader: bn.depth_vert, fragmentShader: bn.depth_frag }, normal: { uniforms: wn.merge([Tn.common, Tn.bumpmap, Tn.normalmap, Tn.displacementmap, { opacity: { value: 1 } }]), vertexShader: bn.normal_vert, fragmentShader: bn.normal_frag }, sprite: { uniforms: wn.merge([Tn.sprite, Tn.fog]), vertexShader: bn.sprite_vert, fragmentShader: bn.sprite_frag }, background: { uniforms: { t2D: { value: null } }, vertexShader: bn.background_vert, fragmentShader: bn.background_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: bn.cube_vert, fragmentShader: bn.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: bn.equirect_vert, fragmentShader: bn.equirect_frag }, distanceRGBA: { uniforms: wn.merge([Tn.common, Tn.displacementmap, { referencePosition: { value: new Qt }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: bn.distanceRGBA_vert, fragmentShader: bn.distanceRGBA_frag }, shadow: { uniforms: wn.merge([Tn.lights, Tn.fog, { color: { value: new En(0) }, opacity: { value: 1 } }]), vertexShader: bn.shadow_vert, fragmentShader: bn.shadow_frag } };

            function Pn() {
                var e = null,
                    t = !1,
                    n = null;

                function r(i, o) {!1 !== t && (n(i, o), e.requestAnimationFrame(r)) }
                return { start: function() {!0 !== t && null !== n && (e.requestAnimationFrame(r), t = !0) }, stop: function() { t = !1 }, setAnimationLoop: function(e) { n = e }, setContext: function(t) { e = t } }
            }

            function Rn(e) {
                var t = new WeakMap;
                return {
                    get: function(e) { return e.isInterleavedBufferAttribute && (e = e.data), t.get(e) },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var r = t.get(n);
                        r && (e.deleteBuffer(r.buffer), t.delete(n))
                    },
                    update: function(n, r) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var i = t.get(n);
                        void 0 === i ? t.set(n, function(t, n) {
                            var r = t.array,
                                i = t.dynamic ? e.DYNAMIC_DRAW : e.STATIC_DRAW,
                                o = e.createBuffer();
                            e.bindBuffer(n, o), e.bufferData(n, r, i), t.onUploadCallback();
                            var a = e.FLOAT;
                            return r instanceof Float32Array ? a = e.FLOAT : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? a = e.UNSIGNED_SHORT : r instanceof Int16Array ? a = e.SHORT : r instanceof Uint32Array ? a = e.UNSIGNED_INT : r instanceof Int32Array ? a = e.INT : r instanceof Int8Array ? a = e.BYTE : r instanceof Uint8Array && (a = e.UNSIGNED_BYTE), { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: t.version }
                        }(n, r)) : i.version < n.version && (function(t, n, r) {
                            var i = n.array,
                                o = n.updateRange;
                            e.bindBuffer(r, t), !1 === n.dynamic ? e.bufferData(r, i, e.STATIC_DRAW) : -1 === o.count ? e.bufferSubData(r, 0, i) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(r, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(i.buffer, n, r), i.version = n.version)
                    }
                }
            }

            function Ln(e, t, n, r, i, o) { this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new Qt, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new En, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0 }

            function Cn(e, t, n, r) { this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || Cn.DefaultOrder }

            function On() { this.mask = 1 }
            An.physical = { uniforms: wn.merge([An.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: bn.meshphysical_vert, fragmentShader: bn.meshphysical_frag }, Object.assign(Ln.prototype, { clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex; for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone(); for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone(); return this } }), Cn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Cn.DefaultOrder = "XYZ", Object.defineProperties(Cn.prototype, { x: { get: function() { return this._x }, set: function(e) { this._x = e, this.onChangeCallback() } }, y: { get: function() { return this._y }, set: function(e) { this._y = e, this.onChangeCallback() } }, z: { get: function() { return this._z }, set: function(e) { this._z = e, this.onChangeCallback() } }, order: { get: function() { return this._order }, set: function(e) { this._order = e, this.onChangeCallback() } } }), Object.assign(Cn.prototype, {
                isEuler: !0,
                set: function(e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this.onChangeCallback(), this },
                clone: function() { return new this.constructor(this._x, this._y, this._z, this._order) },
                copy: function(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this },
                setFromRotationMatrix: function(e, t, n) {
                    var r = Zt.clamp,
                        i = e.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        u = i[1],
                        c = i[5],
                        l = i[9],
                        h = i[2],
                        p = i[6],
                        d = i[10];
                    return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(u, o))) : "ZYX" === t ? (this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(u, o)) : (this._x = 0, this._z = Math.atan2(-a, c))) : "YZX" === t ? (this._z = Math.asin(r(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(-l, c), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === t ? (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-l, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this.onChangeCallback(), this
                },
                setFromQuaternion: function() { var e = new Kt; return function(t, n, r) { return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, n, r) } }(),
                setFromVector3: function(e, t) { return this.set(e.x, e.y, e.z, t || this._order) },
                reorder: (Sn = new $t, function(e) { return Sn.setFromEuler(this), this.setFromQuaternion(Sn, e) }),
                equals: function(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order },
                fromArray: function(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this },
                toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e },
                toVector3: function(e) { return e ? e.set(this._x, this._y, this._z) : new Qt(this._x, this._y, this._z) },
                onChange: function(e) { return this.onChangeCallback = e, this },
                onChangeCallback: function() {}
            }), Object.assign(On.prototype, { set: function(e) { this.mask = 1 << e | 0 }, enable: function(e) { this.mask |= 1 << e | 0 }, toggle: function(e) { this.mask ^= 1 << e | 0 }, disable: function(e) { this.mask &= ~(1 << e | 0) }, test: function(e) { return 0 != (this.mask & e.mask) } });
            var In, Dn, Un, Fn, Nn = 0;

            function Bn() {
                Object.defineProperty(this, "id", { value: Nn++ }), this.uuid = Zt.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Bn.DefaultUp.clone();
                var e = new Qt,
                    t = new Cn,
                    n = new $t,
                    r = new Qt(1, 1, 1);
                t.onChange(function() { n.setFromEuler(t, !1) }), n.onChange(function() { t.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { enumerable: !0, value: e }, rotation: { enumerable: !0, value: t }, quaternion: { enumerable: !0, value: n }, scale: { enumerable: !0, value: r }, modelViewMatrix: { value: new Kt }, normalMatrix: { value: new en } }), this.matrix = new Kt, this.matrixWorld = new Kt, this.matrixAutoUpdate = Bn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new On, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            Bn.DefaultUp = new Qt(0, 1, 0), Bn.DefaultMatrixAutoUpdate = !0, Bn.prototype = Object.assign(Object.create(r.prototype), {
                constructor: Bn,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(e) { this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale) },
                applyQuaternion: function(e) { return this.quaternion.premultiply(e), this },
                setRotationFromAxisAngle: function(e, t) { this.quaternion.setFromAxisAngle(e, t) },
                setRotationFromEuler: function(e) { this.quaternion.setFromEuler(e, !0) },
                setRotationFromMatrix: function(e) { this.quaternion.setFromRotationMatrix(e) },
                setRotationFromQuaternion: function(e) { this.quaternion.copy(e) },
                rotateOnAxis: (Fn = new $t, function(e, t) { return Fn.setFromAxisAngle(e, t), this.quaternion.multiply(Fn), this }),
                rotateOnWorldAxis: function() { var e = new $t; return function(t, n) { return e.setFromAxisAngle(t, n), this.quaternion.premultiply(e), this } }(),
                rotateX: function() { var e = new Qt(1, 0, 0); return function(t) { return this.rotateOnAxis(e, t) } }(),
                rotateY: function() { var e = new Qt(0, 1, 0); return function(t) { return this.rotateOnAxis(e, t) } }(),
                rotateZ: function() { var e = new Qt(0, 0, 1); return function(t) { return this.rotateOnAxis(e, t) } }(),
                translateOnAxis: function() { var e = new Qt; return function(t, n) { return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this } }(),
                translateX: function() { var e = new Qt(1, 0, 0); return function(t) { return this.translateOnAxis(e, t) } }(),
                translateY: function() { var e = new Qt(0, 1, 0); return function(t) { return this.translateOnAxis(e, t) } }(),
                translateZ: function() { var e = new Qt(0, 0, 1); return function(t) { return this.translateOnAxis(e, t) } }(),
                localToWorld: function(e) { return e.applyMatrix4(this.matrixWorld) },
                worldToLocal: (Un = new Kt, function(e) { return e.applyMatrix4(Un.getInverse(this.matrixWorld)) }),
                lookAt: function() {
                    var e = new $t,
                        t = new Kt,
                        n = new Qt,
                        r = new Qt;
                    return function(i, o, a) {
                        i.isVector3 ? n.copy(i) : n.set(i, o, a);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), r.setFromMatrixPosition(this.matrixWorld), this.isCamera ? t.lookAt(r, n, this.up) : t.lookAt(n, r, this.up), this.quaternion.setFromRotationMatrix(t), s && (t.extractRotation(s.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse()))
                    }
                }(),
                add: function(e) { if (arguments.length > 1) { for (var t = 0; t < arguments.length; t++) this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({ type: "added" }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) },
                remove: function(e) { if (arguments.length > 1) { for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]); return this } var n = this.children.indexOf(e); return -1 !== n && (e.parent = null, e.dispatchEvent({ type: "removed" }), this.children.splice(n, 1)), this },
                getObjectById: function(e) { return this.getObjectByProperty("id", e) },
                getObjectByName: function(e) { return this.getObjectByProperty("name", e) },
                getObjectByProperty: function(e, t) { if (this[e] === t) return this; for (var n = 0, r = this.children.length; n < r; n++) { var i = this.children[n].getObjectByProperty(e, t); if (void 0 !== i) return i } },
                getWorldPosition: function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Qt), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld) },
                getWorldQuaternion: (In = new Qt, Dn = new Qt, function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new $t), this.updateMatrixWorld(!0), this.matrixWorld.decompose(In, e, Dn), e }),
                getWorldScale: function() {
                    var e = new Qt,
                        t = new $t;
                    return function(n) { return void 0 === n && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new Qt), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, n), n }
                }(),
                getWorldDirection: function(e) { void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Qt), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() },
                raycast: function() {},
                traverse: function(e) { e(this); for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e) },
                traverseVisible: function(e) { if (!1 !== this.visible) { e(this); for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e) } },
                traverseAncestors: function(e) {
                    var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                },
                updateMatrix: function() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 },
                updateMatrixWorld: function(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e) },
                updateWorldMatrix: function(e, t) {
                    var n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                        for (var r = this.children, i = 0, o = r.length; i < o; i++) r[i].updateWorldMatrix(!1, !0)
                },
                toJSON: function(e) {
                    var t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
                    var r = {};

                    function i(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(e.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, u = a.length; s < u; s++) {
                                    var c = a[s];
                                    i(e.shapes, c)
                                } else i(e.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var l = [];
                            for (s = 0, u = this.material.length; s < u; s++) l.push(i(e.materials, this.material[s]));
                            r.material = l
                        } else r.material = i(e.materials, this.material);
                    if (this.children.length > 0) { r.children = []; for (s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(e).object) }
                    if (t) {
                        var h = m(e.geometries),
                            p = m(e.materials),
                            d = m(e.textures),
                            f = m(e.images);
                        a = m(e.shapes);
                        h.length > 0 && (n.geometries = h), p.length > 0 && (n.materials = p), d.length > 0 && (n.textures = d), f.length > 0 && (n.images = f), a.length > 0 && (n.shapes = a)
                    }
                    return n.object = r, n;

                    function m(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                },
                clone: function(e) { return (new this.constructor).copy(this, e) },
                copy: function(e, t) {
                    if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (var n = 0; n < e.children.length; n++) {
                            var r = e.children[n];
                            this.add(r.clone())
                        }
                    return this
                }
            });
            var zn, kn, Gn = 0;

            function jn() {
                Object.defineProperty(this, "id", { value: Gn += 2 }), this.uuid = Zt.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Hn(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0
            }

            function Vn(e, t, n) { Hn.call(this, new Int8Array(e), t, n) }

            function Wn(e, t, n) { Hn.call(this, new Uint8Array(e), t, n) }

            function Xn(e, t, n) { Hn.call(this, new Uint8ClampedArray(e), t, n) }

            function qn(e, t, n) { Hn.call(this, new Int16Array(e), t, n) }

            function Yn(e, t, n) { Hn.call(this, new Uint16Array(e), t, n) }

            function Zn(e, t, n) { Hn.call(this, new Int32Array(e), t, n) }

            function Jn(e, t, n) { Hn.call(this, new Uint32Array(e), t, n) }

            function Kn(e, t, n) { Hn.call(this, new Float32Array(e), t, n) }

            function $n(e, t, n) { Hn.call(this, new Float64Array(e), t, n) }

            function Qn() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 }

            function er(e) { if (0 === e.length) return -1 / 0; for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]); return t }
            jn.prototype = Object.assign(Object.create(r.prototype), {
                constructor: jn,
                isGeometry: !0,
                applyMatrix: function(e) {
                    for (var t = (new en).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) { this.vertices[n].applyMatrix4(e) }
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n];
                        i.normal.applyMatrix3(t).normalize();
                        for (var o = 0, a = i.vertexNormals.length; o < a; o++) i.vertexNormals[o].applyMatrix3(t).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function() { var e = new Kt; return function(t) { return e.makeRotationX(t), this.applyMatrix(e), this } }(),
                rotateY: function() { var e = new Kt; return function(t) { return e.makeRotationY(t), this.applyMatrix(e), this } }(),
                rotateZ: function() { var e = new Kt; return function(t) { return e.makeRotationZ(t), this.applyMatrix(e), this } }(),
                translate: function() { var e = new Kt; return function(t, n, r) { return e.makeTranslation(t, n, r), this.applyMatrix(e), this } }(),
                scale: function() { var e = new Kt; return function(t, n, r) { return e.makeScale(t, n, r), this.applyMatrix(e), this } }(),
                lookAt: (kn = new Bn, function(e) { kn.lookAt(e), kn.updateMatrix(), this.applyMatrix(kn.matrix) }),
                fromBufferGeometry: function(e) {
                    var t = this,
                        n = null !== e.index ? e.index.array : void 0,
                        r = e.attributes,
                        i = r.position.array,
                        o = void 0 !== r.normal ? r.normal.array : void 0,
                        a = void 0 !== r.color ? r.color.array : void 0,
                        s = void 0 !== r.uv ? r.uv.array : void 0,
                        u = void 0 !== r.uv2 ? r.uv2.array : void 0;
                    void 0 !== u && (this.faceVertexUvs[1] = []);
                    for (var c = [], l = [], h = [], p = 0, d = 0; p < i.length; p += 3, d += 2) t.vertices.push(new Qt(i[p], i[p + 1], i[p + 2])), void 0 !== o && c.push(new Qt(o[p], o[p + 1], o[p + 2])), void 0 !== a && t.colors.push(new En(a[p], a[p + 1], a[p + 2])), void 0 !== s && l.push(new Jt(s[d], s[d + 1])), void 0 !== u && h.push(new Jt(u[d], u[d + 1]));

                    function f(e, n, r, i) {
                        var p = new Ln(e, n, r, void 0 !== o ? [c[e].clone(), c[n].clone(), c[r].clone()] : [], void 0 !== a ? [t.colors[e].clone(), t.colors[n].clone(), t.colors[r].clone()] : [], i);
                        t.faces.push(p), void 0 !== s && t.faceVertexUvs[0].push([l[e].clone(), l[n].clone(), l[r].clone()]), void 0 !== u && t.faceVertexUvs[1].push([h[e].clone(), h[n].clone(), h[r].clone()])
                    }
                    var m = e.groups;
                    if (m.length > 0)
                        for (p = 0; p < m.length; p++)
                            for (var v = m[p], g = v.start, y = (d = g, g + v.count); d < y; d += 3) void 0 !== n ? f(n[d], n[d + 1], n[d + 2], v.materialIndex) : f(d, d + 1, d + 2, v.materialIndex);
                    else if (void 0 !== n)
                        for (p = 0; p < n.length; p += 3) f(n[p], n[p + 1], n[p + 2]);
                    else
                        for (p = 0; p < i.length / 3; p += 3) f(p, p + 1, p + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: (zn = new Qt, function() { return this.computeBoundingBox(), this.boundingBox.getCenter(zn).negate(), this.translate(zn.x, zn.y, zn.z), this }),
                normalize: function() {
                    this.computeBoundingSphere();
                    var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        n = 0 === t ? 1 : 1 / t,
                        r = new Kt;
                    return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
                },
                computeFaceNormals: function() {
                    for (var e = new Qt, t = new Qt, n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n],
                            o = this.vertices[i.a],
                            a = this.vertices[i.b],
                            s = this.vertices[i.c];
                        e.subVectors(s, a), t.subVectors(o, a), e.cross(t), e.normalize(), i.normal.copy(e)
                    }
                },
                computeVertexNormals: function(e) {
                    var t, n, r, i, o, a;
                    for (void 0 === e && (e = !0), a = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) a[t] = new Qt;
                    if (e) {
                        var s, u, c, l = new Qt,
                            h = new Qt;
                        for (r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], s = this.vertices[o.a], u = this.vertices[o.b], c = this.vertices[o.c], l.subVectors(c, u), h.subVectors(s, u), l.cross(h), a[o.a].add(l), a[o.b].add(l), a[o.c].add(l)
                    } else
                        for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) a[(o = this.faces[r]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (t = 0, n = this.vertices.length; t < n; t++) a[t].normalize();
                    for (r = 0, i = this.faces.length; r < i; r++) {
                        var p = (o = this.faces[r]).vertexNormals;
                        3 === p.length ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(), p[1] = a[o.b].clone(), p[2] = a[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var e, t, n;
                    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                        var r = (n = this.faces[e]).vertexNormals;
                        3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var e, t, n, r, i;
                    for (n = 0, r = this.faces.length; n < r; n++)
                        for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
                    var o = new jn;
                    for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            var a = this.morphNormals[e].faceNormals,
                                s = this.morphNormals[e].vertexNormals;
                            for (n = 0, r = this.faces.length; n < r; n++) u = new Qt, c = { a: new Qt, b: new Qt, c: new Qt }, a.push(u), s.push(c)
                        }
                        var u, c, l = this.morphNormals[e];
                        for (o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], u = l.faceNormals[n], c = l.vertexNormals[n], u.copy(i.normal), c.a.copy(i.vertexNormals[0]), c.b.copy(i.vertexNormals[1]), c.c.copy(i.vertexNormals[2])
                    }
                    for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
                },
                computeBoundingBox: function() { null === this.boundingBox && (this.boundingBox = new fn), this.boundingBox.setFromPoints(this.vertices) },
                computeBoundingSphere: function() { null === this.boundingSphere && (this.boundingSphere = new mn), this.boundingSphere.setFromPoints(this.vertices) },
                merge: function(e, t, n) {
                    if (e && e.isGeometry) {
                        var r, i = this.vertices.length,
                            o = this.vertices,
                            a = e.vertices,
                            s = this.faces,
                            u = e.faces,
                            c = this.faceVertexUvs[0],
                            l = e.faceVertexUvs[0],
                            h = this.colors,
                            p = e.colors;
                        void 0 === n && (n = 0), void 0 !== t && (r = (new en).getNormalMatrix(t));
                        for (var d = 0, f = a.length; d < f; d++) {
                            var m = a[d].clone();
                            void 0 !== t && m.applyMatrix4(t), o.push(m)
                        }
                        for (d = 0, f = p.length; d < f; d++) h.push(p[d].clone());
                        for (d = 0, f = u.length; d < f; d++) {
                            var v, g, y, _ = u[d],
                                x = _.vertexNormals,
                                b = _.vertexColors;
                            (v = new Ln(_.a + i, _.b + i, _.c + i)).normal.copy(_.normal), void 0 !== r && v.normal.applyMatrix3(r).normalize();
                            for (var w = 0, M = x.length; w < M; w++) g = x[w].clone(), void 0 !== r && g.applyMatrix3(r).normalize(), v.vertexNormals.push(g);
                            v.color.copy(_.color);
                            for (w = 0, M = b.length; w < M; w++) y = b[w], v.vertexColors.push(y.clone());
                            v.materialIndex = _.materialIndex + n, s.push(v)
                        }
                        for (d = 0, f = l.length; d < f; d++) {
                            var E = l[d],
                                S = [];
                            if (void 0 !== E) {
                                for (w = 0, M = E.length; w < M; w++) S.push(E[w].clone());
                                c.push(S)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
                },
                mergeMesh: function(e) { e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) },
                mergeVertices: function() {
                    var e, t, n, r, i, o, a, s, u = {},
                        c = [],
                        l = [],
                        h = Math.pow(10, 4);
                    for (n = 0, r = this.vertices.length; n < r; n++) e = this.vertices[n], void 0 === u[t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h)] ? (u[t] = n, c.push(this.vertices[n]), l[n] = c.length - 1) : l[n] = l[u[t]];
                    var p = [];
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        (i = this.faces[n]).a = l[i.a], i.b = l[i.b], i.c = l[i.c], o = [i.a, i.b, i.c];
                        for (var d = 0; d < 3; d++)
                            if (o[d] === o[(d + 1) % 3]) { p.push(n); break }
                    }
                    for (n = p.length - 1; n >= 0; n--) { var f = p[n]; for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1) }
                    var m = this.vertices.length - c.length;
                    return this.vertices = c, m
                },
                setFromPoints: function(e) {
                    this.vertices = [];
                    for (var t = 0, n = e.length; t < n; t++) {
                        var r = e[t];
                        this.vertices.push(new Qt(r.x, r.y, r.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
                    e.sort(function(e, t) { return e.materialIndex - t.materialIndex });
                    var r, i, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    o && o.length === t && (r = []), a && a.length === t && (i = []);
                    for (n = 0; n < t; n++) {
                        var s = e[n]._id;
                        r && r.push(o[s]), i && i.push(a[s])
                    }
                    r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
                },
                toJSON: function() {
                    var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) { var t = this.parameters; for (var n in t) void 0 !== t[n] && (e[n] = t[n]); return e }
                    for (var r = [], i = 0; i < this.vertices.length; i++) {
                        var o = this.vertices[i];
                        r.push(o.x, o.y, o.z)
                    }
                    var a = [],
                        s = [],
                        u = {},
                        c = [],
                        l = {},
                        h = [],
                        p = {};
                    for (i = 0; i < this.faces.length; i++) {
                        var d = this.faces[i],
                            f = void 0 !== this.faceVertexUvs[0][i],
                            m = d.normal.length() > 0,
                            v = d.vertexNormals.length > 0,
                            g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                            y = d.vertexColors.length > 0,
                            _ = 0;
                        if (_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, v), 6, g), 7, y), a.push(_), a.push(d.a, d.b, d.c), a.push(d.materialIndex), f) {
                            var x = this.faceVertexUvs[0][i];
                            a.push(T(x[0]), T(x[1]), T(x[2]))
                        }
                        if (m && a.push(E(d.normal)), v) {
                            var b = d.vertexNormals;
                            a.push(E(b[0]), E(b[1]), E(b[2]))
                        }
                        if (g && a.push(S(d.color)), y) {
                            var w = d.vertexColors;
                            a.push(S(w[0]), S(w[1]), S(w[2]))
                        }
                    }

                    function M(e, t, n) { return n ? e | 1 << t : e & ~(1 << t) }

                    function E(e) { var t = e.x.toString() + e.y.toString() + e.z.toString(); return void 0 !== u[t] ? u[t] : (u[t] = s.length / 3, s.push(e.x, e.y, e.z), u[t]) }

                    function S(e) { var t = e.r.toString() + e.g.toString() + e.b.toString(); return void 0 !== l[t] ? l[t] : (l[t] = c.length, c.push(e.getHex()), l[t]) }

                    function T(e) { var t = e.x.toString() + e.y.toString(); return void 0 !== p[t] ? p[t] : (p[t] = h.length / 2, h.push(e.x, e.y), p[t]) }
                    return e.data = {}, e.data.vertices = r, e.data.normals = s, c.length > 0 && (e.data.colors = c), h.length > 0 && (e.data.uvs = [h]), e.data.faces = a, e
                },
                clone: function() { return (new jn).copy(this) },
                copy: function(e) {
                    var t, n, r, i, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var s = e.vertices;
                    for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                    var u = e.colors;
                    for (t = 0, n = u.length; t < n; t++) this.colors.push(u[t].clone());
                    var c = e.faces;
                    for (t = 0, n = c.length; t < n; t++) this.faces.push(c[t].clone());
                    for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                        var l = e.faceVertexUvs[t];
                        for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), r = 0, i = l.length; r < i; r++) {
                            var h = l[r],
                                p = [];
                            for (o = 0, a = h.length; o < a; o++) {
                                var d = h[o];
                                p.push(d.clone())
                            }
                            this.faceVertexUvs[t].push(p)
                        }
                    }
                    var f = e.morphTargets;
                    for (t = 0, n = f.length; t < n; t++) {
                        var m = {};
                        if (m.name = f[t].name, void 0 !== f[t].vertices)
                            for (m.vertices = [], r = 0, i = f[t].vertices.length; r < i; r++) m.vertices.push(f[t].vertices[r].clone());
                        if (void 0 !== f[t].normals)
                            for (m.normals = [], r = 0, i = f[t].normals.length; r < i; r++) m.normals.push(f[t].normals[r].clone());
                        this.morphTargets.push(m)
                    }
                    var v = e.morphNormals;
                    for (t = 0, n = v.length; t < n; t++) {
                        var g = {};
                        if (void 0 !== v[t].vertexNormals)
                            for (g.vertexNormals = [], r = 0, i = v[t].vertexNormals.length; r < i; r++) {
                                var y = v[t].vertexNormals[r],
                                    _ = {};
                                _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), g.vertexNormals.push(_)
                            }
                        if (void 0 !== v[t].faceNormals)
                            for (g.faceNormals = [], r = 0, i = v[t].faceNormals.length; r < i; r++) g.faceNormals.push(v[t].faceNormals[r].clone());
                        this.morphNormals.push(g)
                    }
                    var x = e.skinWeights;
                    for (t = 0, n = x.length; t < n; t++) this.skinWeights.push(x[t].clone());
                    var b = e.skinIndices;
                    for (t = 0, n = b.length; t < n; t++) this.skinIndices.push(b[t].clone());
                    var w = e.lineDistances;
                    for (t = 0, n = w.length; t < n; t++) this.lineDistances.push(w[t]);
                    var M = e.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var E = e.boundingSphere;
                    return null !== E && (this.boundingSphere = E.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                },
                dispose: function() { this.dispatchEvent({ type: "dispose" }) }
            }), Object.defineProperty(Hn.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(Hn.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setArray: function(e) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this },
                setDynamic: function(e) { return this.dynamic = e, this },
                copy: function(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this },
                copyAt: function(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r]; return this },
                copyArray: function(e) { return this.array.set(e), this },
                copyColorsArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new En), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new Jt), t[n++] = o.x, t[n++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new Qt), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(e) {
                    for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new ln), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w
                    }
                    return this
                },
                set: function(e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this },
                getX: function(e) { return this.array[e * this.itemSize] },
                setX: function(e, t) { return this.array[e * this.itemSize] = t, this },
                getY: function(e) { return this.array[e * this.itemSize + 1] },
                setY: function(e, t) { return this.array[e * this.itemSize + 1] = t, this },
                getZ: function(e) { return this.array[e * this.itemSize + 2] },
                setZ: function(e, t) { return this.array[e * this.itemSize + 2] = t, this },
                getW: function(e) { return this.array[e * this.itemSize + 3] },
                setW: function(e, t) { return this.array[e * this.itemSize + 3] = t, this },
                setXY: function(e, t, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this },
                setXYZ: function(e, t, n, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this },
                setXYZW: function(e, t, n, r, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this },
                onUpload: function(e) { return this.onUploadCallback = e, this },
                clone: function() { return new this.constructor(this.array, this.itemSize).copy(this) }
            }), Vn.prototype = Object.create(Hn.prototype), Vn.prototype.constructor = Vn, Wn.prototype = Object.create(Hn.prototype), Wn.prototype.constructor = Wn, Xn.prototype = Object.create(Hn.prototype), Xn.prototype.constructor = Xn, qn.prototype = Object.create(Hn.prototype), qn.prototype.constructor = qn, Yn.prototype = Object.create(Hn.prototype), Yn.prototype.constructor = Yn, Zn.prototype = Object.create(Hn.prototype), Zn.prototype.constructor = Zn, Jn.prototype = Object.create(Hn.prototype), Jn.prototype.constructor = Jn, Kn.prototype = Object.create(Hn.prototype), Kn.prototype.constructor = Kn, $n.prototype = Object.create(Hn.prototype), $n.prototype.constructor = $n, Object.assign(Qn.prototype, {
                computeGroups: function(e) {
                    for (var t, n = [], r = void 0, i = e.faces, o = 0; o < i.length; o++) {
                        var a = i[o];
                        a.materialIndex !== r && (r = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), t = { start: 3 * o, materialIndex: r })
                    }
                    void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), this.groups = n
                },
                fromGeometry: function(e) {
                    var t, n = e.faces,
                        r = e.vertices,
                        i = e.faceVertexUvs,
                        o = i[0] && i[0].length > 0,
                        a = i[1] && i[1].length > 0,
                        s = e.morphTargets,
                        u = s.length;
                    if (u > 0) {
                        t = [];
                        for (var c = 0; c < u; c++) t[c] = { name: s[c].name, data: [] };
                        this.morphTargets.position = t
                    }
                    var l, h = e.morphNormals,
                        p = h.length;
                    if (p > 0) {
                        l = [];
                        for (c = 0; c < p; c++) l[c] = { name: h[c].name, data: [] };
                        this.morphTargets.normal = l
                    }
                    var d = e.skinIndices,
                        f = e.skinWeights,
                        m = d.length === r.length,
                        v = f.length === r.length;
                    r.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (c = 0; c < n.length; c++) {
                        var g = n[c];
                        this.vertices.push(r[g.a], r[g.b], r[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var _ = g.normal;
                            this.normals.push(_, _, _)
                        }
                        var x, b = g.vertexColors;
                        if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                        else {
                            var w = g.color;
                            this.colors.push(w, w, w)
                        }
                        if (!0 === o) void 0 !== (x = i[0][c]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", c), this.uvs.push(new Jt, new Jt, new Jt));
                        if (!0 === a) void 0 !== (x = i[1][c]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c), this.uvs2.push(new Jt, new Jt, new Jt));
                        for (var M = 0; M < u; M++) {
                            var E = s[M].vertices;
                            t[M].data.push(E[g.a], E[g.b], E[g.c])
                        }
                        for (M = 0; M < p; M++) {
                            var S = h[M].vertexNormals[c];
                            l[M].data.push(S.a, S.b, S.c)
                        }
                        m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
                    }
                    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                }
            });
            var tr = 1;

            function nr() { Object.defineProperty(this, "id", { value: tr += 2 }), this.uuid = Zt.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} }

            function rr(e, t, n, r, i, o) { jn.call(this), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: o }, this.fromBufferGeometry(new ir(e, t, n, r, i, o)), this.mergeVertices() }

            function ir(e, t, n, r, i, o) {
                nr.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: o };
                var a = this;
                e = e || 1, t = t || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1;
                var s = [],
                    u = [],
                    c = [],
                    l = [],
                    h = 0,
                    p = 0;

                function d(e, t, n, r, i, o, d, f, m, v, g) {
                    var y, _, x = o / m,
                        b = d / v,
                        w = o / 2,
                        M = d / 2,
                        E = f / 2,
                        S = m + 1,
                        T = v + 1,
                        A = 0,
                        P = 0,
                        R = new Qt;
                    for (_ = 0; _ < T; _++) {
                        var L = _ * b - M;
                        for (y = 0; y < S; y++) {
                            var C = y * x - w;
                            R[e] = C * r, R[t] = L * i, R[n] = E, u.push(R.x, R.y, R.z), R[e] = 0, R[t] = 0, R[n] = f > 0 ? 1 : -1, c.push(R.x, R.y, R.z), l.push(y / m), l.push(1 - _ / v), A += 1
                        }
                    }
                    for (_ = 0; _ < v; _++)
                        for (y = 0; y < m; y++) {
                            var O = h + y + S * _,
                                I = h + y + S * (_ + 1),
                                D = h + (y + 1) + S * (_ + 1),
                                U = h + (y + 1) + S * _;
                            s.push(O, I, U), s.push(I, D, U), P += 6
                        }
                    a.addGroup(p, P, g), p += P, h += A
                }
                d("z", "y", "x", -1, -1, n, t, e, o = Math.floor(o) || 1, i, 0), d("z", "y", "x", 1, -1, n, t, -e, o, i, 1), d("x", "z", "y", 1, 1, e, n, t, r, o, 2), d("x", "z", "y", 1, -1, e, n, -t, r, o, 3), d("x", "y", "z", 1, -1, e, t, n, r, i, 4), d("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(s), this.addAttribute("position", new Kn(u, 3)), this.addAttribute("normal", new Kn(c, 3)), this.addAttribute("uv", new Kn(l, 2))
            }

            function or(e, t, n, r) { jn.call(this), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r }, this.fromBufferGeometry(new ar(e, t, n, r)), this.mergeVertices() }

            function ar(e, t, n, r) {
                nr.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r };
                var i, o, a = (e = e || 1) / 2,
                    s = (t = t || 1) / 2,
                    u = Math.floor(n) || 1,
                    c = Math.floor(r) || 1,
                    l = u + 1,
                    h = c + 1,
                    p = e / u,
                    d = t / c,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (o = 0; o < h; o++) {
                    var y = o * d - s;
                    for (i = 0; i < l; i++) {
                        var _ = i * p - a;
                        m.push(_, -y, 0), v.push(0, 0, 1), g.push(i / u), g.push(1 - o / c)
                    }
                }
                for (o = 0; o < c; o++)
                    for (i = 0; i < u; i++) {
                        var x = i + l * o,
                            b = i + l * (o + 1),
                            w = i + 1 + l * (o + 1),
                            M = i + 1 + l * o;
                        f.push(x, b, M), f.push(b, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new Kn(m, 3)), this.addAttribute("normal", new Kn(v, 3)), this.addAttribute("uv", new Kn(g, 2))
            }
            nr.prototype = Object.assign(Object.create(r.prototype), {
                constructor: nr,
                isBufferGeometry: !0,
                getIndex: function() { return this.index },
                setIndex: function(e) { Array.isArray(e) ? this.index = new(er(e) > 65535 ? Jn : Yn)(e, 1) : this.index = e },
                addAttribute: function(e, t) { return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new Hn(arguments[1], arguments[2]))) },
                getAttribute: function(e) { return this.attributes[e] },
                removeAttribute: function(e) { return delete this.attributes[e], this },
                addGroup: function(e, t, n) { this.groups.push({ start: e, count: t, materialIndex: void 0 !== n ? n : 0 }) },
                clearGroups: function() { this.groups = [] },
                setDrawRange: function(e, t) { this.drawRange.start = e, this.drawRange.count = t },
                applyMatrix: function(e) {
                    var t = this.attributes.position;
                    void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
                    var n = this.attributes.normal;
                    void 0 !== n && ((new en).getNormalMatrix(e).applyToBufferAttribute(n), n.needsUpdate = !0);
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() { var e = new Kt; return function(t) { return e.makeRotationX(t), this.applyMatrix(e), this } }(),
                rotateY: function() { var e = new Kt; return function(t) { return e.makeRotationY(t), this.applyMatrix(e), this } }(),
                rotateZ: function() { var e = new Kt; return function(t) { return e.makeRotationZ(t), this.applyMatrix(e), this } }(),
                translate: function() { var e = new Kt; return function(t, n, r) { return e.makeTranslation(t, n, r), this.applyMatrix(e), this } }(),
                scale: function() { var e = new Kt; return function(t, n, r) { return e.makeScale(t, n, r), this.applyMatrix(e), this } }(),
                lookAt: function() { var e = new Bn; return function(t) { e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix) } }(),
                center: function() { var e = new Qt; return function() { return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this } }(),
                setFromObject: function(e) {
                    var t = e.geometry;
                    if (e.isPoints || e.isLine) {
                        var n = new Kn(3 * t.vertices.length, 3),
                            r = new Kn(3 * t.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(t.vertices)), this.addAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                            var i = new Kn(t.lineDistances.length, 1);
                            this.addAttribute("lineDistance", i.copyArray(t.lineDistances))
                        }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                    return this
                },
                setFromPoints: function(e) {
                    for (var t = [], n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    return this.addAttribute("position", new Kn(t, 3)), this
                },
                updateFromObject: function(e) {
                    var t, n = e.geometry;
                    if (e.isMesh) {
                        var r = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                        r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices), t.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals), t.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors), t.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs), t.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances), t.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(e.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(e) { return e.__directGeometry = (new Qn).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry) },
                fromDirectGeometry: function(e) {
                    var t = new Float32Array(3 * e.vertices.length);
                    if (this.addAttribute("position", new Hn(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                        var n = new Float32Array(3 * e.normals.length);
                        this.addAttribute("normal", new Hn(n, 3).copyVector3sArray(e.normals))
                    }
                    if (e.colors.length > 0) {
                        var r = new Float32Array(3 * e.colors.length);
                        this.addAttribute("color", new Hn(r, 3).copyColorsArray(e.colors))
                    }
                    if (e.uvs.length > 0) {
                        var i = new Float32Array(2 * e.uvs.length);
                        this.addAttribute("uv", new Hn(i, 2).copyVector2sArray(e.uvs))
                    }
                    if (e.uvs2.length > 0) {
                        var o = new Float32Array(2 * e.uvs2.length);
                        this.addAttribute("uv2", new Hn(o, 2).copyVector2sArray(e.uvs2))
                    }
                    for (var a in this.groups = e.groups, e.morphTargets) {
                        for (var s = [], u = e.morphTargets[a], c = 0, l = u.length; c < l; c++) {
                            var h = u[c],
                                p = new Kn(3 * h.data.length, 3);
                            p.name = h.name, s.push(p.copyVector3sArray(h.data))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (e.skinIndices.length > 0) {
                        var d = new Kn(4 * e.skinIndices.length, 4);
                        this.addAttribute("skinIndex", d.copyVector4sArray(e.skinIndices))
                    }
                    if (e.skinWeights.length > 0) {
                        var f = new Kn(4 * e.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
                    }
                    return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new fn);
                    var e = this.attributes.position;
                    void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    var e = new fn,
                        t = new Qt;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new mn);
                        var n = this.attributes.position;
                        if (n) {
                            var r = this.boundingSphere.center;
                            e.setFromBufferAttribute(n), e.getCenter(r);
                            for (var i = 0, o = 0, a = n.count; o < a; o++) t.x = n.getX(o), t.y = n.getY(o), t.z = n.getZ(o), i = Math.max(i, r.distanceToSquared(t));
                            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var e = this.index,
                        t = this.attributes;
                    if (t.position) {
                        var n = t.position.array;
                        if (void 0 === t.normal) this.addAttribute("normal", new Hn(new Float32Array(n.length), 3));
                        else
                            for (var r = t.normal.array, i = 0, o = r.length; i < o; i++) r[i] = 0;
                        var a, s, u, c = t.normal.array,
                            l = new Qt,
                            h = new Qt,
                            p = new Qt,
                            d = new Qt,
                            f = new Qt;
                        if (e) { var m = e.array; for (i = 0, o = e.count; i < o; i += 3) a = 3 * m[i + 0], s = 3 * m[i + 1], u = 3 * m[i + 2], l.fromArray(n, a), h.fromArray(n, s), p.fromArray(n, u), d.subVectors(p, h), f.subVectors(l, h), d.cross(f), c[a] += d.x, c[a + 1] += d.y, c[a + 2] += d.z, c[s] += d.x, c[s + 1] += d.y, c[s + 2] += d.z, c[u] += d.x, c[u + 1] += d.y, c[u + 2] += d.z } else
                            for (i = 0, o = n.length; i < o; i += 9) l.fromArray(n, i), h.fromArray(n, i + 3), p.fromArray(n, i + 6), d.subVectors(p, h), f.subVectors(l, h), d.cross(f), c[i] = d.x, c[i + 1] = d.y, c[i + 2] = d.z, c[i + 3] = d.x, c[i + 4] = d.y, c[i + 5] = d.z, c[i + 6] = d.x, c[i + 7] = d.y, c[i + 8] = d.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0
                    }
                },
                merge: function(e, t) {
                    if (e && e.isBufferGeometry) {
                        void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var n = this.attributes;
                        for (var r in n)
                            if (void 0 !== e.attributes[r])
                                for (var i = n[r].array, o = e.attributes[r], a = o.array, s = 0, u = o.itemSize * t; s < a.length; s++, u++) i[u] = a[s];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
                },
                normalizeNormals: function() { var e = new Qt; return function() { for (var t = this.attributes.normal, n = 0, r = t.count; n < r; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.normalize(), t.setXYZ(n, e.x, e.y, e.z) } }(),
                toNonIndexed: function() {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var e = new nr,
                        t = this.index.array,
                        n = this.attributes;
                    for (var r in n) {
                        for (var i = n[r], o = i.array, a = i.itemSize, s = new o.constructor(t.length * a), u = 0, c = 0, l = 0, h = t.length; l < h; l++) { u = t[l] * a; for (var p = 0; p < a; p++) s[c++] = o[u++] }
                        e.addAttribute(r, new Hn(s, a))
                    }
                    var d = this.groups;
                    for (l = 0, h = d.length; l < h; l++) {
                        var f = d[l];
                        e.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    var e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { var t = this.parameters; for (var n in t) void 0 !== t[n] && (e[n] = t[n]); return e }
                    e.data = { attributes: {} };
                    var r = this.index;
                    if (null !== r) {
                        var i = Array.prototype.slice.call(r.array);
                        e.data.index = { type: r.array.constructor.name, array: i }
                    }
                    var o = this.attributes;
                    for (var n in o) {
                        var a = o[n];
                        i = Array.prototype.slice.call(a.array);
                        e.data.attributes[n] = { itemSize: a.itemSize, type: a.array.constructor.name, array: i, normalized: a.normalized }
                    }
                    var s = this.groups;
                    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    var u = this.boundingSphere;
                    return null !== u && (e.data.boundingSphere = { center: u.center.toArray(), radius: u.radius }), e
                },
                clone: function() { return (new nr).copy(this) },
                copy: function(e) {
                    var t, n, r;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var i = e.index;
                    null !== i && this.setIndex(i.clone());
                    var o = e.attributes;
                    for (t in o) {
                        var a = o[t];
                        this.addAttribute(t, a.clone())
                    }
                    var s = e.morphAttributes;
                    for (t in s) {
                        var u = [],
                            c = s[t];
                        for (n = 0, r = c.length; n < r; n++) u.push(c[n].clone());
                        this.morphAttributes[t] = u
                    }
                    var l = e.groups;
                    for (n = 0, r = l.length; n < r; n++) {
                        var h = l[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var p = e.boundingBox;
                    null !== p && (this.boundingBox = p.clone());
                    var d = e.boundingSphere;
                    return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                },
                dispose: function() { this.dispatchEvent({ type: "dispose" }) }
            }), rr.prototype = Object.create(jn.prototype), rr.prototype.constructor = rr, ir.prototype = Object.create(nr.prototype), ir.prototype.constructor = ir, or.prototype = Object.create(jn.prototype), or.prototype.constructor = or, ar.prototype = Object.create(nr.prototype), ar.prototype.constructor = ar;
            var sr, ur, cr, lr, hr, pr, dr, fr, mr, vr, gr, yr, _r = 0;

            function xr() { Object.defineProperty(this, "id", { value: _r++ }), this.uuid = Zt.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = U, this.side = T, this.flatShading = !1, this.vertexColors = C, this.opacity = 1, this.transparent = !1, this.blendSrc = Z, this.blendDst = J, this.blendEquation = k, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = oe, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0 }

            function br(e) { xr.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) }

            function wr(e, t) { this.origin = void 0 !== e ? e : new Qt, this.direction = void 0 !== t ? t : new Qt }

            function Mr(e, t, n) { this.a = void 0 !== e ? e : new Qt, this.b = void 0 !== t ? t : new Qt, this.c = void 0 !== n ? n : new Qt }

            function Er(e) { xr.call(this), this.type = "MeshBasicMaterial", this.color = new En(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = le, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e) }

            function Sr(e, t) { Bn.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new nr, this.material = void 0 !== t ? t : new Er({ color: 16777215 * Math.random() }), this.drawMode = Dt, this.updateMorphTargets() }

            function Tr(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) }

            function Ar(e, t, n, r, i, o, a, s, u, c) { e = void 0 !== e ? e : [], t = void 0 !== t ? t : _e, cn.call(this, e, t, n, r, i, o, a, s, u, c), this.flipY = !1 }

            function Pr(e, t, n, r) { cn.call(this, null), this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Re, this.minFilter = Re, this.generateMipmaps = !1, this.flipY = !1 }
            xr.prototype = Object.assign(Object.create(r.prototype), {
                constructor: xr,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(e) {
                    if (void 0 !== e)
                        for (var t in e) {
                            var n = e[t];
                            if (void 0 !== n)
                                if ("shading" !== t) {
                                    var r = this[t];
                                    void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = "overdraw" === t ? Number(n) : n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === R;
                            else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                        }
                },
                toJSON: function(e) {
                    var t = void 0 === e || "string" == typeof e;
                    t && (e = { textures: {}, images: {} });
                    var n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };

                    function r(e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== U && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== T && (n.side = this.side), this.vertexColors !== C && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                        var i = r(e.textures),
                            o = r(e.images);
                        i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o)
                    }
                    return n
                },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) {
                    this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
                    var t = e.clippingPlanes,
                        n = null;
                    if (null !== t) {
                        var r = t.length;
                        n = new Array(r);
                        for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = e.shadowSide, this
                },
                dispose: function() { this.dispatchEvent({ type: "dispose" }) }
            }), br.prototype = Object.create(xr.prototype), br.prototype.constructor = br, br.prototype.isShaderMaterial = !0, br.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = wn.clone(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this }, br.prototype.toJSON = function(e) {
                var t = xr.prototype.toJSON.call(this, e);
                for (var n in t.uniforms = {}, this.uniforms) {
                    var r = this.uniforms[n].value;
                    r.isTexture ? t.uniforms[n] = { type: "t", value: r.toJSON(e).uuid } : r.isColor ? t.uniforms[n] = { type: "c", value: r.getHex() } : r.isVector2 ? t.uniforms[n] = { type: "v2", value: r.toArray() } : r.isVector3 ? t.uniforms[n] = { type: "v3", value: r.toArray() } : r.isVector4 ? t.uniforms[n] = { type: "v4", value: r.toArray() } : r.isMatrix4 ? t.uniforms[n] = { type: "m4", value: r.toArray() } : t.uniforms[n] = { value: r }
                }
                return Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
            }, Object.assign(wr.prototype, {
                set: function(e, t) { return this.origin.copy(e), this.direction.copy(t), this },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this },
                at: function(e, t) { return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Qt), t.copy(this.direction).multiplyScalar(e).add(this.origin) },
                lookAt: function(e) { return this.direction.copy(e).sub(this.origin).normalize(), this },
                recast: function() { var e = new Qt; return function(t) { return this.origin.copy(this.at(t, e)), this } }(),
                closestPointToPoint: function(e, t) { void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Qt), t.subVectors(e, this.origin); var n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin) },
                distanceToPoint: function(e) { return Math.sqrt(this.distanceSqToPoint(e)) },
                distanceSqToPoint: function() { var e = new Qt; return function(t) { var n = e.subVectors(t, this.origin).dot(this.direction); return n < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(t)) } }(),
                distanceSqToSegment: (ur = new Qt, cr = new Qt, lr = new Qt, function(e, t, n, r) {
                    ur.copy(e).add(t).multiplyScalar(.5), cr.copy(t).sub(e).normalize(), lr.copy(this.origin).sub(ur);
                    var i, o, a, s, u = .5 * e.distanceTo(t),
                        c = -this.direction.dot(cr),
                        l = lr.dot(this.direction),
                        h = -lr.dot(cr),
                        p = lr.lengthSq(),
                        d = Math.abs(1 - c * c);
                    if (d > 0)
                        if (o = c * l - h, s = u * d, (i = c * h - l) >= 0)
                            if (o >= -s)
                                if (o <= s) {
                                    var f = 1 / d;
                                    a = (i *= f) * (i + c * (o *= f) + 2 * l) + o * (c * i + o + 2 * h) + p
                                } else o = u, a = -(i = Math.max(0, -(c * o + l))) * i + o * (o + 2 * h) + p;
                    else o = -u, a = -(i = Math.max(0, -(c * o + l))) * i + o * (o + 2 * h) + p;
                    else o <= -s ? a = -(i = Math.max(0, -(-c * u + l))) * i + (o = i > 0 ? -u : Math.min(Math.max(-u, -h), u)) * (o + 2 * h) + p : o <= s ? (i = 0, a = (o = Math.min(Math.max(-u, -h), u)) * (o + 2 * h) + p) : a = -(i = Math.max(0, -(c * u + l))) * i + (o = i > 0 ? u : Math.min(Math.max(-u, -h), u)) * (o + 2 * h) + p;
                    else o = c > 0 ? -u : u, a = -(i = Math.max(0, -(c * o + l))) * i + o * (o + 2 * h) + p;
                    return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(cr).multiplyScalar(o).add(ur), a
                }),
                intersectSphere: function() {
                    var e = new Qt;
                    return function(t, n) {
                        e.subVectors(t.center, this.origin);
                        var r = e.dot(this.direction),
                            i = e.dot(e) - r * r,
                            o = t.radius * t.radius;
                        if (i > o) return null;
                        var a = Math.sqrt(o - i),
                            s = r - a,
                            u = r + a;
                        return s < 0 && u < 0 ? null : s < 0 ? this.at(u, n) : this.at(s, n)
                    }
                }(),
                intersectsSphere: function(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius },
                distanceToPlane: function(e) { var t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; var n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null },
                intersectPlane: function(e, t) { var n = this.distanceToPlane(e); return null === n ? null : this.at(n, t) },
                intersectsPlane: function(e) { var t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 },
                intersectBox: function(e, t) {
                    var n, r, i, o, a, s, u = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        l = 1 / this.direction.z,
                        h = this.origin;
                    return u >= 0 ? (n = (e.min.x - h.x) * u, r = (e.max.x - h.x) * u) : (n = (e.max.x - h.x) * u, r = (e.min.x - h.x) * u), c >= 0 ? (i = (e.min.y - h.y) * c, o = (e.max.y - h.y) * c) : (i = (e.max.y - h.y) * c, o = (e.min.y - h.y) * c), n > o || i > r ? null : ((i > n || n != n) && (n = i), (o < r || r != r) && (r = o), l >= 0 ? (a = (e.min.z - h.z) * l, s = (e.max.z - h.z) * l) : (a = (e.max.z - h.z) * l, s = (e.min.z - h.z) * l), n > s || a > r ? null : ((a > n || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
                },
                intersectsBox: (sr = new Qt, function(e) { return null !== this.intersectBox(e, sr) }),
                intersectTriangle: function() {
                    var e = new Qt,
                        t = new Qt,
                        n = new Qt,
                        r = new Qt;
                    return function(i, o, a, s, u) {
                        t.subVectors(o, i), n.subVectors(a, i), r.crossVectors(t, n);
                        var c, l = this.direction.dot(r);
                        if (l > 0) {
                            if (s) return null;
                            c = 1
                        } else {
                            if (!(l < 0)) return null;
                            c = -1, l = -l
                        }
                        e.subVectors(this.origin, i);
                        var h = c * this.direction.dot(n.crossVectors(e, n));
                        if (h < 0) return null;
                        var p = c * this.direction.dot(t.cross(e));
                        if (p < 0) return null;
                        if (h + p > l) return null;
                        var d = -c * e.dot(r);
                        return d < 0 ? null : this.at(d / l, u)
                    }
                }(),
                applyMatrix4: function(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this },
                equals: function(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) }
            }), Object.assign(Mr, {
                getNormal: (pr = new Qt, function(e, t, n, r) { void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new Qt), r.subVectors(n, t), pr.subVectors(e, t), r.cross(pr); var i = r.lengthSq(); return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0) }),
                getBarycoord: function() {
                    var e = new Qt,
                        t = new Qt,
                        n = new Qt;
                    return function(r, i, o, a, s) {
                        e.subVectors(a, i), t.subVectors(o, i), n.subVectors(r, i);
                        var u = e.dot(e),
                            c = e.dot(t),
                            l = e.dot(n),
                            h = t.dot(t),
                            p = t.dot(n),
                            d = u * h - c * c;
                        if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new Qt), 0 === d) return s.set(-2, -1, -1);
                        var f = 1 / d,
                            m = (h * l - c * p) * f,
                            v = (u * p - c * l) * f;
                        return s.set(1 - m - v, v, m)
                    }
                }(),
                containsPoint: function() { var e = new Qt; return function(t, n, r, i) { return Mr.getBarycoord(t, n, r, i, e), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1 } }(),
                getUV: (hr = new Qt, function(e, t, n, r, i, o, a, s) { return this.getBarycoord(e, t, n, r, hr), s.set(0, 0), s.addScaledVector(i, hr.x), s.addScaledVector(o, hr.y), s.addScaledVector(a, hr.z), s })
            }), Object.assign(Mr.prototype, {
                set: function(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this },
                setFromPointsAndIndices: function(e, t, n, r) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this },
                getArea: function() {
                    var e = new Qt,
                        t = new Qt;
                    return function() { return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length() }
                }(),
                getMidpoint: function(e) { return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Qt), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) },
                getNormal: function(e) { return Mr.getNormal(this.a, this.b, this.c, e) },
                getPlane: function(e) { return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Qt), e.setFromCoplanarPoints(this.a, this.b, this.c) },
                getBarycoord: function(e, t) { return Mr.getBarycoord(e, this.a, this.b, this.c, t) },
                containsPoint: function(e) { return Mr.containsPoint(e, this.a, this.b, this.c) },
                getUV: function(e, t, n, r, i) { return Mr.getUV(e, this.a, this.b, this.c, t, n, r, i) },
                intersectsBox: function(e) { return e.intersectsTriangle(this) },
                closestPointToPoint: (dr = new Qt, fr = new Qt, mr = new Qt, vr = new Qt, gr = new Qt, yr = new Qt, function(e, t) {
                    void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Qt);
                    var n, r, i = this.a,
                        o = this.b,
                        a = this.c;
                    dr.subVectors(o, i), fr.subVectors(a, i), vr.subVectors(e, i);
                    var s = dr.dot(vr),
                        u = fr.dot(vr);
                    if (s <= 0 && u <= 0) return t.copy(i);
                    gr.subVectors(e, o);
                    var c = dr.dot(gr),
                        l = fr.dot(gr);
                    if (c >= 0 && l <= c) return t.copy(o);
                    var h = s * l - c * u;
                    if (h <= 0 && s >= 0 && c <= 0) return n = s / (s - c), t.copy(i).addScaledVector(dr, n);
                    yr.subVectors(e, a);
                    var p = dr.dot(yr),
                        d = fr.dot(yr);
                    if (d >= 0 && p <= d) return t.copy(a);
                    var f = p * u - s * d;
                    if (f <= 0 && u >= 0 && d <= 0) return r = u / (u - d), t.copy(i).addScaledVector(fr, r);
                    var m = c * d - p * l;
                    if (m <= 0 && l - c >= 0 && p - d >= 0) return mr.subVectors(a, o), r = (l - c) / (l - c + (p - d)), t.copy(o).addScaledVector(mr, r);
                    var v = 1 / (m + f + h);
                    return n = f * v, r = h * v, t.copy(i).addScaledVector(dr, n).addScaledVector(fr, r)
                }),
                equals: function(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) }
            }), Er.prototype = Object.create(xr.prototype), Er.prototype.constructor = Er, Er.prototype.isMeshBasicMaterial = !0, Er.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this }, Sr.prototype = Object.assign(Object.create(Bn.prototype), {
                constructor: Sr,
                isMesh: !0,
                setDrawMode: function(e) { this.drawMode = e },
                copy: function(e) { return Bn.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this },
                updateMorphTargets: function() {
                    var e, t, n, r = this.geometry;
                    if (r.isBufferGeometry) {
                        var i = r.morphAttributes,
                            o = Object.keys(i);
                        if (o.length > 0) {
                            var a = i[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    } else {
                        var s = r.morphTargets;
                        if (void 0 !== s && s.length > 0)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = s.length; e < t; e++) n = s[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                    }
                },
                raycast: function() {
                    var e = new Kt,
                        t = new wr,
                        n = new mn,
                        r = new Qt,
                        i = new Qt,
                        o = new Qt,
                        a = new Qt,
                        s = new Qt,
                        u = new Qt,
                        c = new Jt,
                        l = new Jt,
                        h = new Jt,
                        p = new Qt,
                        d = new Qt;

                    function f(e, t, n, r, i, o, a, s) {
                        if (null === (t.side === A ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, t.side !== P, s))) return null;
                        d.copy(s), d.applyMatrix4(e.matrixWorld);
                        var u = n.ray.origin.distanceTo(d);
                        return u < n.near || u > n.far ? null : { distance: u, point: d.clone(), object: e }
                    }

                    function m(e, t, n, a, s, u, d, m, v) {
                        r.fromBufferAttribute(s, d), i.fromBufferAttribute(s, m), o.fromBufferAttribute(s, v);
                        var g = f(e, t, n, a, r, i, o, p);
                        if (g) {
                            u && (c.fromBufferAttribute(u, d), l.fromBufferAttribute(u, m), h.fromBufferAttribute(u, v), g.uv = Mr.getUV(p, r, i, o, c, l, h, new Jt));
                            var y = new Ln(d, m, v);
                            Mr.getNormal(r, i, o, y.normal), g.face = y
                        }
                        return g
                    }
                    return function(d, v) {
                        var g, y = this.geometry,
                            _ = this.material,
                            x = this.matrixWorld;
                        if (void 0 !== _ && (null === y.boundingSphere && y.computeBoundingSphere(), n.copy(y.boundingSphere), n.applyMatrix4(x), !1 !== d.ray.intersectsSphere(n) && (e.getInverse(x), t.copy(d.ray).applyMatrix4(e), null === y.boundingBox || !1 !== t.intersectsBox(y.boundingBox))))
                            if (y.isBufferGeometry) {
                                var b, w, M, E, S, T, A, P, R, L = y.index,
                                    C = y.attributes.position,
                                    O = y.attributes.uv,
                                    I = y.groups,
                                    D = y.drawRange;
                                if (null !== L)
                                    if (Array.isArray(_))
                                        for (E = 0, T = I.length; E < T; E++)
                                            for (R = _[(P = I[E]).materialIndex], S = Math.max(P.start, D.start), A = Math.min(P.start + P.count, D.start + D.count); S < A; S += 3) b = L.getX(S), w = L.getX(S + 1), M = L.getX(S + 2), (g = m(this, R, d, t, C, O, b, w, M)) && (g.faceIndex = Math.floor(S / 3), v.push(g));
                                    else
                                        for (E = Math.max(0, D.start), T = Math.min(L.count, D.start + D.count); E < T; E += 3) b = L.getX(E), w = L.getX(E + 1), M = L.getX(E + 2), (g = m(this, _, d, t, C, O, b, w, M)) && (g.faceIndex = Math.floor(E / 3), v.push(g));
                                else if (void 0 !== C)
                                    if (Array.isArray(_))
                                        for (E = 0, T = I.length; E < T; E++)
                                            for (R = _[(P = I[E]).materialIndex], S = Math.max(P.start, D.start), A = Math.min(P.start + P.count, D.start + D.count); S < A; S += 3)(g = m(this, R, d, t, C, O, b = S, w = S + 1, M = S + 2)) && (g.faceIndex = Math.floor(S / 3), v.push(g));
                                    else
                                        for (E = Math.max(0, D.start), T = Math.min(C.count, D.start + D.count); E < T; E += 3)(g = m(this, _, d, t, C, O, b = E, w = E + 1, M = E + 2)) && (g.faceIndex = Math.floor(E / 3), v.push(g))
                            } else if (y.isGeometry) {
                            var U, F, N, B, z = Array.isArray(_),
                                k = y.vertices,
                                G = y.faces,
                                j = y.faceVertexUvs[0];
                            j.length > 0 && (B = j);
                            for (var H = 0, V = G.length; H < V; H++) {
                                var W = G[H],
                                    X = z ? _[W.materialIndex] : _;
                                if (void 0 !== X) {
                                    if (U = k[W.a], F = k[W.b], N = k[W.c], !0 === X.morphTargets) {
                                        var q = y.morphTargets,
                                            Y = this.morphTargetInfluences;
                                        r.set(0, 0, 0), i.set(0, 0, 0), o.set(0, 0, 0);
                                        for (var Z = 0, J = q.length; Z < J; Z++) {
                                            var K = Y[Z];
                                            if (0 !== K) {
                                                var $ = q[Z].vertices;
                                                r.addScaledVector(a.subVectors($[W.a], U), K), i.addScaledVector(s.subVectors($[W.b], F), K), o.addScaledVector(u.subVectors($[W.c], N), K)
                                            }
                                        }
                                        r.add(U), i.add(F), o.add(N), U = r, F = i, N = o
                                    }
                                    if (g = f(this, X, d, t, U, F, N, p)) {
                                        if (B && B[H]) {
                                            var Q = B[H];
                                            c.copy(Q[0]), l.copy(Q[1]), h.copy(Q[2]), g.uv = Mr.getUV(p, U, F, N, c, l, h, new Jt)
                                        }
                                        g.face = W, g.faceIndex = H, v.push(g)
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() { return new this.constructor(this.geometry, this.material).copy(this) }
            }), Ar.prototype = Object.create(cn.prototype), Ar.prototype.constructor = Ar, Ar.prototype.isCubeTexture = !0, Object.defineProperty(Ar.prototype, "images", { get: function() { return this.image }, set: function(e) { this.image = e } }), Pr.prototype = Object.create(cn.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isDataTexture3D = !0;
            var Rr = new cn,
                Lr = new Pr,
                Cr = new Ar;

            function Or() { this.seq = [], this.map = {} }
            var Ir = [],
                Dr = [],
                Ur = new Float32Array(16),
                Fr = new Float32Array(9),
                Nr = new Float32Array(4);

            function Br(e, t, n) {
                var r = e[0];
                if (r <= 0 || r > 0) return e;
                var i = t * n,
                    o = Ir[i];
                if (void 0 === o && (o = new Float32Array(i), Ir[i] = o), 0 !== t) { r.toArray(o, 0); for (var a = 1, s = 0; a !== t; ++a) s += n, e[a].toArray(o, s) }
                return o
            }

            function zr(e, t) {
                if (e.length !== t.length) return !1;
                for (var n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function kr(e, t) { for (var n = 0, r = t.length; n < r; n++) e[n] = t[n] }

            function Gr(e, t) {
                var n = Dr[t];
                void 0 === n && (n = new Int32Array(t), Dr[t] = n);
                for (var r = 0; r !== t; ++r) n[r] = e.allocTextureUnit();
                return n
            }

            function jr(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function Hr(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function Vr(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (zr(n, t)) return;
                    e.uniform2fv(this.addr, t), kr(n, t)
                }
            }

            function Wr(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (zr(n, t)) return;
                    e.uniform3fv(this.addr, t), kr(n, t)
                }
            }

            function Xr(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (zr(n, t)) return;
                    e.uniform4fv(this.addr, t), kr(n, t)
                }
            }

            function qr(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (zr(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), kr(n, t)
                } else {
                    if (zr(n, r)) return;
                    Nr.set(r), e.uniformMatrix2fv(this.addr, !1, Nr), kr(n, r)
                }
            }

            function Yr(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (zr(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), kr(n, t)
                } else {
                    if (zr(n, r)) return;
                    Fr.set(r), e.uniformMatrix3fv(this.addr, !1, Fr), kr(n, r)
                }
            }

            function Zr(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (zr(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), kr(n, t)
                } else {
                    if (zr(n, r)) return;
                    Ur.set(r), e.uniformMatrix4fv(this.addr, !1, Ur), kr(n, r)
                }
            }

            function Jr(e, t, n) {
                var r = this.cache,
                    i = n.allocTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(t || Rr, i)
            }

            function Kr(e, t, n) {
                var r = this.cache,
                    i = n.allocTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Lr, i)
            }

            function $r(e, t, n) {
                var r = this.cache,
                    i = n.allocTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || Cr, i)
            }

            function Qr(e, t) {
                var n = this.cache;
                zr(n, t) || (e.uniform2iv(this.addr, t), kr(n, t))
            }

            function ei(e, t) {
                var n = this.cache;
                zr(n, t) || (e.uniform3iv(this.addr, t), kr(n, t))
            }

            function ti(e, t) {
                var n = this.cache;
                zr(n, t) || (e.uniform4iv(this.addr, t), kr(n, t))
            }

            function ni(e, t) {
                var n = this.cache;
                zr(n, t) || (e.uniform1fv(this.addr, t), kr(n, t))
            }

            function ri(e, t) {
                var n = this.cache;
                zr(n, t) || (e.uniform1iv(this.addr, t), kr(n, t))
            }

            function ii(e, t) {
                var n = this.cache,
                    r = Br(t, this.size, 2);
                zr(n, r) || (e.uniform2fv(this.addr, r), this.updateCache(r))
            }

            function oi(e, t) {
                var n = this.cache,
                    r = Br(t, this.size, 3);
                zr(n, r) || (e.uniform3fv(this.addr, r), this.updateCache(r))
            }

            function ai(e, t) {
                var n = this.cache,
                    r = Br(t, this.size, 4);
                zr(n, r) || (e.uniform4fv(this.addr, r), this.updateCache(r))
            }

            function si(e, t) {
                var n = this.cache,
                    r = Br(t, this.size, 4);
                zr(n, r) || (e.uniformMatrix2fv(this.addr, !1, r), this.updateCache(r))
            }

            function ui(e, t) {
                var n = this.cache,
                    r = Br(t, this.size, 9);
                zr(n, r) || (e.uniformMatrix3fv(this.addr, !1, r), this.updateCache(r))
            }

            function ci(e, t) {
                var n = this.cache,
                    r = Br(t, this.size, 16);
                zr(n, r) || (e.uniformMatrix4fv(this.addr, !1, r), this.updateCache(r))
            }

            function li(e, t, n) {
                var r = this.cache,
                    i = t.length,
                    o = Gr(n, i);
                !1 === zr(r, o) && (e.uniform1iv(this.addr, o), kr(r, o));
                for (var a = 0; a !== i; ++a) n.setTexture2D(t[a] || Rr, o[a])
            }

            function hi(e, t, n) {
                var r = this.cache,
                    i = t.length,
                    o = Gr(n, i);
                !1 === zr(r, o) && (e.uniform1iv(this.addr, o), kr(r, o));
                for (var a = 0; a !== i; ++a) n.setTextureCube(t[a] || Cr, o[a])
            }

            function pi(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return jr;
                        case 35664:
                            return Vr;
                        case 35665:
                            return Wr;
                        case 35666:
                            return Xr;
                        case 35674:
                            return qr;
                        case 35675:
                            return Yr;
                        case 35676:
                            return Zr;
                        case 35678:
                        case 36198:
                            return Jr;
                        case 35679:
                            return Kr;
                        case 35680:
                            return $r;
                        case 5124:
                        case 35670:
                            return Hr;
                        case 35667:
                        case 35671:
                            return Qr;
                        case 35668:
                        case 35672:
                            return ei;
                        case 35669:
                        case 35673:
                            return ti
                    }
                }(t.type)
            }

            function di(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return ni;
                        case 35664:
                            return ii;
                        case 35665:
                            return oi;
                        case 35666:
                            return ai;
                        case 35674:
                            return si;
                        case 35675:
                            return ui;
                        case 35676:
                            return ci;
                        case 35678:
                            return li;
                        case 35680:
                            return hi;
                        case 5124:
                        case 35670:
                            return ri;
                        case 35667:
                        case 35671:
                            return Qr;
                        case 35668:
                        case 35672:
                            return ei;
                        case 35669:
                        case 35673:
                            return ti
                    }
                }(t.type)
            }

            function fi(e) { this.id = e, Or.call(this) }
            di.prototype.updateCache = function(e) {
                var t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), kr(t, e)
            }, fi.prototype.setValue = function(e, t, n) {
                for (var r = this.seq, i = 0, o = r.length; i !== o; ++i) {
                    var a = r[i];
                    a.setValue(e, t[a.id], n)
                }
            };
            var mi = /([\w\d_]+)(\])?(\[|\.)?/g;

            function vi(e, t) { e.seq.push(t), e.map[t.id] = t }

            function gi(e, t, n) {
                var r = e.name,
                    i = r.length;
                for (mi.lastIndex = 0;;) {
                    var o = mi.exec(r),
                        a = mi.lastIndex,
                        s = o[1],
                        u = "]" === o[2],
                        c = o[3];
                    if (u && (s |= 0), void 0 === c || "[" === c && a + 2 === i) { vi(n, void 0 === c ? new pi(s, e, t) : new di(s, e, t)); break }
                    var l = n.map[s];
                    void 0 === l && vi(n, l = new fi(s)), n = l
                }
            }

            function yi(e, t, n) {
                Or.call(this), this.renderer = n;
                for (var r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), i = 0; i < r; ++i) {
                    var o = e.getActiveUniform(t, i);
                    gi(o, e.getUniformLocation(t, o.name), this)
                }
            }

            function _i(e, t, n) { var r = e.createShader(t); return e.shaderSource(r, n), e.compileShader(r), !1 === e.getShaderParameter(r, e.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(r), function(e) { for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n]; return t.join("\n") }(n)), r }
            yi.prototype.setValue = function(e, t, n) {
                var r = this.map[t];
                void 0 !== r && r.setValue(e, n, this.renderer)
            }, yi.prototype.setOptional = function(e, t, n) {
                var r = t[n];
                void 0 !== r && this.setValue(e, n, r)
            }, yi.upload = function(e, t, n, r) {
                for (var i = 0, o = t.length; i !== o; ++i) {
                    var a = t[i],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(e, s.value, r)
                }
            }, yi.seqWithValue = function(e, t) {
                for (var n = [], r = 0, i = e.length; r !== i; ++r) {
                    var o = e[r];
                    o.id in t && n.push(o)
                }
                return n
            };
            var xi = 0;

            function bi(e) {
                switch (e) {
                    case Nt:
                        return ["Linear", "( value )"];
                    case Bt:
                        return ["sRGB", "( value )"];
                    case kt:
                        return ["RGBE", "( value )"];
                    case jt:
                        return ["RGBM", "( value, 7.0 )"];
                    case Ht:
                        return ["RGBM", "( value, 16.0 )"];
                    case Vt:
                        return ["RGBD", "( value, 256.0 )"];
                    case zt:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + e)
                }
            }

            function wi(e, t) { var n = bi(t); return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" }

            function Mi(e) { return "" !== e }

            function Ei(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights) }

            function Si(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) }

            function Ti(e) { return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, t) { var n = bn[t]; if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">"); return Ti(n) }) }

            function Ai(e) { return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(e, t, n, r) { for (var i = "", o = parseInt(t); o < parseInt(n); o++) i += r.replace(/\[ i \]/g, "[ " + o + " ]"); return i }) }

            function Pi(e, t, n, r, i, o, a) {
                var s = e.context,
                    u = r.defines,
                    c = i.vertexShader,
                    l = i.fragmentShader,
                    h = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === E ? h = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === S && (h = "SHADOWMAP_TYPE_PCF_SOFT");
                var p = "ENVMAP_TYPE_CUBE",
                    d = "ENVMAP_MODE_REFLECTION",
                    f = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (r.envMap.mapping) {
                        case _e:
                        case xe:
                            p = "ENVMAP_TYPE_CUBE";
                            break;
                        case Ee:
                        case Se:
                            p = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case be:
                        case we:
                            p = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case Me:
                            p = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (r.envMap.mapping) {
                        case xe:
                        case we:
                            d = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (r.combine) {
                        case le:
                            f = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case he:
                            f = "ENVMAP_BLENDING_MIX";
                            break;
                        case pe:
                            f = "ENVMAP_BLENDING_ADD"
                    }
                }
                var m, v, g, y, _, x = e.gammaFactor > 0 ? e.gammaFactor : 1,
                    b = a.isWebGL2 ? "" : function(e, t, n) { return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mi).join("\n") }(r.extensions, o, t),
                    w = function(e) { var t = []; for (var n in e) { var r = e[n];!1 !== r && t.push("#define " + n + " " + r) } return t.join("\n") }(u),
                    M = s.createProgram();
                if (r.isRawShaderMaterial ? ((m = [w].filter(Mi).join("\n")).length > 0 && (m += "\n"), (v = [b, w].filter(Mi).join("\n")).length > 0 && (v += "\n")) : (m = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + h : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Mi).join("\n"), v = [b, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + x, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + h : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== de ? "#define TONE_MAPPING" : "", o.toneMapping !== de ? bn.tonemapping_pars_fragment : "", o.toneMapping !== de ? function(e, t) {
                        var n;
                        switch (t) {
                            case fe:
                                n = "Linear";
                                break;
                            case me:
                                n = "Reinhard";
                                break;
                            case ve:
                                n = "Uncharted2";
                                break;
                            case ge:
                                n = "OptimizedCineon";
                                break;
                            default:
                                throw new Error("unsupported toneMapping: " + t)
                        }
                        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                    }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? bn.encodings_pars_fragment : "", o.mapEncoding ? wi("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? wi("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? wi("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? wi("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? (g = "linearToOutputTexel", y = o.outputEncoding, _ = bi(y), "vec4 " + g + "( vec4 value ) { return LinearTo" + _[0] + _[1] + "; }") : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Mi).join("\n")), c = Si(c = Ei(c = Ti(c), o), o), l = Si(l = Ei(l = Ti(l), o), o), c = Ai(c), l = Ai(l), a.isWebGL2 && !r.isRawShaderMaterial) {
                    var T = !1,
                        A = /^\s*#version\s+300\s+es\s*\n/;
                    r.isShaderMaterial && null !== c.match(A) && null !== l.match(A) && (T = !0, c = c.replace(A, ""), l = l.replace(A, "")), m = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m, v = ["#version 300 es\n", "#define varying in", T ? "" : "out highp vec4 pc_fragColor;", T ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v
                }
                var P = m + c,
                    R = v + l,
                    L = _i(s, s.VERTEX_SHADER, P),
                    C = _i(s, s.FRAGMENT_SHADER, R);
                s.attachShader(M, L), s.attachShader(M, C), void 0 !== r.index0AttributeName ? s.bindAttribLocation(M, 0, r.index0AttributeName) : !0 === o.morphTargets && s.bindAttribLocation(M, 0, "position"), s.linkProgram(M);
                var O, I, D = s.getProgramInfoLog(M).trim(),
                    U = s.getShaderInfoLog(L).trim(),
                    F = s.getShaderInfoLog(C).trim(),
                    N = !0,
                    B = !0;
                return !1 === s.getProgramParameter(M, s.LINK_STATUS) ? (N = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "gl.VALIDATE_STATUS", s.getProgramParameter(M, s.VALIDATE_STATUS), "gl.getProgramInfoLog", D, U, F)) : "" !== D ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", D) : "" !== U && "" !== F || (B = !1), B && (this.diagnostics = { runnable: N, material: r, programLog: D, vertexShader: { log: U, prefix: m }, fragmentShader: { log: F, prefix: v } }), s.deleteShader(L), s.deleteShader(C), this.getUniforms = function() { return void 0 === O && (O = new yi(s, M, e)), O }, this.getAttributes = function() {
                    return void 0 === I && (I = function(e, t) {
                        for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                            var o = e.getActiveAttrib(t, i).name;
                            n[o] = e.getAttribLocation(t, o)
                        }
                        return n
                    }(s, M)), I
                }, this.destroy = function() { s.deleteProgram(M), this.program = void 0 }, Object.defineProperties(this, { uniforms: { get: function() { return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms() } }, attributes: { get: function() { return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes() } } }), this.name = i.name, this.id = xi++, this.code = n, this.usedTimes = 1, this.program = M, this.vertexShader = L, this.fragmentShader = C, this
            }

            function Ri(e, t, n) {
                var r = [],
                    i = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
                    o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function a(e, t) { var n; return e ? e.isTexture ? n = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = Nt, n === Nt && t && (n = zt), n }
                this.getParameters = function(t, r, o, s, u, c, l) {
                    var h = i[t.type],
                        p = l.isSkinnedMesh ? function(e) {
                            var t = e.skeleton.bones;
                            if (n.floatVertexTextures) return 1024;
                            var r = n.maxVertexUniforms,
                                i = Math.floor((r - 20) / 4),
                                o = Math.min(i, t.length);
                            return o < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + o + "."), 0) : o
                        }(l) : 0,
                        d = n.precision;
                    null !== t.precision && (d = n.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", d, "instead.");
                    var f = e.getRenderTarget();
                    return { shaderID: h, precision: d, supportsVertexTextures: n.vertexTextures, outputEncoding: a(f ? f.texture : null, e.gammaOutput), map: !!t.map, mapEncoding: a(t.map, e.gammaInput), matcap: !!t.matcap, matcapEncoding: a(t.matcap, e.gammaInput), envMap: !!t.envMap, envMapMode: t.envMap && t.envMap.mapping, envMapEncoding: a(t.envMap, e.gammaInput), envMapCubeUV: !!t.envMap && (t.envMap.mapping === Ee || t.envMap.mapping === Se), lightMap: !!t.lightMap, aoMap: !!t.aoMap, emissiveMap: !!t.emissiveMap, emissiveMapEncoding: a(t.emissiveMap, e.gammaInput), bumpMap: !!t.bumpMap, normalMap: !!t.normalMap, objectSpaceNormalMap: t.normalMapType === Yt, displacementMap: !!t.displacementMap, roughnessMap: !!t.roughnessMap, metalnessMap: !!t.metalnessMap, specularMap: !!t.specularMap, alphaMap: !!t.alphaMap, gradientMap: !!t.gradientMap, combine: t.combine, vertexColors: t.vertexColors, fog: !!s, useFog: t.fog, fogExp: s && s.isFogExp2, flatShading: t.flatShading, sizeAttenuation: t.sizeAttenuation, logarithmicDepthBuffer: n.logarithmicDepthBuffer, skinning: t.skinning && p > 0, maxBones: p, useVertexTexture: n.floatVertexTextures, morphTargets: t.morphTargets, morphNormals: t.morphNormals, maxMorphTargets: e.maxMorphTargets, maxMorphNormals: e.maxMorphNormals, numDirLights: r.directional.length, numPointLights: r.point.length, numSpotLights: r.spot.length, numRectAreaLights: r.rectArea.length, numHemiLights: r.hemi.length, numClippingPlanes: u, numClipIntersection: c, dithering: t.dithering, shadowMapEnabled: e.shadowMap.enabled && l.receiveShadow && o.length > 0, shadowMapType: e.shadowMap.type, toneMapping: e.toneMapping, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: t.premultipliedAlpha, alphaTest: t.alphaTest, doubleSided: t.side === P, flipSided: t.side === A, depthPacking: void 0 !== t.depthPacking && t.depthPacking }
                }, this.getProgramCode = function(t, n) {
                    var r = [];
                    if (n.shaderID ? r.push(n.shaderID) : (r.push(t.fragmentShader), r.push(t.vertexShader)), void 0 !== t.defines)
                        for (var i in t.defines) r.push(i), r.push(t.defines[i]);
                    for (var a = 0; a < o.length; a++) r.push(n[o[a]]);
                    return r.push(t.onBeforeCompile.toString()), r.push(e.gammaOutput), r.join()
                }, this.acquireProgram = function(i, o, a, s) { for (var u, c = 0, l = r.length; c < l; c++) { var h = r[c]; if (h.code === s) {++(u = h).usedTimes; break } } return void 0 === u && (u = new Pi(e, t, s, i, o, a, n), r.push(u)), u }, this.releaseProgram = function(e) {
                    if (0 == --e.usedTimes) {
                        var t = r.indexOf(e);
                        r[t] = r[r.length - 1], r.pop(), e.destroy()
                    }
                }, this.programs = r
            }

            function Li(e, t) { return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id }

            function Ci(e, t) { return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id }

            function Oi() {
                var e = {};
                return {
                    get: function(t, n) {
                        var r = t.id + "," + n.id,
                            i = e[r];
                        return void 0 === i && (i = new function() {
                            var e = [],
                                t = 0,
                                n = [],
                                r = [];
                            return {
                                opaque: n,
                                transparent: r,
                                init: function() { t = 0, n.length = 0, r.length = 0 },
                                push: function(i, o, a, s, u) {
                                    var c = e[t];
                                    void 0 === c ? (c = { id: i.id, object: i, geometry: o, material: a, program: a.program, renderOrder: i.renderOrder, z: s, group: u }, e[t] = c) : (c.id = i.id, c.object = i, c.geometry = o, c.material = a, c.program = a.program, c.renderOrder = i.renderOrder, c.z = s, c.group = u), (!0 === a.transparent ? r : n).push(c), t++
                                },
                                sort: function() { n.length > 1 && n.sort(Li), r.length > 1 && r.sort(Ci) }
                            }
                        }, e[r] = i), i
                    },
                    dispose: function() { e = {} }
                }
            }
            var Ii, Di, Ui, Fi, Ni, Bi, zi = 0;

            function ki() {
                var e = new function() {
                        var e = {};
                        return {
                            get: function(t) {
                                if (void 0 !== e[t.id]) return e[t.id];
                                var n;
                                switch (t.type) {
                                    case "DirectionalLight":
                                        n = { direction: new Qt, color: new En, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Jt };
                                        break;
                                    case "SpotLight":
                                        n = { position: new Qt, direction: new Qt, color: new En, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Jt };
                                        break;
                                    case "PointLight":
                                        n = { position: new Qt, color: new En, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Jt, shadowCameraNear: 1, shadowCameraFar: 1e3 };
                                        break;
                                    case "HemisphereLight":
                                        n = { direction: new Qt, skyColor: new En, groundColor: new En };
                                        break;
                                    case "RectAreaLight":
                                        n = { color: new En, position: new Qt, halfWidth: new Qt, halfHeight: new Qt }
                                }
                                return e[t.id] = n, n
                            }
                        }
                    },
                    t = { id: zi++, hash: { stateID: -1, directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, shadowsLength: -1 }, ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] },
                    n = new Qt,
                    r = new Kt,
                    i = new Kt;
                return {
                    setup: function(o, a, s) {
                        for (var u = 0, c = 0, l = 0, h = 0, p = 0, d = 0, f = 0, m = 0, v = s.matrixWorldInverse, g = 0, y = o.length; g < y; g++) {
                            var _ = o[g],
                                x = _.color,
                                b = _.intensity,
                                w = _.distance,
                                M = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
                            if (_.isAmbientLight) u += x.r * b, c += x.g * b, l += x.b * b;
                            else if (_.isDirectionalLight) {
                                if ((S = e.get(_)).color.copy(_.color).multiplyScalar(_.intensity), S.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(v), S.shadow = _.castShadow, _.castShadow) {
                                    var E = _.shadow;
                                    S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E.mapSize
                                }
                                t.directionalShadowMap[h] = M, t.directionalShadowMatrix[h] = _.shadow.matrix, t.directional[h] = S, h++
                            } else if (_.isSpotLight)(S = e.get(_)).position.setFromMatrixPosition(_.matrixWorld), S.position.applyMatrix4(v), S.color.copy(x).multiplyScalar(b), S.distance = w, S.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), S.direction.sub(n), S.direction.transformDirection(v), S.coneCos = Math.cos(_.angle), S.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), S.decay = _.decay, S.shadow = _.castShadow, _.castShadow && (E = _.shadow, S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E.mapSize), t.spotShadowMap[d] = M, t.spotShadowMatrix[d] = _.shadow.matrix, t.spot[d] = S, d++;
                            else if (_.isRectAreaLight)(S = e.get(_)).color.copy(x).multiplyScalar(b), S.position.setFromMatrixPosition(_.matrixWorld), S.position.applyMatrix4(v), i.identity(), r.copy(_.matrixWorld), r.premultiply(v), i.extractRotation(r), S.halfWidth.set(.5 * _.width, 0, 0), S.halfHeight.set(0, .5 * _.height, 0), S.halfWidth.applyMatrix4(i), S.halfHeight.applyMatrix4(i), t.rectArea[f] = S, f++;
                            else if (_.isPointLight)(S = e.get(_)).position.setFromMatrixPosition(_.matrixWorld), S.position.applyMatrix4(v), S.color.copy(_.color).multiplyScalar(_.intensity), S.distance = _.distance, S.decay = _.decay, S.shadow = _.castShadow, _.castShadow && (E = _.shadow, S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E.mapSize, S.shadowCameraNear = E.camera.near, S.shadowCameraFar = E.camera.far), t.pointShadowMap[p] = M, t.pointShadowMatrix[p] = _.shadow.matrix, t.point[p] = S, p++;
                            else if (_.isHemisphereLight) {
                                var S;
                                (S = e.get(_)).direction.setFromMatrixPosition(_.matrixWorld), S.direction.transformDirection(v), S.direction.normalize(), S.skyColor.copy(_.color).multiplyScalar(b), S.groundColor.copy(_.groundColor).multiplyScalar(b), t.hemi[m] = S, m++
                            }
                        }
                        t.ambient[0] = u, t.ambient[1] = c, t.ambient[2] = l, t.directional.length = h, t.spot.length = d, t.rectArea.length = f, t.point.length = p, t.hemi.length = m, t.hash.stateID = t.id, t.hash.directionalLength = h, t.hash.pointLength = p, t.hash.spotLength = d, t.hash.rectAreaLength = f, t.hash.hemiLength = m, t.hash.shadowsLength = a.length
                    },
                    state: t
                }
            }

            function Gi() {
                var e = new ki,
                    t = [],
                    n = [];
                return { init: function() { t.length = 0, n.length = 0 }, state: { lightsArray: t, shadowsArray: n, lights: e }, setupLights: function(r) { e.setup(t, n, r) }, pushLight: function(e) { t.push(e) }, pushShadow: function(e) { n.push(e) } }
            }

            function ji(e) { xr.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Wt, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e) }

            function Hi(e) { xr.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Qt, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e) }

            function Vi(e, t, n) {
                for (var r = new gn, i = new Kt, o = new Jt, a = new Jt(n, n), s = new Qt, u = new Qt, c = 1, l = 2, h = 1 + (c | l), p = new Array(h), d = new Array(h), f = {}, m = { 0: A, 1: T, 2: P }, v = [new Qt(1, 0, 0), new Qt(-1, 0, 0), new Qt(0, 0, 1), new Qt(0, 0, -1), new Qt(0, 1, 0), new Qt(0, -1, 0)], g = [new Qt(0, 1, 0), new Qt(0, 1, 0), new Qt(0, 1, 0), new Qt(0, 1, 0), new Qt(0, 0, 1), new Qt(0, 0, -1)], y = [new ln, new ln, new ln, new ln, new ln, new ln], _ = 0; _ !== h; ++_) {
                    var x = 0 != (_ & c),
                        b = 0 != (_ & l),
                        w = new ji({ depthPacking: Xt, morphTargets: x, skinning: b });
                    p[_] = w;
                    var M = new Hi({ morphTargets: x, skinning: b });
                    d[_] = M
                }
                var S = this;

                function R(t, n, r, i, o, a) {
                    var s = t.geometry,
                        u = null,
                        h = p,
                        v = t.customDepthMaterial;
                    if (r && (h = d, v = t.customDistanceMaterial), v) u = v;
                    else {
                        var g = !1;
                        n.morphTargets && (s && s.isBufferGeometry ? g = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (g = s.morphTargets && s.morphTargets.length > 0)), t.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
                        var y = t.isSkinnedMesh && n.skinning,
                            _ = 0;
                        g && (_ |= c), y && (_ |= l), u = h[_]
                    }
                    if (e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                        var x = u.uuid,
                            b = n.uuid,
                            w = f[x];
                        void 0 === w && (w = {}, f[x] = w);
                        var M = w[b];
                        void 0 === M && (M = u.clone(), w[b] = M), u = M
                    }
                    return u.visible = n.visible, u.wireframe = n.wireframe, u.side = null != n.shadowSide ? n.shadowSide : m[n.side], u.clipShadows = n.clipShadows, u.clippingPlanes = n.clippingPlanes, u.clipIntersection = n.clipIntersection, u.wireframeLinewidth = n.wireframeLinewidth, u.linewidth = n.linewidth, r && u.isMeshDistanceMaterial && (u.referencePosition.copy(i), u.nearDistance = o, u.farDistance = a), u
                }

                function L(n, i, o, a) {
                    if (!1 !== n.visible) {
                        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || r.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                            var s = t.update(n),
                                c = n.material;
                            if (Array.isArray(c))
                                for (var l = s.groups, h = 0, p = l.length; h < p; h++) {
                                    var d = l[h],
                                        f = c[d.materialIndex];
                                    if (f && f.visible) {
                                        var m = R(n, f, a, u, o.near, o.far);
                                        e.renderBufferDirect(o, null, s, m, n, d)
                                    }
                                } else if (c.visible) {
                                    m = R(n, c, a, u, o.near, o.far);
                                    e.renderBufferDirect(o, null, s, m, n, null)
                                }
                        }
                        for (var v = n.children, g = 0, y = v.length; g < y; g++) L(v[g], i, o, a)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = E, this.render = function(t, n, c) {
                    if (!1 !== S.enabled && (!1 !== S.autoUpdate || !1 !== S.needsUpdate) && 0 !== t.length) {
                        var l, h = e.context,
                            p = e.state;
                        p.disable(h.BLEND), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
                        for (var d = 0, f = t.length; d < f; d++) {
                            var m = t[d],
                                _ = m.shadow,
                                x = m && m.isPointLight;
                            if (void 0 !== _) {
                                var b = _.camera;
                                if (o.copy(_.mapSize), o.min(a), x) {
                                    var w = o.x,
                                        M = o.y;
                                    y[0].set(2 * w, M, w, M), y[1].set(0, M, w, M), y[2].set(3 * w, M, w, M), y[3].set(w, M, w, M), y[4].set(3 * w, 0, w, M), y[5].set(w, 0, w, M), o.x *= 4, o.y *= 2
                                }
                                if (null === _.map) {
                                    var E = { minFilter: Re, magFilter: Re, format: Ze };
                                    _.map = new hn(o.x, o.y, E), _.map.texture.name = m.name + ".shadowMap", b.updateProjectionMatrix()
                                }
                                _.isSpotLightShadow && _.update(m);
                                var T = _.map,
                                    A = _.matrix;
                                u.setFromMatrixPosition(m.matrixWorld), b.position.copy(u), x ? (l = 6, A.makeTranslation(-u.x, -u.y, -u.z)) : (l = 1, s.setFromMatrixPosition(m.target.matrixWorld), b.lookAt(s), b.updateMatrixWorld(), A.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), A.multiply(b.projectionMatrix), A.multiply(b.matrixWorldInverse)), e.setRenderTarget(T), e.clear();
                                for (var P = 0; P < l; P++) {
                                    if (x) {
                                        s.copy(b.position), s.add(v[P]), b.up.copy(g[P]), b.lookAt(s), b.updateMatrixWorld();
                                        var R = y[P];
                                        p.viewport(R)
                                    }
                                    i.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), r.setFromMatrix(i), L(n, c, b, x)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", m, "has no shadow.")
                        }
                        S.needsUpdate = !1
                    }
                }
            }

            function Wi(e, t, n, r, i, o, a) {
                var s, u = {};

                function c(e, t) {
                    if (e.width > t || e.height > t) {
                        if ("data" in e) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + e.width + "x" + e.height + ").");
                        var n = t / Math.max(e.width, e.height),
                            r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return r.width = Math.floor(e.width * n), r.height = Math.floor(e.height * n), r.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, r.width, r.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height), r
                    }
                    return e
                }

                function l(e) { return Zt.isPowerOfTwo(e.width) && Zt.isPowerOfTwo(e.height) }

                function h(e, t) { return e.generateMipmaps && t && e.minFilter !== Re && e.minFilter !== Oe }

                function p(t, n, i, o) { e.generateMipmap(t), r.get(n).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E }

                function d(t, n) { if (!i.isWebGL2) return t; if (t === e.RED) { if (n === e.FLOAT) return e.R32F; if (n === e.HALF_FLOAT) return e.R16F; if (n === e.UNSIGNED_BYTE) return e.R8 } if (t === e.RGB) { if (n === e.FLOAT) return e.RGB32F; if (n === e.HALF_FLOAT) return e.RGB16F; if (n === e.UNSIGNED_BYTE) return e.RGB8 } if (t === e.RGBA) { if (n === e.FLOAT) return e.RGBA32F; if (n === e.HALF_FLOAT) return e.RGBA16F; if (n === e.UNSIGNED_BYTE) return e.RGBA8 } return t }

                function f(t) { return t === Re || t === Le || t === Ce ? e.NEAREST : e.LINEAR }

                function m(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", m),
                        function(t) {
                            var n = r.get(t);
                            if (t.image && n.__image__webglTextureCube) e.deleteTexture(n.__image__webglTextureCube);
                            else {
                                if (void 0 === n.__webglInit) return;
                                e.deleteTexture(n.__webglTexture)
                            }
                            r.remove(t)
                        }(n), n.isVideoTexture && delete u[n.id], a.memory.textures--
                }

                function v(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", v),
                        function(t) {
                            var n = r.get(t),
                                i = r.get(t.texture);
                            if (!t) return;
                            void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture);
                            t.depthTexture && t.depthTexture.dispose();
                            if (t.isWebGLRenderTargetCube)
                                for (var o = 0; o < 6; o++) e.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                            else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer);
                            r.remove(t.texture), r.remove(t)
                        }(n), a.memory.textures--
                }

                function g(t, i) {
                    var o = r.get(t);
                    if (t.isVideoTexture && function(e) {
                            var t = e.id,
                                n = a.render.frame;
                            u[t] !== n && (u[t] = n, e.update())
                        }(t), t.version > 0 && o.__version !== t.version) {
                        var s = t.image;
                        if (void 0 === s) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== s.complete) return void _(o, t, i);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_2D, o.__webglTexture)
                }

                function y(n, a, s) {
                    var u;
                    if (s ? (e.texParameteri(n, e.TEXTURE_WRAP_S, o.convert(a.wrapS)), e.texParameteri(n, e.TEXTURE_WRAP_T, o.convert(a.wrapT)), e.texParameteri(n, e.TEXTURE_MAG_FILTER, o.convert(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), a.wrapS === Ae && a.wrapT === Ae || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, e.TEXTURE_MAG_FILTER, f(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, f(a.minFilter)), a.minFilter !== Re && a.minFilter !== Oe && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), u = t.get("EXT_texture_filter_anisotropic")) {
                        if (a.type === Ge && null === t.get("OES_texture_float_linear")) return;
                        if (a.type === je && null === (i.isWebGL2 || t.get("OES_texture_half_float_linear"))) return;
                        (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, u.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function _(t, r, u) {
                    var f;
                    f = r.isDataTexture3D ? e.TEXTURE_3D : e.TEXTURE_2D, void 0 === t.__webglInit && (t.__webglInit = !0, r.addEventListener("dispose", m), t.__webglTexture = e.createTexture(), a.memory.textures++), n.activeTexture(e.TEXTURE0 + u), n.bindTexture(f, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, r.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, r.unpackAlignment);
                    var v = c(r.image, i.maxTextureSize);
                    (function(e) { return !i.isWebGL2 && (e.wrapS !== Ae || e.wrapT !== Ae || e.minFilter !== Re && e.minFilter !== Oe) })(r) && !1 === l(v) && (v = function(e) { return e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap ? (void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s.width = Zt.floorPowerOfTwo(e.width), s.height = Zt.floorPowerOfTwo(e.height), s.getContext("2d").drawImage(e, 0, 0, s.width, s.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + s.width + "x" + s.height), s) : e }(v));
                    var g = l(v),
                        _ = o.convert(r.format),
                        x = o.convert(r.type),
                        b = d(_, x);
                    y(f, r, g);
                    var w, M = r.mipmaps;
                    if (r.isDepthTexture) {
                        if (b = e.DEPTH_COMPONENT, r.type === Ge) {
                            if (!i.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            b = e.DEPTH_COMPONENT32F
                        } else i.isWebGL2 && (b = e.DEPTH_COMPONENT16);
                        r.format === Qe && b === e.DEPTH_COMPONENT && r.type !== Be && r.type !== ke && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Be, x = o.convert(r.type)), r.format === et && (b = e.DEPTH_STENCIL, r.type !== Xe && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Xe, x = o.convert(r.type))), n.texImage2D(e.TEXTURE_2D, 0, b, v.width, v.height, 0, _, x, null)
                    } else if (r.isDataTexture)
                        if (M.length > 0 && g) {
                            for (var E = 0, S = M.length; E < S; E++) w = M[E], n.texImage2D(e.TEXTURE_2D, E, b, w.width, w.height, 0, _, x, w.data);
                            r.generateMipmaps = !1, t.__maxMipLevel = M.length - 1
                        } else n.texImage2D(e.TEXTURE_2D, 0, b, v.width, v.height, 0, _, x, v.data), t.__maxMipLevel = 0;
                    else if (r.isCompressedTexture) {
                        for (E = 0, S = M.length; E < S; E++) w = M[E], r.format !== Ze && r.format !== Ye ? n.getCompressedTextureFormats().indexOf(_) > -1 ? n.compressedTexImage2D(e.TEXTURE_2D, E, b, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(e.TEXTURE_2D, E, b, w.width, w.height, 0, _, x, w.data);
                        t.__maxMipLevel = M.length - 1
                    } else if (r.isDataTexture3D) n.texImage3D(e.TEXTURE_3D, 0, b, v.width, v.height, v.depth, 0, _, x, v.data), t.__maxMipLevel = 0;
                    else if (M.length > 0 && g) {
                        for (E = 0, S = M.length; E < S; E++) w = M[E], n.texImage2D(e.TEXTURE_2D, E, b, _, x, w);
                        r.generateMipmaps = !1, t.__maxMipLevel = M.length - 1
                    } else n.texImage2D(e.TEXTURE_2D, 0, b, _, x, v), t.__maxMipLevel = 0;
                    h(r, g) && p(e.TEXTURE_2D, r, v.width, v.height), t.__version = r.version, r.onUpdate && r.onUpdate(r)
                }

                function x(t, i, a, s) {
                    var u = o.convert(i.texture.format),
                        c = o.convert(i.texture.type),
                        l = d(u, c);
                    n.texImage2D(s, 0, l, i.width, i.height, 0, u, c, null), e.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, a, s, r.get(i.texture).__webglTexture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null)
                }

                function b(t, n) { e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)) : n.depthBuffer && n.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, n.width, n.height), e.bindRenderbuffer(e.RENDERBUFFER, null) }

                function w(t) {
                    var n = r.get(t),
                        i = !0 === t.isWebGLRenderTargetCube;
                    if (t.depthTexture) {
                        if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, n) {
                            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (e.bindFramebuffer(e.FRAMEBUFFER, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), g(n.depthTexture, 0);
                            var i = r.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === Qe) e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, i, 0);
                            else {
                                if (n.depthTexture.format !== et) throw new Error("Unknown depthTexture format");
                                e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, i, 0)
                            }
                        }(n.__webglFramebuffer, t)
                    } else if (i) { n.__webglDepthbuffer = []; for (var o = 0; o < 6; o++) e.bindFramebuffer(e.FRAMEBUFFER, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = e.createRenderbuffer(), b(n.__webglDepthbuffer[o], t) } else e.bindFramebuffer(e.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), b(n.__webglDepthbuffer, t);
                    e.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                this.setTexture2D = g, this.setTexture3D = function(t, i) {
                    var o = r.get(t);
                    t.version > 0 && o.__version !== t.version ? _(o, t, i) : (n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_3D, o.__webglTexture))
                }, this.setTextureCube = function(t, s) {
                    var u = r.get(t);
                    if (6 === t.image.length)
                        if (t.version > 0 && u.__version !== t.version) {
                            u.__image__webglTextureCube || (t.addEventListener("dispose", m), u.__image__webglTextureCube = e.createTexture(), a.memory.textures++), n.activeTexture(e.TEXTURE0 + s), n.bindTexture(e.TEXTURE_CUBE_MAP, u.__image__webglTextureCube), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY);
                            for (var f = t && t.isCompressedTexture, v = t.image[0] && t.image[0].isDataTexture, g = [], _ = 0; _ < 6; _++) g[_] = f || v ? v ? t.image[_].image : t.image[_] : c(t.image[_], i.maxCubemapSize);
                            var x = g[0],
                                b = l(x),
                                w = o.convert(t.format),
                                M = o.convert(t.type),
                                E = d(w, M);
                            for (y(e.TEXTURE_CUBE_MAP, t, b), _ = 0; _ < 6; _++)
                                if (f)
                                    for (var S, T = g[_].mipmaps, A = 0, P = T.length; A < P; A++) S = T[A], t.format !== Ze && t.format !== Ye ? n.getCompressedTextureFormats().indexOf(w) > -1 ? n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + _, A, E, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + _, A, E, S.width, S.height, 0, w, M, S.data);
                                else v ? n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + _, 0, E, g[_].width, g[_].height, 0, w, M, g[_].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + _, 0, E, w, M, g[_]);
                            u.__maxMipLevel = f ? T.length - 1 : 0, h(t, b) && p(e.TEXTURE_CUBE_MAP, t, x.width, x.height), u.__version = t.version, t.onUpdate && t.onUpdate(t)
                        } else n.activeTexture(e.TEXTURE0 + s), n.bindTexture(e.TEXTURE_CUBE_MAP, u.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function(t, i) { n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_CUBE_MAP, r.get(t).__webglTexture) }, this.setupRenderTarget = function(t) {
                    var i = r.get(t),
                        o = r.get(t.texture);
                    t.addEventListener("dispose", v), o.__webglTexture = e.createTexture(), a.memory.textures++;
                    var s = !0 === t.isWebGLRenderTargetCube,
                        u = l(t);
                    if (s) { i.__webglFramebuffer = []; for (var c = 0; c < 6; c++) i.__webglFramebuffer[c] = e.createFramebuffer() } else i.__webglFramebuffer = e.createFramebuffer();
                    if (s) {
                        for (n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture), y(e.TEXTURE_CUBE_MAP, t.texture, u), c = 0; c < 6; c++) x(i.__webglFramebuffer[c], t, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + c);
                        h(t.texture, u) && p(e.TEXTURE_CUBE_MAP, t.texture, t.width, t.height), n.bindTexture(e.TEXTURE_CUBE_MAP, null)
                    } else n.bindTexture(e.TEXTURE_2D, o.__webglTexture), y(e.TEXTURE_2D, t.texture, u), x(i.__webglFramebuffer, t, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), h(t.texture, u) && p(e.TEXTURE_2D, t.texture, t.width, t.height), n.bindTexture(e.TEXTURE_2D, null);
                    t.depthBuffer && w(t)
                }, this.updateRenderTargetMipmap = function(t) {
                    var i = t.texture;
                    if (h(i, l(t))) {
                        var o = t.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
                            a = r.get(i).__webglTexture;
                        n.bindTexture(o, a), p(o, i, t.width, t.height), n.bindTexture(o, null)
                    }
                }
            }

            function Xi(e, t, n) { return { convert: function(r) { var i; if (r === Te) return e.REPEAT; if (r === Ae) return e.CLAMP_TO_EDGE; if (r === Pe) return e.MIRRORED_REPEAT; if (r === Re) return e.NEAREST; if (r === Le) return e.NEAREST_MIPMAP_NEAREST; if (r === Ce) return e.NEAREST_MIPMAP_LINEAR; if (r === Oe) return e.LINEAR; if (r === Ie) return e.LINEAR_MIPMAP_NEAREST; if (r === De) return e.LINEAR_MIPMAP_LINEAR; if (r === Ue) return e.UNSIGNED_BYTE; if (r === He) return e.UNSIGNED_SHORT_4_4_4_4; if (r === Ve) return e.UNSIGNED_SHORT_5_5_5_1; if (r === We) return e.UNSIGNED_SHORT_5_6_5; if (r === Fe) return e.BYTE; if (r === Ne) return e.SHORT; if (r === Be) return e.UNSIGNED_SHORT; if (r === ze) return e.INT; if (r === ke) return e.UNSIGNED_INT; if (r === Ge) return e.FLOAT; if (r === je) { if (n.isWebGL2) return e.HALF_FLOAT; if (null !== (i = t.get("OES_texture_half_float"))) return i.HALF_FLOAT_OES } if (r === qe) return e.ALPHA; if (r === Ye) return e.RGB; if (r === Ze) return e.RGBA; if (r === Je) return e.LUMINANCE; if (r === Ke) return e.LUMINANCE_ALPHA; if (r === Qe) return e.DEPTH_COMPONENT; if (r === et) return e.DEPTH_STENCIL; if (r === tt) return e.RED; if (r === k) return e.FUNC_ADD; if (r === G) return e.FUNC_SUBTRACT; if (r === j) return e.FUNC_REVERSE_SUBTRACT; if (r === W) return e.ZERO; if (r === X) return e.ONE; if (r === q) return e.SRC_COLOR; if (r === Y) return e.ONE_MINUS_SRC_COLOR; if (r === Z) return e.SRC_ALPHA; if (r === J) return e.ONE_MINUS_SRC_ALPHA; if (r === K) return e.DST_ALPHA; if (r === $) return e.ONE_MINUS_DST_ALPHA; if (r === Q) return e.DST_COLOR; if (r === ee) return e.ONE_MINUS_DST_COLOR; if (r === te) return e.SRC_ALPHA_SATURATE; if ((r === nt || r === rt || r === it || r === ot) && null !== (i = t.get("WEBGL_compressed_texture_s3tc"))) { if (r === nt) return i.COMPRESSED_RGB_S3TC_DXT1_EXT; if (r === rt) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (r === it) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (r === ot) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT } if ((r === at || r === st || r === ut || r === ct) && null !== (i = t.get("WEBGL_compressed_texture_pvrtc"))) { if (r === at) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (r === st) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (r === ut) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (r === ct) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (r === lt && null !== (i = t.get("WEBGL_compressed_texture_etc1"))) return i.COMPRESSED_RGB_ETC1_WEBGL; if ((r === ht || r === pt || r === dt || r === ft || r === mt || r === vt || r === gt || r === yt || r === _t || r === xt || r === bt || r === wt || r === Mt || r === Et) && null !== (i = t.get("WEBGL_compressed_texture_astc"))) return r; if (r === H || r === V) { if (n.isWebGL2) { if (r === H) return e.MIN; if (r === V) return e.MAX } if (null !== (i = t.get("EXT_blend_minmax"))) { if (r === H) return i.MIN_EXT; if (r === V) return i.MAX_EXT } } if (r === Xe) { if (n.isWebGL2) return e.UNSIGNED_INT_24_8; if (null !== (i = t.get("WEBGL_depth_texture"))) return i.UNSIGNED_INT_24_8_WEBGL } return 0 } } }

            function qi() { Bn.call(this), this.type = "Group" }

            function Yi() { Bn.call(this), this.type = "Camera", this.matrixWorldInverse = new Kt, this.projectionMatrix = new Kt, this.projectionMatrixInverse = new Kt }

            function Zi(e, t, n, r) { Yi.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() }

            function Ji(e) { Zi.call(this), this.cameras = e || [] }

            function Ki(e) {
                var t = this,
                    n = null,
                    r = null,
                    i = null,
                    o = [],
                    a = new Kt,
                    s = new Kt,
                    u = "stage";
                "undefined" != typeof window && "VRFrameData" in window && (r = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", y, !1));
                var c = new Kt,
                    l = new $t,
                    h = new Qt,
                    p = new Zi;
                p.bounds = new ln(0, 0, .5, 1), p.layers.enable(1);
                var d = new Zi;
                d.bounds = new ln(.5, 0, .5, 1), d.layers.enable(2);
                var f, m, v = new Ji([p, d]);

                function g() { return null !== n && !0 === n.isPresenting }

                function y() {
                    if (g()) {
                        var r = n.getEyeParameters("left"),
                            i = r.renderWidth,
                            o = r.renderHeight;
                        m = e.getPixelRatio(), f = e.getSize(), e.setDrawingBufferSize(2 * i, o, 1), b.start()
                    } else t.enabled && e.setDrawingBufferSize(f.width, f.height, m), b.stop()
                }
                v.layers.enable(1), v.layers.enable(2);
                var _ = [];

                function x(e) {
                    for (var t = navigator.getGamepads && navigator.getGamepads(), n = 0, r = 0, i = t.length; n < i; n++) {
                        var o = t[n];
                        if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("Spatial Controller"))) {
                            if (r === e) return o;
                            r++
                        }
                    }
                }
                this.enabled = !1, this.getController = function(e) { var t = o[e]; return void 0 === t && ((t = new qi).matrixAutoUpdate = !1, t.visible = !1, o[e] = t), t }, this.getDevice = function() { return n }, this.setDevice = function(e) { void 0 !== e && (n = e), b.setContext(e) }, this.setFrameOfReferenceType = function(e) { u = e }, this.setPoseTarget = function(e) { void 0 !== e && (i = e) }, this.getCamera = function(e) {
                    var t = "stage" === u ? 1.6 : 0;
                    if (null === n) return e.position.set(0, t, 0), e;
                    if (n.depthNear = e.near, n.depthFar = e.far, n.getFrameData(r), "stage" === u) {
                        var f = n.stageParameters;
                        f ? a.fromArray(f.sittingToStandingTransform) : a.makeTranslation(0, t, 0)
                    }
                    var m = r.pose,
                        g = null !== i ? i : e;
                    if (g.matrix.copy(a), g.matrix.decompose(g.position, g.quaternion, g.scale), null !== m.orientation && (l.fromArray(m.orientation), g.quaternion.multiply(l)), null !== m.position && (l.setFromRotationMatrix(a), h.fromArray(m.position), h.applyQuaternion(l), g.position.add(h)), g.updateMatrixWorld(), !1 === n.isPresenting) return e;
                    p.near = e.near, d.near = e.near, p.far = e.far, d.far = e.far, v.matrixWorld.copy(e.matrixWorld), v.matrixWorldInverse.copy(e.matrixWorldInverse), p.matrixWorldInverse.fromArray(r.leftViewMatrix), d.matrixWorldInverse.fromArray(r.rightViewMatrix), s.getInverse(a), "stage" === u && (p.matrixWorldInverse.multiply(s), d.matrixWorldInverse.multiply(s));
                    var y = g.parent;
                    null !== y && (c.getInverse(y.matrixWorld), p.matrixWorldInverse.multiply(c), d.matrixWorldInverse.multiply(c)), p.matrixWorld.getInverse(p.matrixWorldInverse), d.matrixWorld.getInverse(d.matrixWorldInverse), p.projectionMatrix.fromArray(r.leftProjectionMatrix), d.projectionMatrix.fromArray(r.rightProjectionMatrix), v.projectionMatrix.copy(p.projectionMatrix);
                    var b = n.getLayers();
                    if (b.length) {
                        var w = b[0];
                        null !== w.leftBounds && 4 === w.leftBounds.length && p.bounds.fromArray(w.leftBounds), null !== w.rightBounds && 4 === w.rightBounds.length && d.bounds.fromArray(w.rightBounds)
                    }
                    return function() {
                        for (var e = 0; e < o.length; e++) {
                            var t = o[e],
                                n = x(e);
                            if (void 0 !== n && void 0 !== n.pose) {
                                if (null === n.pose) return;
                                var r = n.pose;
                                !1 === r.hasPosition && t.position.set(.2, -.6, -.05), null !== r.position && t.position.fromArray(r.position), null !== r.orientation && t.quaternion.fromArray(r.orientation), t.matrix.compose(t.position, t.quaternion, t.scale), t.matrix.premultiply(a), t.matrix.decompose(t.position, t.quaternion, t.scale), t.matrixWorldNeedsUpdate = !0, t.visible = !0;
                                var i = "Daydream Controller" === n.id ? 0 : 1;
                                _[e] !== n.buttons[i].pressed && (_[e] = n.buttons[i].pressed, !0 === _[e] ? t.dispatchEvent({ type: "selectstart" }) : (t.dispatchEvent({ type: "selectend" }), t.dispatchEvent({ type: "select" })))
                            } else t.visible = !1
                        }
                    }(), v
                }, this.getStandingMatrix = function() { return a }, this.isPresenting = g;
                var b = new Pn;
                this.setAnimationLoop = function(e) { b.setAnimationLoop(e) }, this.submitFrame = function() { g() && n.submitFrame() }, this.dispose = function() { "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", y) }
            }

            function $i(e) {
                console.log("THREE.WebGLRenderer", m);
                var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== e.context ? e.context : null,
                    r = void 0 !== e.alpha && e.alpha,
                    i = void 0 === e.depth || e.depth,
                    o = void 0 === e.stencil || e.stencil,
                    a = void 0 !== e.antialias && e.antialias,
                    s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    u = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    c = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    l = null,
                    h = null;
                this.domElement = t, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = fe, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var p, d, f, v, x, b, w, M, E, S, R, L, C, O, I, G, j, H, V = this,
                    W = !1,
                    X = null,
                    q = null,
                    Y = null,
                    Z = -1,
                    J = { geometry: null, program: null, wireframe: !1 },
                    K = null,
                    $ = null,
                    Q = new ln,
                    ee = new ln,
                    te = null,
                    le = 0,
                    he = t.width,
                    pe = t.height,
                    de = 1,
                    me = new ln(0, 0, he, pe),
                    ve = new ln(0, 0, he, pe),
                    ge = !1,
                    ye = new gn,
                    _e = new function() {
                        var e = this,
                            t = null,
                            n = 0,
                            r = !1,
                            i = !1,
                            o = new vn,
                            a = new en,
                            s = { value: null, needsUpdate: !1 };

                        function u() { s.value !== t && (s.value = t, s.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0 }

                        function c(t, n, r, i) {
                            var u = null !== t ? t.length : 0,
                                c = null;
                            if (0 !== u) {
                                if (c = s.value, !0 !== i || null === c) {
                                    var l = r + 4 * u,
                                        h = n.matrixWorldInverse;
                                    a.getNormalMatrix(h), (null === c || c.length < l) && (c = new Float32Array(l));
                                    for (var p = 0, d = r; p !== u; ++p, d += 4) o.copy(t[p]).applyMatrix4(h, a), o.normal.toArray(c, d), c[d + 3] = o.constant
                                }
                                s.value = c, s.needsUpdate = !0
                            }
                            return e.numPlanes = u, c
                        }
                        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, i, o) { var a = 0 !== e.length || i || 0 !== n || r; return r = i, t = c(e, o, 0), n = e.length, a }, this.beginShadows = function() { i = !0, c(null) }, this.endShadows = function() { i = !1, u() }, this.setState = function(e, o, a, l, h, p) {
                            if (!r || null === e || 0 === e.length || i && !a) i ? c(null) : u();
                            else {
                                var d = i ? 0 : n,
                                    f = 4 * d,
                                    m = h.clippingState || null;
                                s.value = m, m = c(e, l, f, p);
                                for (var v = 0; v !== f; ++v) m[v] = t[v];
                                h.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += d
                            }
                        }
                    },
                    xe = !1,
                    be = !1,
                    we = new Kt,
                    Me = new Qt;

                function Ee() { return null === q ? de : 1 }
                try {
                    var Se = { alpha: r, depth: i, stencil: o, antialias: a, premultipliedAlpha: s, preserveDrawingBuffer: u, powerPreference: c };
                    if (t.addEventListener("webglcontextlost", Re, !1), t.addEventListener("webglcontextrestored", Le, !1), null === (p = n || t.getContext("webgl", Se) || t.getContext("experimental-webgl", Se))) throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === p.getShaderPrecisionFormat && (p.getShaderPrecisionFormat = function() { return { rangeMin: 1, rangeMax: 1, precision: 1 } })
                } catch (e) { console.error("THREE.WebGLRenderer: " + e.message) }

                function Te() {
                    d = new function(e) {
                        var t = {};
                        return {
                            get: function(n) {
                                if (void 0 !== t[n]) return t[n];
                                var r;
                                switch (n) {
                                    case "WEBGL_depth_texture":
                                        r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                                        break;
                                    case "EXT_texture_filter_anisotropic":
                                        r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                        break;
                                    case "WEBGL_compressed_texture_s3tc":
                                        r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                        break;
                                    case "WEBGL_compressed_texture_pvrtc":
                                        r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                        break;
                                    default:
                                        r = e.getExtension(n)
                                }
                                return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = r, r
                            }
                        }
                    }(p), (f = new function(e, t, n) {
                        var r;

                        function i(t) {
                            if ("highp" === t) {
                                if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                                t = "mediump"
                            }
                            return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                        }
                        var o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
                            a = void 0 !== n.precision ? n.precision : "highp",
                            s = i(a);
                        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                        var u = !0 === n.logarithmicDepthBuffer,
                            c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                            l = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                            h = e.getParameter(e.MAX_TEXTURE_SIZE),
                            p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                            d = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                            f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                            m = e.getParameter(e.MAX_VARYING_VECTORS),
                            v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                            g = l > 0,
                            y = o || !!t.get("OES_texture_float");
                        return { isWebGL2: o, getMaxAnisotropy: function() { if (void 0 !== r) return r; var n = t.get("EXT_texture_filter_anisotropic"); return r = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: i, precision: a, logarithmicDepthBuffer: u, maxTextures: c, maxVertexTextures: l, maxTextureSize: h, maxCubemapSize: p, maxAttributes: d, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: v, vertexTextures: g, floatFragmentTextures: y, floatVertexTextures: g && y }
                    }(p, d, e)).isWebGL2 || (d.get("WEBGL_depth_texture"), d.get("OES_texture_float"), d.get("OES_texture_half_float"), d.get("OES_texture_half_float_linear"), d.get("OES_standard_derivatives"), d.get("OES_element_index_uint"), d.get("ANGLE_instanced_arrays")), d.get("OES_texture_float_linear"), H = new Xi(p, d, f), (v = new function(e, t, n, r) {
                        var i = new function() {
                                var t = !1,
                                    n = new ln,
                                    r = null,
                                    i = new ln(0, 0, 0, 0);
                                return { setMask: function(n) { r === n || t || (e.colorMask(n, n, n, n), r = n) }, setLocked: function(e) { t = e }, setClear: function(t, r, o, a, s) {!0 === s && (t *= a, r *= a, o *= a), n.set(t, r, o, a), !1 === i.equals(n) && (e.clearColor(t, r, o, a), i.copy(n)) }, reset: function() { t = !1, r = null, i.set(-1, 0, 0, 0) } }
                            },
                            o = new function() {
                                var t = !1,
                                    n = null,
                                    r = null,
                                    i = null;
                                return {
                                    setTest: function(t) { t ? K(e.DEPTH_TEST) : $(e.DEPTH_TEST) },
                                    setMask: function(r) { n === r || t || (e.depthMask(r), n = r) },
                                    setFunc: function(t) {
                                        if (r !== t) {
                                            if (t) switch (t) {
                                                case ne:
                                                    e.depthFunc(e.NEVER);
                                                    break;
                                                case re:
                                                    e.depthFunc(e.ALWAYS);
                                                    break;
                                                case ie:
                                                    e.depthFunc(e.LESS);
                                                    break;
                                                case oe:
                                                    e.depthFunc(e.LEQUAL);
                                                    break;
                                                case ae:
                                                    e.depthFunc(e.EQUAL);
                                                    break;
                                                case se:
                                                    e.depthFunc(e.GEQUAL);
                                                    break;
                                                case ue:
                                                    e.depthFunc(e.GREATER);
                                                    break;
                                                case ce:
                                                    e.depthFunc(e.NOTEQUAL);
                                                    break;
                                                default:
                                                    e.depthFunc(e.LEQUAL)
                                            } else e.depthFunc(e.LEQUAL);
                                            r = t
                                        }
                                    },
                                    setLocked: function(e) { t = e },
                                    setClear: function(t) { i !== t && (e.clearDepth(t), i = t) },
                                    reset: function() { t = !1, n = null, r = null, i = null }
                                }
                            },
                            a = new function() {
                                var t = !1,
                                    n = null,
                                    r = null,
                                    i = null,
                                    o = null,
                                    a = null,
                                    s = null,
                                    u = null,
                                    c = null;
                                return { setTest: function(t) { t ? K(e.STENCIL_TEST) : $(e.STENCIL_TEST) }, setMask: function(r) { n === r || t || (e.stencilMask(r), n = r) }, setFunc: function(t, n, a) { r === t && i === n && o === a || (e.stencilFunc(t, n, a), r = t, i = n, o = a) }, setOp: function(t, n, r) { a === t && s === n && u === r || (e.stencilOp(t, n, r), a = t, s = n, u = r) }, setLocked: function(e) { t = e }, setClear: function(t) { c !== t && (e.clearStencil(t), c = t) }, reset: function() { t = !1, n = null, r = null, i = null, o = null, a = null, s = null, u = null, c = null } }
                            },
                            s = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                            u = new Uint8Array(s),
                            c = new Uint8Array(s),
                            l = new Uint8Array(s),
                            h = {},
                            p = null,
                            d = null,
                            f = null,
                            m = null,
                            v = null,
                            x = null,
                            b = null,
                            w = null,
                            M = null,
                            E = null,
                            S = !1,
                            T = null,
                            R = null,
                            L = null,
                            C = null,
                            O = null,
                            I = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                            G = !1,
                            j = 0,
                            H = e.getParameter(e.VERSION); - 1 !== H.indexOf("WebGL") ? (j = parseFloat(/^WebGL\ ([0-9])/.exec(H)[1]), G = j >= 1) : -1 !== H.indexOf("OpenGL ES") && (j = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(H)[1]), G = j >= 2);
                        var V = null,
                            W = {},
                            X = new ln,
                            q = new ln;

                        function Y(t, n, r) {
                            var i = new Uint8Array(4),
                                o = e.createTexture();
                            e.bindTexture(t, o), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                            for (var a = 0; a < r; a++) e.texImage2D(n + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, i);
                            return o
                        }
                        var Z = {};

                        function J(n, i) { u[n] = 1, 0 === c[n] && (e.enableVertexAttribArray(n), c[n] = 1), l[n] !== i && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), l[n] = i) }

                        function K(t) {!0 !== h[t] && (e.enable(t), h[t] = !0) }

                        function $(t) {!1 !== h[t] && (e.disable(t), h[t] = !1) }

                        function Q(t, r, i, o, a, s, u, c) {
                            if (t !== D) {
                                if (f || (K(e.BLEND), f = !0), t === z) a = a || r, s = s || i, u = u || o, r === v && a === w || (e.blendEquationSeparate(n.convert(r), n.convert(a)), v = r, w = a), i === x && o === b && s === M && u === E || (e.blendFuncSeparate(n.convert(i), n.convert(o), n.convert(s), n.convert(u)), x = i, b = o, M = s, E = u), m = t, S = null;
                                else if (t !== m || c !== S) {
                                    if (v === k && w === k || (e.blendEquation(e.FUNC_ADD), v = k, w = k), c) switch (t) {
                                        case U:
                                            e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case F:
                                            e.blendFunc(e.ONE, e.ONE);
                                            break;
                                        case N:
                                            e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case B:
                                            e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", t)
                                    } else switch (t) {
                                        case U:
                                            e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case F:
                                            e.blendFunc(e.SRC_ALPHA, e.ONE);
                                            break;
                                        case N:
                                            e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR);
                                            break;
                                        case B:
                                            e.blendFunc(e.ZERO, e.SRC_COLOR);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", t)
                                    }
                                    x = null, b = null, M = null, E = null, m = t, S = c
                                }
                            } else f && ($(e.BLEND), f = !1)
                        }

                        function ee(t) { T !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), T = t) }

                        function te(t) { t !== g ? (K(e.CULL_FACE), t !== R && (t === y ? e.cullFace(e.BACK) : t === _ ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : $(e.CULL_FACE), R = t }

                        function le(t, n, r) { t ? (K(e.POLYGON_OFFSET_FILL), C === n && O === r || (e.polygonOffset(n, r), C = n, O = r)) : $(e.POLYGON_OFFSET_FILL) }

                        function he(t) { void 0 === t && (t = e.TEXTURE0 + I - 1), V !== t && (e.activeTexture(t), V = t) }
                        return Z[e.TEXTURE_2D] = Y(e.TEXTURE_2D, e.TEXTURE_2D, 1), Z[e.TEXTURE_CUBE_MAP] = Y(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), K(e.DEPTH_TEST), o.setFunc(oe), ee(!1), te(y), K(e.CULL_FACE), Q(D), {
                            buffers: { color: i, depth: o, stencil: a },
                            initAttributes: function() { for (var e = 0, t = u.length; e < t; e++) u[e] = 0 },
                            enableAttribute: function(e) { J(e, 0) },
                            enableAttributeAndDivisor: J,
                            disableUnusedAttributes: function() { for (var t = 0, n = c.length; t !== n; ++t) c[t] !== u[t] && (e.disableVertexAttribArray(t), c[t] = 0) },
                            enable: K,
                            disable: $,
                            getCompressedTextureFormats: function() {
                                if (null === p && (p = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                                    for (var n = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), r = 0; r < n.length; r++) p.push(n[r]);
                                return p
                            },
                            useProgram: function(t) { return d !== t && (e.useProgram(t), d = t, !0) },
                            setBlending: Q,
                            setMaterial: function(t, n) {
                                t.side === P ? $(e.CULL_FACE) : K(e.CULL_FACE);
                                var r = t.side === A;
                                n && (r = !r), ee(r), t.blending === U && !1 === t.transparent ? Q(D) : Q(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), i.setMask(t.colorWrite), le(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                            },
                            setFlipSided: ee,
                            setCullFace: te,
                            setLineWidth: function(t) { t !== L && (G && e.lineWidth(t), L = t) },
                            setPolygonOffset: le,
                            setScissorTest: function(t) { t ? K(e.SCISSOR_TEST) : $(e.SCISSOR_TEST) },
                            activeTexture: he,
                            bindTexture: function(t, n) {
                                null === V && he();
                                var r = W[V];
                                void 0 === r && (r = { type: void 0, texture: void 0 }, W[V] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || Z[t]), r.type = t, r.texture = n)
                            },
                            compressedTexImage2D: function() { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } },
                            texImage2D: function() { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } },
                            texImage3D: function() { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } },
                            scissor: function(t) {!1 === X.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), X.copy(t)) },
                            viewport: function(t) {!1 === q.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), q.copy(t)) },
                            reset: function() {
                                for (var t = 0; t < c.length; t++) 1 === c[t] && (e.disableVertexAttribArray(t), c[t] = 0);
                                h = {}, p = null, V = null, W = {}, d = null, m = null, T = null, R = null, i.reset(), o.reset(), a.reset()
                            }
                        }
                    }(p, d, H, f)).scissor(ee.copy(ve).multiplyScalar(de)), v.viewport(Q.copy(me).multiplyScalar(de)), x = new function(e) {
                        var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
                        return {
                            memory: { geometries: 0, textures: 0 },
                            render: t,
                            programs: null,
                            autoReset: !0,
                            reset: function() { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 },
                            update: function(n, r, i) {
                                switch (i = i || 1, t.calls++, r) {
                                    case e.TRIANGLES:
                                        t.triangles += i * (n / 3);
                                        break;
                                    case e.TRIANGLE_STRIP:
                                    case e.TRIANGLE_FAN:
                                        t.triangles += i * (n - 2);
                                        break;
                                    case e.LINES:
                                        t.lines += i * (n / 2);
                                        break;
                                    case e.LINE_STRIP:
                                        t.lines += i * (n - 1);
                                        break;
                                    case e.LINE_LOOP:
                                        t.lines += i * n;
                                        break;
                                    case e.POINTS:
                                        t.points += i * n;
                                        break;
                                    default:
                                        console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                                }
                            }
                        }
                    }(p), b = new function() { var e = new WeakMap; return { get: function(t) { var n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function(t) { e.delete(t) }, update: function(t, n, r) { e.get(t)[n] = r }, dispose: function() { e = new WeakMap } } }, w = new Wi(p, d, v, b, f, H, x), M = new Rn(p), E = new function(e, t, n) {
                        var r = {},
                            i = {};

                        function o(e) {
                            var a = e.target,
                                s = r[a.id];
                            for (var u in null !== s.index && t.remove(s.index), s.attributes) t.remove(s.attributes[u]);
                            a.removeEventListener("dispose", o), delete r[a.id];
                            var c = i[s.id];
                            c && (t.remove(c), delete i[s.id]), n.memory.geometries--
                        }
                        return {
                            get: function(e, t) { var i = r[t.id]; return i || (t.addEventListener("dispose", o), t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new nr).setFromObject(e)), i = t._bufferGeometry), r[t.id] = i, n.memory.geometries++, i) },
                            update: function(n) {
                                var r = n.index,
                                    i = n.attributes;
                                for (var o in null !== r && t.update(r, e.ELEMENT_ARRAY_BUFFER), i) t.update(i[o], e.ARRAY_BUFFER);
                                var a = n.morphAttributes;
                                for (var o in a)
                                    for (var s = a[o], u = 0, c = s.length; u < c; u++) t.update(s[u], e.ARRAY_BUFFER)
                            },
                            getWireframeAttribute: function(n) {
                                var r = i[n.id];
                                if (r) return r;
                                var o, a = [],
                                    s = n.index,
                                    u = n.attributes;
                                if (null !== s)
                                    for (var c = 0, l = (o = s.array).length; c < l; c += 3) {
                                        var h = o[c + 0],
                                            p = o[c + 1],
                                            d = o[c + 2];
                                        a.push(h, p, p, d, d, h)
                                    } else
                                        for (c = 0, l = (o = u.position.array).length / 3 - 1; c < l; c += 3) h = c + 0, p = c + 1, d = c + 2, a.push(h, p, p, d, d, h);
                                return r = new(er(a) > 65535 ? Jn : Yn)(a, 1), t.update(r, e.ELEMENT_ARRAY_BUFFER), i[n.id] = r, r
                            }
                        }
                    }(p, M, x), S = new function(e, t) {
                        var n = {};
                        return {
                            update: function(r) {
                                var i = t.render.frame,
                                    o = r.geometry,
                                    a = e.get(r, o);
                                return n[a.id] !== i && (o.isGeometry && a.updateFromObject(r), e.update(a), n[a.id] = i), a
                            },
                            dispose: function() { n = {} }
                        }
                    }(E, x), I = new function(e) {
                        var t = {},
                            n = new Float32Array(8);
                        return {
                            update: function(r, i, o, a) {
                                var s = r.morphTargetInfluences,
                                    u = s.length,
                                    c = t[i.id];
                                if (void 0 === c) {
                                    c = [];
                                    for (var l = 0; l < u; l++) c[l] = [l, 0];
                                    t[i.id] = c
                                }
                                var h = o.morphTargets && i.morphAttributes.position,
                                    p = o.morphNormals && i.morphAttributes.normal;
                                for (l = 0; l < u; l++) 0 !== (d = c[l])[1] && (h && i.removeAttribute("morphTarget" + l), p && i.removeAttribute("morphNormal" + l));
                                for (l = 0; l < u; l++)(d = c[l])[0] = l, d[1] = s[l];
                                for (c.sort(Tr), l = 0; l < 8; l++) {
                                    var d;
                                    if (d = c[l]) {
                                        var f = d[0],
                                            m = d[1];
                                        if (m) { h && i.addAttribute("morphTarget" + l, h[f]), p && i.addAttribute("morphNormal" + l, p[f]), n[l] = m; continue }
                                    }
                                    n[l] = 0
                                }
                                a.getUniforms().setValue(e, "morphTargetInfluences", n)
                            }
                        }
                    }(p), R = new Ri(V, d, f), L = new Oi, C = new function() { var e = {}; return { get: function(t, n) { var r; return void 0 === e[t.id] ? (r = new Gi, e[t.id] = {}, e[t.id][n.id] = r) : void 0 === e[t.id][n.id] ? (r = new Gi, e[t.id][n.id] = r) : r = e[t.id][n.id], r }, dispose: function() { e = {} } } }, O = new function(e, t, n, r) {
                        var i, o, a = new En(0),
                            s = 0;

                        function u(e, n) { t.buffers.color.setClear(e.r, e.g, e.b, n, r) }
                        return {
                            getClearColor: function() { return a },
                            setClearColor: function(e, t) { a.set(e), u(a, s = void 0 !== t ? t : 1) },
                            getClearAlpha: function() { return s },
                            setClearAlpha: function(e) { u(a, s = e) },
                            render: function(t, r, c, l) {
                                var h = r.background;
                                null === h ? u(a, s) : h && h.isColor && (u(h, 1), l = !0), (e.autoClear || l) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), h && h.isCubeTexture ? (void 0 === o && ((o = new Sr(new ir(1, 1, 1), new br({ uniforms: wn.clone(An.cube.uniforms), vertexShader: An.cube.vertexShader, fragmentShader: An.cube.fragmentShader, side: A, depthTest: !0, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, n.update(o)), o.material.uniforms.tCube.value = h, t.push(o, o.geometry, o.material, 0, null)) : h && h.isTexture && (void 0 === i && ((i = new Sr(new ar(2, 2), new br({ uniforms: wn.clone(An.background.uniforms), vertexShader: An.background.vertexShader, fragmentShader: An.background.fragmentShader, side: T, depthTest: !0, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), n.update(i)), i.material.uniforms.t2D.value = h, t.push(i, i.geometry, i.material, 0, null))
                            }
                        }
                    }(V, v, S, s), G = new function(e, t, n, r) {
                        var i;
                        this.setMode = function(e) { i = e }, this.render = function(t, r) { e.drawArrays(i, t, r), n.update(r, i) }, this.renderInstances = function(o, a, s) {
                            var u;
                            if (r.isWebGL2) u = e;
                            else if (null === (u = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            u[r.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](i, a, s, o.maxInstancedCount), n.update(s, i, o.maxInstancedCount)
                        }
                    }(p, d, x, f), j = new function(e, t, n, r) {
                        var i, o, a;
                        this.setMode = function(e) { i = e }, this.setIndex = function(e) { o = e.type, a = e.bytesPerElement }, this.render = function(t, r) { e.drawElements(i, r, o, t * a), n.update(r, i) }, this.renderInstances = function(s, u, c) {
                            var l;
                            if (r.isWebGL2) l = e;
                            else if (null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            l[r.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](i, c, o, u * a, s.maxInstancedCount), n.update(c, i, s.maxInstancedCount)
                        }
                    }(p, d, x, f), x.programs = R.programs, V.context = p, V.capabilities = f, V.extensions = d, V.properties = b, V.renderLists = L, V.state = v, V.info = x
                }
                Te();
                var Ae = null;
                "undefined" != typeof navigator && (Ae = "xr" in navigator ? new function(e) {
                    var t = e.context,
                        n = null,
                        r = null,
                        i = null,
                        o = "stage",
                        a = null,
                        s = [],
                        u = [];

                    function c() { return null !== r && null !== i }
                    var l = new Zi;
                    l.layers.enable(1), l.viewport = new ln;
                    var h = new Zi;
                    h.layers.enable(2), h.viewport = new ln;
                    var p = new Ji([l, h]);

                    function d(e) {
                        var t = s[u.indexOf(e.inputSource)];
                        t && t.dispatchEvent({ type: e.type })
                    }

                    function f() { e.setFramebuffer(null), g.stop() }

                    function m(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld) }
                    p.layers.enable(1), p.layers.enable(2), this.enabled = !1, this.getController = function(e) { var t = s[e]; return void 0 === t && ((t = new qi).matrixAutoUpdate = !1, t.visible = !1, s[e] = t), t }, this.getDevice = function() { return n }, this.setDevice = function(e) { void 0 !== e && (n = e), e instanceof XRDevice && t.setCompatibleXRDevice(e) }, this.setFrameOfReferenceType = function(e) { o = e }, this.setSession = function(n) { null !== (r = n) && (r.addEventListener("select", d), r.addEventListener("selectstart", d), r.addEventListener("selectend", d), r.addEventListener("end", f), r.baseLayer = new XRWebGLLayer(r, t), r.requestFrameOfReference(o).then(function(t) { i = t, e.setFramebuffer(r.baseLayer.framebuffer), g.setContext(r), g.start() }), u = r.getInputSources(), r.addEventListener("inputsourceschange", function() { u = r.getInputSources(), console.log(u) })) }, this.getCamera = function(e) {
                        if (c()) {
                            var t = e.parent,
                                n = p.cameras;
                            m(p, t);
                            for (var r = 0; r < n.length; r++) m(n[r], t);
                            e.matrixWorld.copy(p.matrixWorld);
                            for (var i = e.children, o = (r = 0, i.length); r < o; r++) i[r].updateMatrixWorld(!0);
                            return p
                        }
                        return e
                    }, this.isPresenting = c;
                    var v = null,
                        g = new Pn;
                    g.setAnimationLoop(function(e, t) {
                        if (null !== (a = t.getDevicePose(i)))
                            for (var n = r.baseLayer, o = t.views, c = 0; c < o.length; c++) {
                                var l = o[c],
                                    h = n.getViewport(l),
                                    d = a.getViewMatrix(l),
                                    f = p.cameras[c];
                                f.matrix.fromArray(d).getInverse(f.matrix), f.projectionMatrix.fromArray(l.projectionMatrix), f.viewport.set(h.x, h.y, h.width, h.height), 0 === c && (p.matrix.copy(f.matrix), p.projectionMatrix.copy(f.projectionMatrix))
                            }
                        for (c = 0; c < s.length; c++) {
                            var m = s[c],
                                g = u[c];
                            if (g) { var y = t.getInputPose(g, i); if (null !== y) { "targetRay" in y ? m.matrix.elements = y.targetRay.transformMatrix : "pointerMatrix" in y && (m.matrix.elements = y.pointerMatrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.visible = !0; continue } }
                            m.visible = !1
                        }
                        v && v(e)
                    }), this.setAnimationLoop = function(e) { v = e }, this.dispose = function() {}, this.getStandingMatrix = function() { return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4 }, this.submitFrame = function() {}
                }(V) : new Ki(V)), this.vr = Ae;
                var Pe = new Vi(V, S, f.maxTextureSize);

                function Re(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), W = !0 }

                function Le() { console.log("THREE.WebGLRenderer: Context Restored."), W = !1, Te() }

                function Ce(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", Ce),
                        function(e) { Oe(e), b.remove(e) }(t)
                }

                function Oe(e) {
                    var t = b.get(e).program;
                    e.program = void 0, void 0 !== t && R.releaseProgram(t)
                }
                this.shadowMap = Pe, this.getContext = function() { return p }, this.getContextAttributes = function() { return p.getContextAttributes() }, this.forceContextLoss = function() {
                    var e = d.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    var e = d.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() { return de }, this.setPixelRatio = function(e) { void 0 !== e && (de = e, this.setSize(he, pe, !1)) }, this.getSize = function() { return { width: he, height: pe } }, this.setSize = function(e, n, r) { Ae.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (he = e, pe = n, t.width = e * de, t.height = n * de, !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n)) }, this.getDrawingBufferSize = function() { return { width: he * de, height: pe * de } }, this.setDrawingBufferSize = function(e, n, r) { he = e, pe = n, de = r, t.width = e * r, t.height = n * r, this.setViewport(0, 0, e, n) }, this.getCurrentViewport = function() { return Q }, this.setViewport = function(e, t, n, r) { me.set(e, pe - t - r, n, r), v.viewport(Q.copy(me).multiplyScalar(de)) }, this.setScissor = function(e, t, n, r) { ve.set(e, pe - t - r, n, r), v.scissor(ee.copy(ve).multiplyScalar(de)) }, this.setScissorTest = function(e) { v.setScissorTest(ge = e) }, this.getClearColor = function() { return O.getClearColor() }, this.setClearColor = function() { O.setClearColor.apply(O, arguments) }, this.getClearAlpha = function() { return O.getClearAlpha() }, this.setClearAlpha = function() { O.setClearAlpha.apply(O, arguments) }, this.clear = function(e, t, n) {
                    var r = 0;
                    (void 0 === e || e) && (r |= p.COLOR_BUFFER_BIT), (void 0 === t || t) && (r |= p.DEPTH_BUFFER_BIT), (void 0 === n || n) && (r |= p.STENCIL_BUFFER_BIT), p.clear(r)
                }, this.clearColor = function() { this.clear(!0, !1, !1) }, this.clearDepth = function() { this.clear(!1, !0, !1) }, this.clearStencil = function() { this.clear(!1, !1, !0) }, this.dispose = function() { t.removeEventListener("webglcontextlost", Re, !1), t.removeEventListener("webglcontextrestored", Le, !1), L.dispose(), C.dispose(), b.dispose(), S.dispose(), Ae.dispose(), Fe.stop() }, this.renderBufferImmediate = function(e, t) {
                    v.initAttributes();
                    var n = b.get(e);
                    e.hasPositions && !n.position && (n.position = p.createBuffer()), e.hasNormals && !n.normal && (n.normal = p.createBuffer()), e.hasUvs && !n.uv && (n.uv = p.createBuffer()), e.hasColors && !n.color && (n.color = p.createBuffer());
                    var r = t.getAttributes();
                    e.hasPositions && (p.bindBuffer(p.ARRAY_BUFFER, n.position), p.bufferData(p.ARRAY_BUFFER, e.positionArray, p.DYNAMIC_DRAW), v.enableAttribute(r.position), p.vertexAttribPointer(r.position, 3, p.FLOAT, !1, 0, 0)), e.hasNormals && (p.bindBuffer(p.ARRAY_BUFFER, n.normal), p.bufferData(p.ARRAY_BUFFER, e.normalArray, p.DYNAMIC_DRAW), v.enableAttribute(r.normal), p.vertexAttribPointer(r.normal, 3, p.FLOAT, !1, 0, 0)), e.hasUvs && (p.bindBuffer(p.ARRAY_BUFFER, n.uv), p.bufferData(p.ARRAY_BUFFER, e.uvArray, p.DYNAMIC_DRAW), v.enableAttribute(r.uv), p.vertexAttribPointer(r.uv, 2, p.FLOAT, !1, 0, 0)), e.hasColors && (p.bindBuffer(p.ARRAY_BUFFER, n.color), p.bufferData(p.ARRAY_BUFFER, e.colorArray, p.DYNAMIC_DRAW), v.enableAttribute(r.color), p.vertexAttribPointer(r.color, 3, p.FLOAT, !1, 0, 0)), v.disableUnusedAttributes(), p.drawArrays(p.TRIANGLES, 0, e.count), e.count = 0
                }, this.renderBufferDirect = function(e, t, n, r, i, o) {
                    var a = i.isMesh && i.normalMatrix.determinant() < 0;
                    v.setMaterial(r, a);
                    var s = ke(e, t, r, i),
                        u = !1;
                    J.geometry === n.id && J.program === s.id && J.wireframe === (!0 === r.wireframe) || (J.geometry = n.id, J.program = s.id, J.wireframe = !0 === r.wireframe, u = !0), i.morphTargetInfluences && (I.update(i, n, r, s), u = !0);
                    var c, l = n.index,
                        h = n.attributes.position,
                        m = 1;
                    !0 === r.wireframe && (l = E.getWireframeAttribute(n), m = 2);
                    var g = G;
                    null !== l && (c = M.get(l), (g = j).setIndex(c)), u && (! function(e, t, n) {
                        if (n && n.isInstancedBufferGeometry & !f.isWebGL2 && null === d.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        v.initAttributes();
                        var r = n.attributes,
                            i = t.getAttributes(),
                            o = e.defaultAttributeValues;
                        for (var a in i) {
                            var s = i[a];
                            if (s >= 0) {
                                var u = r[a];
                                if (void 0 !== u) {
                                    var c = u.normalized,
                                        l = u.itemSize,
                                        h = M.get(u);
                                    if (void 0 === h) continue;
                                    var m = h.buffer,
                                        g = h.type,
                                        y = h.bytesPerElement;
                                    if (u.isInterleavedBufferAttribute) {
                                        var _ = u.data,
                                            x = _.stride,
                                            b = u.offset;
                                        _ && _.isInstancedInterleavedBuffer ? (v.enableAttributeAndDivisor(s, _.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = _.meshPerAttribute * _.count)) : v.enableAttribute(s), p.bindBuffer(p.ARRAY_BUFFER, m), p.vertexAttribPointer(s, l, g, c, x * y, b * y)
                                    } else u.isInstancedBufferAttribute ? (v.enableAttributeAndDivisor(s, u.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = u.meshPerAttribute * u.count)) : v.enableAttribute(s), p.bindBuffer(p.ARRAY_BUFFER, m), p.vertexAttribPointer(s, l, g, c, 0, 0)
                                } else if (void 0 !== o) {
                                    var w = o[a];
                                    if (void 0 !== w) switch (w.length) {
                                        case 2:
                                            p.vertexAttrib2fv(s, w);
                                            break;
                                        case 3:
                                            p.vertexAttrib3fv(s, w);
                                            break;
                                        case 4:
                                            p.vertexAttrib4fv(s, w);
                                            break;
                                        default:
                                            p.vertexAttrib1fv(s, w)
                                    }
                                }
                            }
                        }
                        v.disableUnusedAttributes()
                    }(r, s, n), null !== l && p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, c.buffer));
                    var y = 1 / 0;
                    null !== l ? y = l.count : void 0 !== h && (y = h.count);
                    var _ = n.drawRange.start * m,
                        x = n.drawRange.count * m,
                        b = null !== o ? o.start * m : 0,
                        w = null !== o ? o.count * m : 1 / 0,
                        S = Math.max(_, b),
                        T = Math.min(y, _ + x, b + w) - 1,
                        A = Math.max(0, T - S + 1);
                    if (0 !== A) {
                        if (i.isMesh)
                            if (!0 === r.wireframe) v.setLineWidth(r.wireframeLinewidth * Ee()), g.setMode(p.LINES);
                            else switch (i.drawMode) {
                                    case Dt:
                                        g.setMode(p.TRIANGLES);
                                        break;
                                    case Ut:
                                        g.setMode(p.TRIANGLE_STRIP);
                                        break;
                                    case Ft:
                                        g.setMode(p.TRIANGLE_FAN)
                                } else if (i.isLine) {
                                    var P = r.linewidth;
                                    void 0 === P && (P = 1), v.setLineWidth(P * Ee()), i.isLineSegments ? g.setMode(p.LINES) : i.isLineLoop ? g.setMode(p.LINE_LOOP) : g.setMode(p.LINE_STRIP)
                                } else i.isPoints ? g.setMode(p.POINTS) : i.isSprite && g.setMode(p.TRIANGLES);
                        n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && g.renderInstances(n, S, A) : g.render(S, A)
                    }
                }, this.compile = function(e, t) {
                    (h = C.get(e, t)).init(), e.traverse(function(e) { e.isLight && (h.pushLight(e), e.castShadow && h.pushShadow(e)) }), h.setupLights(t), e.traverse(function(t) {
                        if (t.material)
                            if (Array.isArray(t.material))
                                for (var n = 0; n < t.material.length; n++) ze(t.material[n], e.fog, t);
                            else ze(t.material, e.fog, t)
                    })
                };
                var Ie = null;
                var De, Fe = new Pn;

                function Ne(e, t, n, r) {
                    for (var i = 0, o = e.length; i < o; i++) {
                        var a = e[i],
                            s = a.object,
                            u = a.geometry,
                            c = void 0 === r ? a.material : r,
                            l = a.group;
                        if (n.isArrayCamera) {
                            $ = n;
                            for (var p = n.cameras, d = 0, f = p.length; d < f; d++) {
                                var m = p[d];
                                if (s.layers.test(m.layers)) {
                                    if ("viewport" in m) v.viewport(Q.copy(m.viewport));
                                    else {
                                        var g = m.bounds,
                                            y = g.x * he,
                                            _ = g.y * pe,
                                            x = g.z * he,
                                            b = g.w * pe;
                                        v.viewport(Q.set(y, _, x, b).multiplyScalar(de))
                                    }
                                    h.setupLights(m), Be(s, t, m, u, c, l)
                                }
                            }
                        } else $ = null, Be(s, t, n, u, c, l)
                    }
                }

                function Be(e, t, n, r, i, o) {
                    if (e.onBeforeRender(V, t, n, r, i, o), h = C.get(t, $ || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                        v.setMaterial(i);
                        var a = ke(n, t.fog, i, e);
                        J.geometry = null, J.program = null, J.wireframe = !1,
                            function(e, t) { e.render(function(e) { V.renderBufferImmediate(e, t) }) }(e, a)
                    } else V.renderBufferDirect(n, t.fog, r, i, e, o);
                    e.onAfterRender(V, t, n, r, i, o), h = C.get(t, $ || n)
                }

                function ze(e, t, n) {
                    var r = b.get(e),
                        i = h.state.lights,
                        o = h.state.shadowsArray,
                        a = r.lightsHash,
                        s = i.state.hash,
                        u = R.getParameters(e, i.state, o, t, _e.numPlanes, _e.numIntersection, n),
                        c = R.getProgramCode(e, u),
                        l = r.program,
                        p = !0;
                    if (void 0 === l) e.addEventListener("dispose", Ce);
                    else if (l.code !== c) Oe(e);
                    else if (a.stateID !== s.stateID || a.directionalLength !== s.directionalLength || a.pointLength !== s.pointLength || a.spotLength !== s.spotLength || a.rectAreaLength !== s.rectAreaLength || a.hemiLength !== s.hemiLength || a.shadowsLength !== s.shadowsLength) a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, p = !1;
                    else {
                        if (void 0 !== u.shaderID) return;
                        p = !1
                    }
                    if (p) {
                        if (u.shaderID) {
                            var d = An[u.shaderID];
                            r.shader = { name: e.type, uniforms: wn.clone(d.uniforms), vertexShader: d.vertexShader, fragmentShader: d.fragmentShader }
                        } else r.shader = { name: e.type, uniforms: e.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader };
                        e.onBeforeCompile(r.shader, V), c = R.getProgramCode(e, u), l = R.acquireProgram(e, r.shader, u, c), r.program = l, e.program = l
                    }
                    var f = l.getAttributes();
                    if (e.morphTargets) { e.numSupportedMorphTargets = 0; for (var m = 0; m < V.maxMorphTargets; m++) f["morphTarget" + m] >= 0 && e.numSupportedMorphTargets++ }
                    if (e.morphNormals) { e.numSupportedMorphNormals = 0; for (m = 0; m < V.maxMorphNormals; m++) f["morphNormal" + m] >= 0 && e.numSupportedMorphNormals++ }
                    var v = r.shader.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = _e.numPlanes, r.numIntersection = _e.numIntersection, v.clippingPlanes = _e.uniform), r.fog = t, void 0 === a && (r.lightsHash = a = {}), a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, e.lights && (v.ambientLightColor.value = i.state.ambient, v.directionalLights.value = i.state.directional, v.spotLights.value = i.state.spot, v.rectAreaLights.value = i.state.rectArea, v.pointLights.value = i.state.point, v.hemisphereLights.value = i.state.hemi, v.directionalShadowMap.value = i.state.directionalShadowMap, v.directionalShadowMatrix.value = i.state.directionalShadowMatrix, v.spotShadowMap.value = i.state.spotShadowMap, v.spotShadowMatrix.value = i.state.spotShadowMatrix, v.pointShadowMap.value = i.state.pointShadowMap, v.pointShadowMatrix.value = i.state.pointShadowMatrix);
                    var g = r.program.getUniforms(),
                        y = yi.seqWithValue(g.seq, v);
                    r.uniformsList = y
                }

                function ke(e, t, n, r) {
                    le = 0;
                    var i = b.get(n),
                        o = h.state.lights,
                        a = i.lightsHash,
                        s = o.state.hash;
                    if (xe && (be || e !== K)) {
                        var u = e === K && n.id === Z;
                        _e.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, i, u)
                    }!1 === n.needsUpdate && (void 0 === i.program ? n.needsUpdate = !0 : n.fog && i.fog !== t ? n.needsUpdate = !0 : (!n.lights || a.stateID === s.stateID && a.directionalLength === s.directionalLength && a.pointLength === s.pointLength && a.spotLength === s.spotLength && a.rectAreaLength === s.rectAreaLength && a.hemiLength === s.hemiLength && a.shadowsLength === s.shadowsLength) && (void 0 === i.numClippingPlanes || i.numClippingPlanes === _e.numPlanes && i.numIntersection === _e.numIntersection) || (n.needsUpdate = !0)), n.needsUpdate && (ze(n, t, r), n.needsUpdate = !1);
                    var c, l, d = !1,
                        m = !1,
                        g = !1,
                        y = i.program,
                        _ = y.getUniforms(),
                        x = i.shader.uniforms;
                    if (v.useProgram(y.program) && (d = !0, m = !0, g = !0), n.id !== Z && (Z = n.id, m = !0), d || K !== e) {
                        if (_.setValue(p, "projectionMatrix", e.projectionMatrix), f.logarithmicDepthBuffer && _.setValue(p, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), K !== e && (K = e, m = !0, g = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var w = _.map.cameraPosition;
                            void 0 !== w && w.setValue(p, Me.setFromMatrixPosition(e.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && _.setValue(p, "viewMatrix", e.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        _.setOptional(p, r, "bindMatrix"), _.setOptional(p, r, "bindMatrixInverse");
                        var M = r.skeleton;
                        if (M) {
                            var E = M.bones;
                            if (f.floatVertexTextures) {
                                if (void 0 === M.boneTexture) {
                                    var S = Math.sqrt(4 * E.length);
                                    S = Zt.ceilPowerOfTwo(S), S = Math.max(S, 4);
                                    var T = new Float32Array(S * S * 4);
                                    T.set(M.boneMatrices);
                                    var P = new dn(T, S, S, Ze, Ge);
                                    P.needsUpdate = !0, M.boneMatrices = T, M.boneTexture = P, M.boneTextureSize = S
                                }
                                _.setValue(p, "boneTexture", M.boneTexture), _.setValue(p, "boneTextureSize", M.boneTextureSize)
                            } else _.setOptional(p, M, "boneMatrices")
                        }
                    }
                    return m && (_.setValue(p, "toneMappingExposure", V.toneMappingExposure), _.setValue(p, "toneMappingWhitePoint", V.toneMappingWhitePoint), n.lights && (l = g, (c = x).ambientLightColor.needsUpdate = l, c.directionalLights.needsUpdate = l, c.pointLights.needsUpdate = l, c.spotLights.needsUpdate = l, c.rectAreaLights.needsUpdate = l, c.hemisphereLights.needsUpdate = l), t && n.fog && function(e, t) { e.fogColor.value = t.color, t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }(x, t), n.isMeshBasicMaterial ? He(x, n) : n.isMeshLambertMaterial ? (He(x, n), function(e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(x, n)) : n.isMeshPhongMaterial ? (He(x, n), n.isMeshToonMaterial ? function(e, t) { Ve(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap) }(x, n) : Ve(x, n)) : n.isMeshStandardMaterial ? (He(x, n), n.isMeshPhysicalMaterial ? function(e, t) { We(e, t), e.reflectivity.value = t.reflectivity, e.clearCoat.value = t.clearCoat, e.clearCoatRoughness.value = t.clearCoatRoughness }(x, n) : We(x, n)) : n.isMeshMatcapMaterial ? (He(x, n), function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap);
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === A && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === A && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(x, n)) : n.isMeshDepthMaterial ? (He(x, n), function(e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(x, n)) : n.isMeshDistanceMaterial ? (He(x, n), function(e, t) {
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                        e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                    }(x, n)) : n.isMeshNormalMaterial ? (He(x, n), function(e, t) {
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === A && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === A && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                    }(x, n)) : n.isLineBasicMaterial ? (function(e, t) { e.diffuse.value = t.color, e.opacity.value = t.opacity }(x, n), n.isLineDashedMaterial && function(e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(x, n)) : n.isPointsMaterial ? function(e, t) { e.diffuse.value = t.color, e.opacity.value = t.opacity, e.size.value = t.size * de, e.scale.value = .5 * pe, e.map.value = t.map, null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix)) }(x, n) : n.isSpriteMaterial ? function(e, t) { e.diffuse.value = t.color, e.opacity.value = t.opacity, e.rotation.value = t.rotation, e.map.value = t.map, null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix)) }(x, n) : n.isShadowMaterial && (x.color.value = n.color, x.opacity.value = n.opacity), void 0 !== x.ltc_1 && (x.ltc_1.value = Tn.LTC_1), void 0 !== x.ltc_2 && (x.ltc_2.value = Tn.LTC_2), yi.upload(p, i.uniformsList, x, V)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (yi.upload(p, i.uniformsList, x, V), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && _.setValue(p, "center", r.center), _.setValue(p, "modelViewMatrix", r.modelViewMatrix), _.setValue(p, "normalMatrix", r.normalMatrix), _.setValue(p, "modelMatrix", r.matrixWorld), y
                }

                function He(e, t) {
                    var n;
                    e.opacity.value = t.opacity, t.color && (e.diffuse.value = t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap && t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = b.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap && (n = t.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }

                function Ve(e, t) { e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === A && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === A && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }

                function We(e, t) { e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === A && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === A && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity) }
                Fe.setAnimationLoop(function(e) { Ae.isPresenting() || Ie && Ie(e) }), "undefined" != typeof window && Fe.setContext(window), this.setAnimationLoop = function(e) { Ie = e, Ae.setAnimationLoop(e), Fe.start() }, this.render = function(e, t, n, r) {
                    if (t && t.isCamera) {
                        if (!W) {
                            J.geometry = null, J.program = null, J.wireframe = !1, Z = -1, K = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), Ae.enabled && (t = Ae.getCamera(t)), (h = C.get(e, t)).init(), e.onBeforeRender(V, e, t, n), we.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ye.setFromMatrix(we), be = this.localClippingEnabled, xe = _e.init(this.clippingPlanes, be, t), (l = L.get(e, t)).init(),
                                function e(t, n, r) {
                                    if (!1 === t.visible) return;
                                    var i = t.layers.test(n.layers);
                                    if (i)
                                        if (t.isLight) h.pushLight(t), t.castShadow && h.pushShadow(t);
                                        else if (t.isSprite) {
                                        if (!t.frustumCulled || ye.intersectsSprite(t)) {
                                            r && Me.setFromMatrixPosition(t.matrixWorld).applyMatrix4(we);
                                            var o = S.update(t),
                                                a = t.material;
                                            l.push(t, o, a, Me.z, null)
                                        }
                                    } else if (t.isImmediateRenderObject) r && Me.setFromMatrixPosition(t.matrixWorld).applyMatrix4(we), l.push(t, null, t.material, Me.z, null);
                                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || ye.intersectsObject(t))) {
                                        r && Me.setFromMatrixPosition(t.matrixWorld).applyMatrix4(we);
                                        var o = S.update(t),
                                            a = t.material;
                                        if (Array.isArray(a))
                                            for (var s = o.groups, u = 0, c = s.length; u < c; u++) {
                                                var p = s[u],
                                                    d = a[p.materialIndex];
                                                d && d.visible && l.push(t, o, d, Me.z, p)
                                            } else a.visible && l.push(t, o, a, Me.z, null)
                                    }
                                    var f = t.children;
                                    for (var u = 0, c = f.length; u < c; u++) e(f[u], n, r)
                                }(e, t, V.sortObjects), !0 === V.sortObjects && l.sort(), xe && _e.beginShadows();
                            var i = h.state.shadowsArray;
                            Pe.render(i, e, t), h.setupLights(t), xe && _e.endShadows(), this.info.autoReset && this.info.reset(), void 0 === n && (n = null), this.setRenderTarget(n), O.render(l, e, t, r);
                            var o = l.opaque,
                                a = l.transparent;
                            if (e.overrideMaterial) {
                                var s = e.overrideMaterial;
                                o.length && Ne(o, e, t, s), a.length && Ne(a, e, t, s)
                            } else o.length && Ne(o, e, t), a.length && Ne(a, e, t);
                            n && w.updateRenderTargetMipmap(n), v.buffers.depth.setTest(!0), v.buffers.depth.setMask(!0), v.buffers.color.setMask(!0), v.setPolygonOffset(!1), e.onAfterRender(V, e, t), Ae.enabled && Ae.submitFrame(), l = null, h = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.allocTextureUnit = function() { var e = le; return e >= f.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + f.maxTextures), le += 1, e }, this.setTexture2D = (De = !1, function(e, t) { e && e.isWebGLRenderTarget && (De || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), De = !0), e = e.texture), w.setTexture2D(e, t) }), this.setTexture3D = function(e, t) { w.setTexture3D(e, t) }, this.setTexture = function() { var e = !1; return function(t, n) { e || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), e = !0), w.setTexture2D(t, n) } }(), this.setTextureCube = function() { var e = !1; return function(t, n) { t && t.isWebGLRenderTargetCube && (e || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? w.setTextureCube(t, n) : w.setTextureCubeDynamic(t, n) } }(), this.setFramebuffer = function(e) { X = e }, this.getRenderTarget = function() { return q }, this.setRenderTarget = function(e) {
                    q = e, e && void 0 === b.get(e).__webglFramebuffer && w.setupRenderTarget(e);
                    var t = X,
                        n = !1;
                    if (e) {
                        var r = b.get(e).__webglFramebuffer;
                        e.isWebGLRenderTargetCube ? (t = r[e.activeCubeFace], n = !0) : t = r, Q.copy(e.viewport), ee.copy(e.scissor), te = e.scissorTest
                    } else Q.copy(me).multiplyScalar(de), ee.copy(ve).multiplyScalar(de), te = ge;
                    if (Y !== t && (p.bindFramebuffer(p.FRAMEBUFFER, t), Y = t), v.viewport(Q), v.scissor(ee), v.setScissorTest(te), n) {
                        var i = b.get(e.texture);
                        p.framebufferTexture2D(p.FRAMEBUFFER, p.COLOR_ATTACHMENT0, p.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, i.__webglTexture, e.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function(e, t, n, r, i, o) {
                    if (e && e.isWebGLRenderTarget) {
                        var a = b.get(e).__webglFramebuffer;
                        if (a) {
                            var s = !1;
                            a !== Y && (p.bindFramebuffer(p.FRAMEBUFFER, a), s = !0);
                            try {
                                var u = e.texture,
                                    c = u.format,
                                    l = u.type;
                                if (c !== Ze && H.convert(c) !== p.getParameter(p.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(l === Ue || H.convert(l) === p.getParameter(p.IMPLEMENTATION_COLOR_READ_TYPE) || l === Ge && (f.isWebGL2 || d.get("OES_texture_float") || d.get("WEBGL_color_buffer_float")) || l === je && (f.isWebGL2 ? d.get("EXT_color_buffer_float") : d.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                p.checkFramebufferStatus(p.FRAMEBUFFER) === p.FRAMEBUFFER_COMPLETE ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && p.readPixels(t, n, r, i, H.convert(c), H.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally { s && p.bindFramebuffer(p.FRAMEBUFFER, Y) }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(e, t, n) {
                    var r = t.image.width,
                        i = t.image.height,
                        o = H.convert(t.format);
                    this.setTexture2D(t, 0), p.copyTexImage2D(p.TEXTURE_2D, n || 0, o, e.x, e.y, r, i, 0)
                }, this.copyTextureToTexture = function(e, t, n, r) {
                    var i = t.image.width,
                        o = t.image.height,
                        a = H.convert(n.format),
                        s = H.convert(n.type);
                    this.setTexture2D(n, 0), t.isDataTexture ? p.texSubImage2D(p.TEXTURE_2D, r || 0, e.x, e.y, i, o, a, s, t.image.data) : p.texSubImage2D(p.TEXTURE_2D, r || 0, e.x, e.y, a, s, t.image)
                }
            }

            function Qi(e, t) { this.name = "", this.color = new En(e), this.density = void 0 !== t ? t : 25e-5 }

            function eo(e, t, n) { this.name = "", this.color = new En(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3 }

            function to() { Bn.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0 }

            function no(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 }

            function ro(e, t, n, r) { this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r }

            function io(e) { xr.call(this), this.type = "SpriteMaterial", this.color = new En(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e) }

            function oo(e) {
                if (Bn.call(this), this.type = "Sprite", void 0 === Ii) {
                    Ii = new nr;
                    var t = new no(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    Ii.setIndex([0, 1, 2, 0, 2, 3]), Ii.addAttribute("position", new ro(t, 3, 0, !1)), Ii.addAttribute("uv", new ro(t, 2, 3, !1))
                }
                this.geometry = Ii, this.material = void 0 !== e ? e : new io, this.center = new Jt(.5, .5)
            }

            function ao() { Bn.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) }

            function so(e, t) {
                if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new Kt) }
            }

            function uo() { Bn.call(this), this.type = "Bone" }

            function co(e, t) {
                Sr.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Kt, this.bindMatrixInverse = new Kt;
                var n = new so(this.initBones());
                this.bind(n, this.matrixWorld), this.normalizeSkinWeights()
            }

            function lo(e) { xr.call(this), this.type = "LineBasicMaterial", this.color = new En(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e) }

            function ho(e, t, n) { 1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Bn.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new nr, this.material = void 0 !== t ? t : new lo({ color: 16777215 * Math.random() }) }

            function po(e, t) { ho.call(this, e, t), this.type = "LineSegments" }

            function fo(e, t) { ho.call(this, e, t), this.type = "LineLoop" }

            function mo(e) { xr.call(this), this.type = "PointsMaterial", this.color = new En(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e) }

            function vo(e, t) { Bn.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new nr, this.material = void 0 !== t ? t : new mo({ color: 16777215 * Math.random() }) }

            function go(e, t, n, r, i, o, a, s, u) { cn.call(this, e, t, n, r, i, o, a, s, u), this.generateMipmaps = !1 }

            function yo(e, t, n, r, i, o, a, s, u, c, l, h) { cn.call(this, null, o, a, s, u, c, r, i, l, h), this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 }

            function _o(e, t, n, r, i, o, a, s, u) { cn.call(this, e, t, n, r, i, o, a, s, u), this.needsUpdate = !0 }

            function xo(e, t, n, r, i, o, a, s, u, c) {
                if ((c = void 0 !== c ? c : Qe) !== Qe && c !== et) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === Qe && (n = Be), void 0 === n && c === et && (n = Xe), cn.call(this, null, r, i, o, a, s, c, n, u), this.image = { width: e, height: t }, this.magFilter = void 0 !== a ? a : Re, this.minFilter = void 0 !== s ? s : Re, this.flipY = !1, this.generateMipmaps = !1
            }

            function bo(e) {
                nr.call(this), this.type = "WireframeGeometry";
                var t, n, r, i, o, a, s, u, c, l, h = [],
                    p = [0, 0],
                    d = {},
                    f = ["a", "b", "c"];
                if (e && e.isGeometry) { var m = e.faces; for (t = 0, r = m.length; t < r; t++) { var v = m[t]; for (n = 0; n < 3; n++) s = v[f[n]], u = v[f[(n + 1) % 3]], p[0] = Math.min(s, u), p[1] = Math.max(s, u), void 0 === d[c = p[0] + "," + p[1]] && (d[c] = { index1: p[0], index2: p[1] }) } for (c in d) a = d[c], l = e.vertices[a.index1], h.push(l.x, l.y, l.z), l = e.vertices[a.index2], h.push(l.x, l.y, l.z) } else if (e && e.isBufferGeometry) {
                    var g, y, _, x, b, w, M;
                    if (l = new Qt, null !== e.index) {
                        for (g = e.attributes.position, y = e.index, 0 === (_ = e.groups).length && (_ = [{ start: 0, count: y.count, materialIndex: 0 }]), i = 0, o = _.length; i < o; ++i)
                            for (t = b = (x = _[i]).start, r = b + x.count; t < r; t += 3)
                                for (n = 0; n < 3; n++) s = y.getX(t + n), u = y.getX(t + (n + 1) % 3), p[0] = Math.min(s, u), p[1] = Math.max(s, u), void 0 === d[c = p[0] + "," + p[1]] && (d[c] = { index1: p[0], index2: p[1] });
                        for (c in d) a = d[c], l.fromBufferAttribute(g, a.index1), h.push(l.x, l.y, l.z), l.fromBufferAttribute(g, a.index2), h.push(l.x, l.y, l.z)
                    } else
                        for (t = 0, r = (g = e.attributes.position).count / 3; t < r; t++)
                            for (n = 0; n < 3; n++) w = 3 * t + n, l.fromBufferAttribute(g, w), h.push(l.x, l.y, l.z), M = 3 * t + (n + 1) % 3, l.fromBufferAttribute(g, M), h.push(l.x, l.y, l.z)
                }
                this.addAttribute("position", new Kn(h, 3))
            }

            function wo(e, t, n) { jn.call(this), this.type = "ParametricGeometry", this.parameters = { func: e, slices: t, stacks: n }, this.fromBufferGeometry(new Mo(e, t, n)), this.mergeVertices() }

            function Mo(e, t, n) {
                nr.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: e, slices: t, stacks: n };
                var r, i, o = [],
                    a = [],
                    s = [],
                    u = [],
                    c = new Qt,
                    l = new Qt,
                    h = new Qt,
                    p = new Qt,
                    d = new Qt;
                e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var f = t + 1;
                for (r = 0; r <= n; r++) {
                    var m = r / n;
                    for (i = 0; i <= t; i++) {
                        var v = i / t;
                        e(v, m, l), a.push(l.x, l.y, l.z), v - 1e-5 >= 0 ? (e(v - 1e-5, m, h), p.subVectors(l, h)) : (e(v + 1e-5, m, h), p.subVectors(h, l)), m - 1e-5 >= 0 ? (e(v, m - 1e-5, h), d.subVectors(l, h)) : (e(v, m + 1e-5, h), d.subVectors(h, l)), c.crossVectors(p, d).normalize(), s.push(c.x, c.y, c.z), u.push(v, m)
                    }
                }
                for (r = 0; r < n; r++)
                    for (i = 0; i < t; i++) {
                        var g = r * f + i,
                            y = r * f + i + 1,
                            _ = (r + 1) * f + i + 1,
                            x = (r + 1) * f + i;
                        o.push(g, y, x), o.push(y, _, x)
                    }
                this.setIndex(o), this.addAttribute("position", new Kn(a, 3)), this.addAttribute("normal", new Kn(s, 3)), this.addAttribute("uv", new Kn(u, 2))
            }

            function Eo(e, t, n, r) { jn.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: r }, this.fromBufferGeometry(new So(e, t, n, r)), this.mergeVertices() }

            function So(e, t, n, r) {
                nr.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: r }, n = n || 1;
                var i = [],
                    o = [];

                function a(e, t, n, r) {
                    var i, o, a = Math.pow(2, r),
                        u = [];
                    for (i = 0; i <= a; i++) {
                        u[i] = [];
                        var c = e.clone().lerp(n, i / a),
                            l = t.clone().lerp(n, i / a),
                            h = a - i;
                        for (o = 0; o <= h; o++) u[i][o] = 0 === o && i === a ? c : c.clone().lerp(l, o / h)
                    }
                    for (i = 0; i < a; i++)
                        for (o = 0; o < 2 * (a - i) - 1; o++) {
                            var p = Math.floor(o / 2);
                            o % 2 == 0 ? (s(u[i][p + 1]), s(u[i + 1][p]), s(u[i][p])) : (s(u[i][p + 1]), s(u[i + 1][p + 1]), s(u[i + 1][p]))
                        }
                }

                function s(e) { i.push(e.x, e.y, e.z) }

                function u(t, n) {
                    var r = 3 * t;
                    n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
                }

                function c(e, t, n, r) { r < 0 && 1 === e.x && (o[t] = e.x - 1), 0 === n.x && 0 === n.z && (o[t] = r / 2 / Math.PI + .5) }

                function l(e) { return Math.atan2(e.z, -e.x) }! function(e) { for (var n = new Qt, r = new Qt, i = new Qt, o = 0; o < t.length; o += 3) u(t[o + 0], n), u(t[o + 1], r), u(t[o + 2], i), a(n, r, i, e) }(r = r || 0),
                function(e) { for (var t = new Qt, n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z }(n),
                function() {
                    for (var e = new Qt, t = 0; t < i.length; t += 3) {
                        e.x = i[t + 0], e.y = i[t + 1], e.z = i[t + 2];
                        var n = l(e) / 2 / Math.PI + .5,
                            r = (a = e, Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5);
                        o.push(n, 1 - r)
                    }
                    var a;
                    (function() {
                        for (var e = new Qt, t = new Qt, n = new Qt, r = new Qt, a = new Jt, s = new Jt, u = new Jt, h = 0, p = 0; h < i.length; h += 9, p += 6) {
                            e.set(i[h + 0], i[h + 1], i[h + 2]), t.set(i[h + 3], i[h + 4], i[h + 5]), n.set(i[h + 6], i[h + 7], i[h + 8]), a.set(o[p + 0], o[p + 1]), s.set(o[p + 2], o[p + 3]), u.set(o[p + 4], o[p + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                            var d = l(r);
                            c(a, p + 0, e, d), c(s, p + 2, t, d), c(u, p + 4, n, d)
                        }
                    })(),
                    function() {
                        for (var e = 0; e < o.length; e += 6) {
                            var t = o[e + 0],
                                n = o[e + 2],
                                r = o[e + 4],
                                i = Math.max(t, n, r),
                                a = Math.min(t, n, r);
                            i > .9 && a < .1 && (t < .2 && (o[e + 0] += 1), n < .2 && (o[e + 2] += 1), r < .2 && (o[e + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new Kn(i, 3)), this.addAttribute("normal", new Kn(i.slice(), 3)), this.addAttribute("uv", new Kn(o, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function To(e, t) { jn.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Ao(e, t)), this.mergeVertices() }

            function Ao(e, t) { So.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function Po(e, t) { jn.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Ro(e, t)), this.mergeVertices() }

            function Ro(e, t) { So.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function Lo(e, t) { jn.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Co(e, t)), this.mergeVertices() }

            function Co(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                So.call(this, r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: e, detail: t }
            }

            function Oo(e, t) { jn.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Io(e, t)), this.mergeVertices() }

            function Io(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n,
                    i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
                So.call(this, i, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: e, detail: t }
            }

            function Do(e, t, n, r, i, o) {
                jn.call(this), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: i }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Uo(e, t, n, r, i);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Uo(e, t, n, r, i) {
                nr.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: i }, t = t || 64, n = n || 1, r = r || 8, i = i || !1;
                var o = e.computeFrenetFrames(t, i);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                var a, s, u = new Qt,
                    c = new Qt,
                    l = new Jt,
                    h = new Qt,
                    p = [],
                    d = [],
                    f = [],
                    m = [];

                function v(i) {
                    h = e.getPointAt(i / t, h);
                    var a = o.normals[i],
                        l = o.binormals[i];
                    for (s = 0; s <= r; s++) {
                        var f = s / r * Math.PI * 2,
                            m = Math.sin(f),
                            v = -Math.cos(f);
                        c.x = v * a.x + m * l.x, c.y = v * a.y + m * l.y, c.z = v * a.z + m * l.z, c.normalize(), d.push(c.x, c.y, c.z), u.x = h.x + n * c.x, u.y = h.y + n * c.y, u.z = h.z + n * c.z, p.push(u.x, u.y, u.z)
                    }
                }! function() {
                    for (a = 0; a < t; a++) v(a);
                    v(!1 === i ? t : 0),
                        function() {
                            for (a = 0; a <= t; a++)
                                for (s = 0; s <= r; s++) l.x = a / t, l.y = s / r, f.push(l.x, l.y)
                        }(),
                        function() {
                            for (s = 1; s <= t; s++)
                                for (a = 1; a <= r; a++) {
                                    var e = (r + 1) * (s - 1) + (a - 1),
                                        n = (r + 1) * s + (a - 1),
                                        i = (r + 1) * s + a,
                                        o = (r + 1) * (s - 1) + a;
                                    m.push(e, n, o), m.push(n, i, o)
                                }
                        }()
                }(), this.setIndex(m), this.addAttribute("position", new Kn(p, 3)), this.addAttribute("normal", new Kn(d, 3)), this.addAttribute("uv", new Kn(f, 2))
            }

            function Fo(e, t, n, r, i, o, a) { jn.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: i, q: o }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new No(e, t, n, r, i, o)), this.mergeVertices() }

            function No(e, t, n, r, i, o) {
                nr.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: i, q: o }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
                var a, s, u = [],
                    c = [],
                    l = [],
                    h = [],
                    p = new Qt,
                    d = new Qt,
                    f = new Qt,
                    m = new Qt,
                    v = new Qt,
                    g = new Qt,
                    y = new Qt;
                for (a = 0; a <= n; ++a) {
                    var _ = a / n * i * Math.PI * 2;
                    for (A(_, i, o, e, f), A(_ + .01, i, o, e, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= r; ++s) {
                        var x = s / r * Math.PI * 2,
                            b = -t * Math.cos(x),
                            w = t * Math.sin(x);
                        p.x = f.x + (b * y.x + w * v.x), p.y = f.y + (b * y.y + w * v.y), p.z = f.z + (b * y.z + w * v.z), c.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), l.push(d.x, d.y, d.z), h.push(a / n), h.push(s / r)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (a = 1; a <= r; a++) {
                        var M = (r + 1) * (s - 1) + (a - 1),
                            E = (r + 1) * s + (a - 1),
                            S = (r + 1) * s + a,
                            T = (r + 1) * (s - 1) + a;
                        u.push(M, E, T), u.push(E, S, T)
                    }

                function A(e, t, n, r, i) {
                    var o = Math.cos(e),
                        a = Math.sin(e),
                        s = n / t * e,
                        u = Math.cos(s);
                    i.x = r * (2 + u) * .5 * o, i.y = r * (2 + u) * a * .5, i.z = r * Math.sin(s) * .5
                }
                this.setIndex(u), this.addAttribute("position", new Kn(c, 3)), this.addAttribute("normal", new Kn(l, 3)), this.addAttribute("uv", new Kn(h, 2))
            }

            function Bo(e, t, n, r, i) { jn.call(this), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: i }, this.fromBufferGeometry(new zo(e, t, n, r, i)), this.mergeVertices() }

            function zo(e, t, n, r, i) {
                nr.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: i }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
                var o, a, s = [],
                    u = [],
                    c = [],
                    l = [],
                    h = new Qt,
                    p = new Qt,
                    d = new Qt;
                for (o = 0; o <= n; o++)
                    for (a = 0; a <= r; a++) {
                        var f = a / r * i,
                            m = o / n * Math.PI * 2;
                        p.x = (e + t * Math.cos(m)) * Math.cos(f), p.y = (e + t * Math.cos(m)) * Math.sin(f), p.z = t * Math.sin(m), u.push(p.x, p.y, p.z), h.x = e * Math.cos(f), h.y = e * Math.sin(f), d.subVectors(p, h).normalize(), c.push(d.x, d.y, d.z), l.push(a / r), l.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (a = 1; a <= r; a++) {
                        var v = (r + 1) * o + a - 1,
                            g = (r + 1) * (o - 1) + a - 1,
                            y = (r + 1) * (o - 1) + a,
                            _ = (r + 1) * o + a;
                        s.push(v, g, _), s.push(g, y, _)
                    }
                this.setIndex(s), this.addAttribute("position", new Kn(u, 3)), this.addAttribute("normal", new Kn(c, 3)), this.addAttribute("uv", new Kn(l, 2))
            }
            ji.prototype = Object.create(xr.prototype), ji.prototype.constructor = ji, ji.prototype.isMeshDepthMaterial = !0, ji.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this }, Hi.prototype = Object.create(xr.prototype), Hi.prototype.constructor = Hi, Hi.prototype.isMeshDistanceMaterial = !0, Hi.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this }, qi.prototype = Object.assign(Object.create(Bn.prototype), { constructor: qi, isGroup: !0 }), Yi.prototype = Object.assign(Object.create(Bn.prototype), { constructor: Yi, isCamera: !0, copy: function(e, t) { return Bn.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this }, getWorldDirection: function(e) { void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Qt), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() }, updateMatrixWorld: function(e) { Bn.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function() { return (new this.constructor).copy(this) } }), Zi.prototype = Object.assign(Object.create(Yi.prototype), {
                constructor: Zi,
                isPerspectiveCamera: !0,
                copy: function(e, t) { return Yi.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this },
                setFocalLength: function(e) {
                    var t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Zt.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
                },
                getFocalLength: function() { var e = Math.tan(.5 * Zt.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / e },
                getEffectiveFOV: function() { return 2 * Zt.RAD2DEG * Math.atan(Math.tan(.5 * Zt.DEG2RAD * this.fov) / this.zoom) },
                getFilmWidth: function() { return this.filmGauge * Math.min(this.aspect, 1) },
                getFilmHeight: function() { return this.filmGauge / Math.max(this.aspect, 1) },
                setViewOffset: function(e, t, n, r, i, o) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() },
                clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() },
                updateProjectionMatrix: function() {
                    var e = this.near,
                        t = e * Math.tan(.5 * Zt.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * t,
                        r = this.aspect * n,
                        i = -.5 * r,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        i += o.offsetX * r / a, t -= o.offsetY * n / s, r *= o.width / a, n *= o.height / s
                    }
                    var u = this.filmOffset;
                    0 !== u && (i += e * u / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(e) { var t = Bn.prototype.toJSON.call(this, e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t }
            }), Ji.prototype = Object.assign(Object.create(Zi.prototype), { constructor: Ji, isArrayCamera: !0 }), Qi.prototype.isFogExp2 = !0, Qi.prototype.clone = function() { return new Qi(this.color, this.density) }, Qi.prototype.toJSON = function() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } }, eo.prototype.isFog = !0, eo.prototype.clone = function() { return new eo(this.color, this.near, this.far) }, eo.prototype.toJSON = function() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } }, to.prototype = Object.assign(Object.create(Bn.prototype), { constructor: to, copy: function(e, t) { return Bn.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this }, toJSON: function(e) { var t = Bn.prototype.toJSON.call(this, e); return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t } }), Object.defineProperty(no.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(no.prototype, { isInterleavedBuffer: !0, onUploadCallback: function() {}, setArray: function(e) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this }, setDynamic: function(e) { return this.dynamic = e, this }, copy: function(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this }, copyAt: function(e, t, n) { e *= this.stride, n *= t.stride; for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r]; return this }, set: function(e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, clone: function() { return (new this.constructor).copy(this) }, onUpload: function(e) { return this.onUploadCallback = e, this } }), Object.defineProperties(ro.prototype, { count: { get: function() { return this.data.count } }, array: { get: function() { return this.data.array } } }), Object.assign(ro.prototype, { isInterleavedBufferAttribute: !0, setX: function(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this }, setY: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this }, setZ: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this }, setW: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this }, getX: function(e) { return this.data.array[e * this.data.stride + this.offset] }, getY: function(e) { return this.data.array[e * this.data.stride + this.offset + 1] }, getZ: function(e) { return this.data.array[e * this.data.stride + this.offset + 2] }, getW: function(e) { return this.data.array[e * this.data.stride + this.offset + 3] }, setXY: function(e, t, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this }, setXYZ: function(e, t, n, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this }, setXYZW: function(e, t, n, r, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this } }), io.prototype = Object.create(xr.prototype), io.prototype.constructor = io, io.prototype.isSpriteMaterial = !0, io.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this }, oo.prototype = Object.assign(Object.create(Bn.prototype), {
                constructor: oo,
                isSprite: !0,
                raycast: function() {
                    var e = new Qt,
                        t = new Qt,
                        n = new Qt,
                        r = new Jt,
                        i = new Jt,
                        o = new Kt,
                        a = new Qt,
                        s = new Qt,
                        u = new Qt,
                        c = new Jt,
                        l = new Jt,
                        h = new Jt;

                    function p(e, t, n, a, s, u) { r.subVectors(e, n).addScalar(.5).multiply(a), void 0 !== s ? (i.x = u * r.x - s * r.y, i.y = s * r.x + u * r.y) : i.copy(r), e.copy(t), e.x += i.x, e.y += i.y, e.applyMatrix4(o) }
                    return function(r, i) {
                        t.setFromMatrixScale(this.matrixWorld), o.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
                        var d, f, m = this.material.rotation;
                        0 !== m && (f = Math.cos(m), d = Math.sin(m));
                        var v = this.center;
                        p(a.set(-.5, -.5, 0), n, v, t, d, f), p(s.set(.5, -.5, 0), n, v, t, d, f), p(u.set(.5, .5, 0), n, v, t, d, f), c.set(0, 0), l.set(1, 0), h.set(1, 1);
                        var g = r.ray.intersectTriangle(a, s, u, !1, e);
                        if (null !== g || (p(s.set(-.5, .5, 0), n, v, t, d, f), l.set(0, 1), null !== (g = r.ray.intersectTriangle(a, u, s, !1, e)))) {
                            var y = r.ray.origin.distanceTo(e);
                            y < r.near || y > r.far || i.push({ distance: y, point: e.clone(), uv: Mr.getUV(e, a, s, u, c, l, h, new Jt), face: null, object: this })
                        }
                    }
                }(),
                clone: function() { return new this.constructor(this.material).copy(this) },
                copy: function(e) { return Bn.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this }
            }), ao.prototype = Object.assign(Object.create(Bn.prototype), {
                constructor: ao,
                copy: function(e) {
                    Bn.prototype.copy.call(this, e, !1);
                    for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        this.addLevel(i.object.clone(), i.distance)
                    }
                    return this
                },
                addLevel: function(e, t) {
                    void 0 === t && (t = 0), t = Math.abs(t);
                    for (var n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
                    n.splice(r, 0, { distance: t, object: e }), this.add(e)
                },
                getObjectForDistance: function(e) { for (var t = this.levels, n = 1, r = t.length; n < r && !(e < t[n].distance); n++); return t[n - 1].object },
                raycast: (Di = new Qt, function(e, t) {
                    Di.setFromMatrixPosition(this.matrixWorld);
                    var n = e.ray.origin.distanceTo(Di);
                    this.getObjectForDistance(n).raycast(e, t)
                }),
                update: function() {
                    var e = new Qt,
                        t = new Qt;
                    return function(n) {
                        var r = this.levels;
                        if (r.length > 1) {
                            e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
                            var i = e.distanceTo(t);
                            r[0].object.visible = !0;
                            for (var o = 1, a = r.length; o < a && i >= r[o].distance; o++) r[o - 1].object.visible = !1, r[o].object.visible = !0;
                            for (; o < a; o++) r[o].object.visible = !1
                        }
                    }
                }(),
                toJSON: function(e) {
                    var t = Bn.prototype.toJSON.call(this, e);
                    t.object.levels = [];
                    for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                        var o = n[r];
                        t.object.levels.push({ object: o.object.uuid, distance: o.distance })
                    }
                    return t
                }
            }), Object.assign(so.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var e = 0, t = this.bones.length; e < t; e++) {
                        var n = new Kt;
                        this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function() { var e, t, n; for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]); for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) },
                update: (Ui = new Kt, Fi = new Kt, function() {
                    for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, o = e.length; i < o; i++) {
                        var a = e[i] ? e[i].matrixWorld : Fi;
                        Ui.multiplyMatrices(a, t[i]), Ui.toArray(n, 16 * i)
                    }
                    void 0 !== r && (r.needsUpdate = !0)
                }),
                clone: function() { return new so(this.bones, this.boneInverses) },
                getBoneByName: function(e) { for (var t = 0, n = this.bones.length; t < n; t++) { var r = this.bones[t]; if (r.name === e) return r } }
            }), uo.prototype = Object.assign(Object.create(Bn.prototype), { constructor: uo, isBone: !0 }), co.prototype = Object.assign(Object.create(Sr.prototype), {
                constructor: co,
                isSkinnedMesh: !0,
                initBones: function() { var e, t, n, r, i = []; if (this.geometry && void 0 !== this.geometry.bones) { for (n = 0, r = this.geometry.bones.length; n < r; n++) t = this.geometry.bones[n], e = new uo, i.push(e), e.name = t.name, e.position.fromArray(t.pos), e.quaternion.fromArray(t.rotq), void 0 !== t.scl && e.scale.fromArray(t.scl); for (n = 0, r = this.geometry.bones.length; n < r; n++) - 1 !== (t = this.geometry.bones[n]).parent && null !== t.parent && void 0 !== i[t.parent] ? i[t.parent].add(i[n]) : this.add(i[n]) } return this.updateMatrixWorld(!0), i },
                bind: function(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t) },
                pose: function() { this.skeleton.pose() },
                normalizeSkinWeights: function() {
                    var e, t;
                    if (this.geometry && this.geometry.isGeometry)
                        for (t = 0; t < this.geometry.skinWeights.length; t++) {
                            var n = this.geometry.skinWeights[t];
                            (e = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0)
                        } else if (this.geometry && this.geometry.isBufferGeometry) {
                            var r = new ln,
                                i = this.geometry.attributes.skinWeight;
                            for (t = 0; t < i.count; t++) r.x = i.getX(t), r.y = i.getY(t), r.z = i.getZ(t), r.w = i.getW(t), (e = 1 / r.manhattanLength()) !== 1 / 0 ? r.multiplyScalar(e) : r.set(1, 0, 0, 0), i.setXYZW(t, r.x, r.y, r.z, r.w)
                        }
                },
                updateMatrixWorld: function(e) { Sr.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) },
                clone: function() { return new this.constructor(this.geometry, this.material).copy(this) }
            }), lo.prototype = Object.create(xr.prototype), lo.prototype.constructor = lo, lo.prototype.isLineBasicMaterial = !0, lo.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this }, ho.prototype = Object.assign(Object.create(Bn.prototype), {
                constructor: ho,
                isLine: !0,
                computeLineDistances: (Ni = new Qt, Bi = new Qt, function() {
                    var e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) Ni.fromBufferAttribute(t, r - 1), Bi.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += Ni.distanceTo(Bi);
                            e.addAttribute("lineDistance", new Kn(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry) { var o = e.vertices; for ((n = e.lineDistances)[0] = 0, r = 1, i = o.length; r < i; r++) n[r] = n[r - 1], n[r] += o[r - 1].distanceTo(o[r]) }
                    return this
                }),
                raycast: function() {
                    var e = new Kt,
                        t = new wr,
                        n = new mn;
                    return function(r, i) {
                        var o = r.linePrecision,
                            a = this.geometry,
                            s = this.matrixWorld;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += o, !1 !== r.ray.intersectsSphere(n)) {
                            e.getInverse(s), t.copy(r.ray).applyMatrix4(e);
                            var u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                c = u * u,
                                l = new Qt,
                                h = new Qt,
                                p = new Qt,
                                d = new Qt,
                                f = this && this.isLineSegments ? 2 : 1;
                            if (a.isBufferGeometry) {
                                var m = a.index,
                                    v = a.attributes.position.array;
                                if (null !== m)
                                    for (var g = m.array, y = 0, _ = g.length - 1; y < _; y += f) {
                                        var x = g[y],
                                            b = g[y + 1];
                                        if (l.fromArray(v, 3 * x), h.fromArray(v, 3 * b), !(t.distanceSqToSegment(l, h, d, p) > c)) d.applyMatrix4(this.matrixWorld), (E = r.ray.origin.distanceTo(d)) < r.near || E > r.far || i.push({ distance: E, point: p.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this })
                                    } else
                                        for (y = 0, _ = v.length / 3 - 1; y < _; y += f) { if (l.fromArray(v, 3 * y), h.fromArray(v, 3 * y + 3), !(t.distanceSqToSegment(l, h, d, p) > c)) d.applyMatrix4(this.matrixWorld), (E = r.ray.origin.distanceTo(d)) < r.near || E > r.far || i.push({ distance: E, point: p.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this }) }
                            } else if (a.isGeometry) {
                                var w = a.vertices,
                                    M = w.length;
                                for (y = 0; y < M - 1; y += f) { var E; if (!(t.distanceSqToSegment(w[y], w[y + 1], d, p) > c)) d.applyMatrix4(this.matrixWorld), (E = r.ray.origin.distanceTo(d)) < r.near || E > r.far || i.push({ distance: E, point: p.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this }) }
                            }
                        }
                    }
                }(),
                clone: function() { return new this.constructor(this.geometry, this.material).copy(this) }
            }), po.prototype = Object.assign(Object.create(ho.prototype), {
                constructor: po,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var e = new Qt,
                        t = new Qt;
                    return function() {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var r = n.attributes.position, i = [], o = 0, a = r.count; o < a; o += 2) e.fromBufferAttribute(r, o), t.fromBufferAttribute(r, o + 1), i[o] = 0 === o ? 0 : i[o - 1], i[o + 1] = i[o] + e.distanceTo(t);
                                n.addAttribute("lineDistance", new Kn(i, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry) { var s = n.vertices; for (i = n.lineDistances, o = 0, a = s.length; o < a; o += 2) e.copy(s[o]), t.copy(s[o + 1]), i[o] = 0 === o ? 0 : i[o - 1], i[o + 1] = i[o] + e.distanceTo(t) }
                        return this
                    }
                }()
            }), fo.prototype = Object.assign(Object.create(ho.prototype), { constructor: fo, isLineLoop: !0 }), mo.prototype = Object.create(xr.prototype), mo.prototype.constructor = mo, mo.prototype.isPointsMaterial = !0, mo.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this }, vo.prototype = Object.assign(Object.create(Bn.prototype), {
                constructor: vo,
                isPoints: !0,
                raycast: function() {
                    var e = new Kt,
                        t = new wr,
                        n = new mn;
                    return function(r, i) {
                        var o = this,
                            a = this.geometry,
                            s = this.matrixWorld,
                            u = r.params.Points.threshold;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += u, !1 !== r.ray.intersectsSphere(n)) {
                            e.getInverse(s), t.copy(r.ray).applyMatrix4(e);
                            var c = u / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                l = c * c,
                                h = new Qt,
                                p = new Qt;
                            if (a.isBufferGeometry) {
                                var d = a.index,
                                    f = a.attributes.position.array;
                                if (null !== d)
                                    for (var m = d.array, v = 0, g = m.length; v < g; v++) {
                                        var y = m[v];
                                        h.fromArray(f, 3 * y), b(h, y)
                                    } else { v = 0; for (var _ = f.length / 3; v < _; v++) h.fromArray(f, 3 * v), b(h, v) }
                            } else { var x = a.vertices; for (v = 0, _ = x.length; v < _; v++) b(x[v], v) }
                        }

                        function b(e, n) {
                            var a = t.distanceSqToPoint(e);
                            if (a < l) {
                                t.closestPointToPoint(e, p), p.applyMatrix4(s);
                                var u = r.ray.origin.distanceTo(p);
                                if (u < r.near || u > r.far) return;
                                i.push({ distance: u, distanceToRay: Math.sqrt(a), point: p.clone(), index: n, face: null, object: o })
                            }
                        }
                    }
                }(),
                clone: function() { return new this.constructor(this.geometry, this.material).copy(this) }
            }), go.prototype = Object.assign(Object.create(cn.prototype), {
                constructor: go,
                isVideoTexture: !0,
                update: function() {
                    var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), yo.prototype = Object.create(cn.prototype), yo.prototype.constructor = yo, yo.prototype.isCompressedTexture = !0, _o.prototype = Object.create(cn.prototype), _o.prototype.constructor = _o, _o.prototype.isCanvasTexture = !0, xo.prototype = Object.create(cn.prototype), xo.prototype.constructor = xo, xo.prototype.isDepthTexture = !0, bo.prototype = Object.create(nr.prototype), bo.prototype.constructor = bo, wo.prototype = Object.create(jn.prototype), wo.prototype.constructor = wo, Mo.prototype = Object.create(nr.prototype), Mo.prototype.constructor = Mo, Eo.prototype = Object.create(jn.prototype), Eo.prototype.constructor = Eo, So.prototype = Object.create(nr.prototype), So.prototype.constructor = So, To.prototype = Object.create(jn.prototype), To.prototype.constructor = To, Ao.prototype = Object.create(So.prototype), Ao.prototype.constructor = Ao, Po.prototype = Object.create(jn.prototype), Po.prototype.constructor = Po, Ro.prototype = Object.create(So.prototype), Ro.prototype.constructor = Ro, Lo.prototype = Object.create(jn.prototype), Lo.prototype.constructor = Lo, Co.prototype = Object.create(So.prototype), Co.prototype.constructor = Co, Oo.prototype = Object.create(jn.prototype), Oo.prototype.constructor = Oo, Io.prototype = Object.create(So.prototype), Io.prototype.constructor = Io, Do.prototype = Object.create(jn.prototype), Do.prototype.constructor = Do, Uo.prototype = Object.create(nr.prototype), Uo.prototype.constructor = Uo, Fo.prototype = Object.create(jn.prototype), Fo.prototype.constructor = Fo, No.prototype = Object.create(nr.prototype), No.prototype.constructor = No, Bo.prototype = Object.create(jn.prototype), Bo.prototype.constructor = Bo, zo.prototype = Object.create(nr.prototype), zo.prototype.constructor = zo;
            var ko = function(e, t, n) {
                n = n || 2;
                var r, i, o, a, s, u, c, l = t && t.length,
                    h = l ? t[0] * n : e.length,
                    p = Go(e, 0, h, n, !0),
                    d = [];
                if (!p) return d;
                if (l && (p = function(e, t, n, r) { var i, o, a, s, u, c = []; for (i = 0, o = t.length; i < o; i++) a = t[i] * r, s = i < o - 1 ? t[i + 1] * r : e.length, (u = Go(e, a, s, r, !1)) === u.next && (u.steiner = !0), c.push(Ko(u)); for (c.sort(Yo), i = 0; i < c.length; i++) Zo(c[i], n), n = jo(n, n.next); return n }(e, t, p, n)), e.length > 80 * n) {
                    r = o = e[0], i = a = e[1];
                    for (var f = n; f < h; f += n) s = e[f], u = e[f + 1], s < r && (r = s), u < i && (i = u), s > o && (o = s), u > a && (a = u);
                    c = 0 !== (c = Math.max(o - r, a - i)) ? 1 / c : 0
                }
                return Ho(p, d, n, r, i, c), d
            };

            function Go(e, t, n, r, i) {
                var o, a;
                if (i === function(e, t, n, r) { for (var i = 0, o = t, a = n - r; o < n; o += r) i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o; return i }(e, t, n, r) > 0)
                    for (o = t; o < n; o += r) a = oa(o, e[o], e[o + 1], a);
                else
                    for (o = n - r; o >= t; o -= r) a = oa(o, e[o], e[o + 1], a);
                return a && ta(a, a.next) && (aa(a), a = a.next), a
            }

            function jo(e, t) {
                if (!e) return e;
                t || (t = e);
                var n, r = e;
                do {
                    if (n = !1, r.steiner || !ta(r, r.next) && 0 !== ea(r.prev, r, r.next)) r = r.next;
                    else {
                        if (aa(r), (r = t = r.prev) === r.next) break;
                        n = !0
                    }
                } while (n || r !== t);
                return t
            }

            function Ho(e, t, n, r, i, o, a) {
                if (e) {
                    !a && o && function(e, t, n, r) {
                        var i = e;
                        do { null === i.z && (i.z = Jo(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== e);
                        i.prevZ.nextZ = null, i.prevZ = null,
                            function(e) {
                                var t, n, r, i, o, a, s, u, c = 1;
                                do {
                                    for (n = e, e = null, o = null, a = 0; n;) {
                                        for (a++, r = n, s = 0, t = 0; t < c && (s++, r = r.nextZ); t++);
                                        for (u = c; s > 0 || u > 0 && r;) 0 !== s && (0 === u || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, u--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i;
                                        n = r
                                    }
                                    o.nextZ = null, c *= 2
                                } while (a > 1)
                            }(i)
                    }(e, r, i, o);
                    for (var s, u, c = e; e.prev !== e.next;)
                        if (s = e.prev, u = e.next, o ? Wo(e, r, i, o) : Vo(e)) t.push(s.i / n), t.push(e.i / n), t.push(u.i / n), aa(e), e = u.next, c = u.next;
                        else if ((e = u) === c) { a ? 1 === a ? Ho(e = Xo(e, t, n), t, n, r, i, o, 2) : 2 === a && qo(e, t, n, r, i, o) : Ho(jo(e), t, n, r, i, o, 1); break }
                }
            }

            function Vo(e) {
                var t = e.prev,
                    n = e,
                    r = e.next;
                if (ea(t, n, r) >= 0) return !1;
                for (var i = e.next.next; i !== e.prev;) {
                    if ($o(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && ea(i.prev, i, i.next) >= 0) return !1;
                    i = i.next
                }
                return !0
            }

            function Wo(e, t, n, r) {
                var i = e.prev,
                    o = e,
                    a = e.next;
                if (ea(i, o, a) >= 0) return !1;
                for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, u = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, c = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, l = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, h = Jo(s, u, t, n, r), p = Jo(c, l, t, n, r), d = e.nextZ; d && d.z <= p;) {
                    if (d !== e.prev && d !== e.next && $o(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && ea(d.prev, d, d.next) >= 0) return !1;
                    d = d.nextZ
                }
                for (d = e.prevZ; d && d.z >= h;) {
                    if (d !== e.prev && d !== e.next && $o(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && ea(d.prev, d, d.next) >= 0) return !1;
                    d = d.prevZ
                }
                return !0
            }

            function Xo(e, t, n) {
                var r = e;
                do {
                    var i = r.prev,
                        o = r.next.next;
                    !ta(i, o) && na(i, r, r.next, o) && ra(i, o) && ra(o, i) && (t.push(i.i / n), t.push(r.i / n), t.push(o.i / n), aa(r), aa(r.next), r = e = o), r = r.next
                } while (r !== e);
                return r
            }

            function qo(e, t, n, r, i, o) {
                var a = e;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && Qo(a, s)) { var u = ia(a, s); return a = jo(a, a.next), u = jo(u, u.next), Ho(a, t, n, r, i, o), void Ho(u, t, n, r, i, o) }
                        s = s.next
                    }
                    a = a.next
                } while (a !== e)
            }

            function Yo(e, t) { return e.x - t.x }

            function Zo(e, t) {
                if (t = function(e, t) {
                        var n, r = t,
                            i = e.x,
                            o = e.y,
                            a = -1 / 0;
                        do {
                            if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                                var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                if (s <= i && s > a) {
                                    if (a = s, s === i) { if (o === r.y) return r; if (o === r.next.y) return r.next }
                                    n = r.x < r.next.x ? r : r.next
                                }
                            }
                            r = r.next
                        } while (r !== t);
                        if (!n) return null;
                        if (i === a) return n.prev;
                        var u, c = n,
                            l = n.x,
                            h = n.y,
                            p = 1 / 0;
                        r = n.next;
                        for (; r !== c;) i >= r.x && r.x >= l && i !== r.x && $o(o < h ? i : a, o, l, h, o < h ? a : i, o, r.x, r.y) && ((u = Math.abs(o - r.y) / (i - r.x)) < p || u === p && r.x > n.x) && ra(r, e) && (n = r, p = u), r = r.next;
                        return n
                    }(e, t)) {
                    var n = ia(t, e);
                    jo(n, n.next)
                }
            }

            function Jo(e, t, n, r, i) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 }

            function Ko(e) {
                var t = e,
                    n = e;
                do { t.x < n.x && (n = t), t = t.next } while (t !== e);
                return n
            }

            function $o(e, t, n, r, i, o, a, s) { return (i - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (r - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0 }

            function Qo(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                    var n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && na(n, n.next, e, t)) return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }(e, t) && ra(e, t) && ra(t, e) && function(e, t) {
                    var n = e,
                        r = !1,
                        i = (e.x + t.x) / 2,
                        o = (e.y + t.y) / 2;
                    do { n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== e);
                    return r
                }(e, t)
            }

            function ea(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) }

            function ta(e, t) { return e.x === t.x && e.y === t.y }

            function na(e, t, n, r) { return !!(ta(e, t) && ta(n, r) || ta(e, r) && ta(n, t)) || ea(e, t, n) > 0 != ea(e, t, r) > 0 && ea(n, r, e) > 0 != ea(n, r, t) > 0 }

            function ra(e, t) { return ea(e.prev, e, e.next) < 0 ? ea(e, t, e.next) >= 0 && ea(e, e.prev, t) >= 0 : ea(e, t, e.prev) < 0 || ea(e, e.next, t) < 0 }

            function ia(e, t) {
                var n = new sa(e.i, e.x, e.y),
                    r = new sa(t.i, t.x, t.y),
                    i = e.next,
                    o = t.prev;
                return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
            }

            function oa(e, t, n, r) { var i = new sa(e, t, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i }

            function aa(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) }

            function sa(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }
            var ua = {
                area: function(e) { for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y; return .5 * n },
                isClockWise: function(e) { return ua.area(e) < 0 },
                triangulateShape: function(e, t) {
                    var n = [],
                        r = [],
                        i = [];
                    ca(e), la(n, e);
                    var o = e.length;
                    t.forEach(ca);
                    for (var a = 0; a < t.length; a++) r.push(o), o += t[a].length, la(n, t[a]);
                    var s = ko(n, r);
                    for (a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
                    return i
                }
            };

            function ca(e) {
                var t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function la(e, t) { for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y) }

            function ha(e, t) { jn.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, this.fromBufferGeometry(new pa(e, t)), this.mergeVertices() }

            function pa(e, t) {
                nr.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: e, options: t };
                for (var n = this, r = [], i = [], o = 0, a = (e = Array.isArray(e) ? e : [e]).length; o < a; o++) { s(e[o]) }

                function s(e) {
                    var o = [],
                        a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                        s = void 0 !== t.steps ? t.steps : 1,
                        u = void 0 !== t.depth ? t.depth : 100,
                        c = void 0 === t.bevelEnabled || t.bevelEnabled,
                        l = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                        h = void 0 !== t.bevelSize ? t.bevelSize : l - 2,
                        p = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                        d = t.extrudePath,
                        f = void 0 !== t.UVGenerator ? t.UVGenerator : da;
                    void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), u = t.amount);
                    var m, v, g, y, _, x, b, w, M = !1;
                    d && (m = d.getSpacedPoints(s), M = !0, c = !1, v = d.computeFrenetFrames(s, !1), g = new Qt, y = new Qt, _ = new Qt), c || (p = 0, l = 0, h = 0);
                    var E = e.extractPoints(a),
                        S = E.shape,
                        T = E.holes;
                    if (!ua.isClockWise(S))
                        for (S = S.reverse(), b = 0, w = T.length; b < w; b++) x = T[b], ua.isClockWise(x) && (T[b] = x.reverse());
                    var A = ua.triangulateShape(S, T),
                        P = S;
                    for (b = 0, w = T.length; b < w; b++) x = T[b], S = S.concat(x);

                    function R(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e) }
                    var L, C, O, I, D, U, F = S.length,
                        N = A.length;

                    function B(e, t, n) {
                        var r, i, o, a = e.x - t.x,
                            s = e.y - t.y,
                            u = n.x - e.x,
                            c = n.y - e.y,
                            l = a * a + s * s,
                            h = a * c - s * u;
                        if (Math.abs(h) > Number.EPSILON) {
                            var p = Math.sqrt(l),
                                d = Math.sqrt(u * u + c * c),
                                f = t.x - s / p,
                                m = t.y + a / p,
                                v = ((n.x - c / d - f) * c - (n.y + u / d - m) * u) / (a * c - s * u),
                                g = (r = f + a * v - e.x) * r + (i = m + s * v - e.y) * i;
                            if (g <= 2) return new Jt(r, i);
                            o = Math.sqrt(g / 2)
                        } else {
                            var y = !1;
                            a > Number.EPSILON ? u > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? u < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(c) && (y = !0), y ? (r = -s, i = a, o = Math.sqrt(l)) : (r = a, i = s, o = Math.sqrt(l / 2))
                        }
                        return new Jt(r / o, i / o)
                    }
                    for (var z = [], k = 0, G = P.length, j = G - 1, H = k + 1; k < G; k++, j++, H++) j === G && (j = 0), H === G && (H = 0), z[k] = B(P[k], P[j], P[H]);
                    var V, W, X = [],
                        q = z.concat();
                    for (b = 0, w = T.length; b < w; b++) {
                        for (x = T[b], V = [], k = 0, j = (G = x.length) - 1, H = k + 1; k < G; k++, j++, H++) j === G && (j = 0), H === G && (H = 0), V[k] = B(x[k], x[j], x[H]);
                        X.push(V), q = q.concat(V)
                    }
                    for (L = 0; L < p; L++) {
                        for (O = L / p, I = l * Math.cos(O * Math.PI / 2), C = h * Math.sin(O * Math.PI / 2), k = 0, G = P.length; k < G; k++) Z((D = R(P[k], z[k], C)).x, D.y, -I);
                        for (b = 0, w = T.length; b < w; b++)
                            for (x = T[b], V = X[b], k = 0, G = x.length; k < G; k++) Z((D = R(x[k], V[k], C)).x, D.y, -I)
                    }
                    for (C = h, k = 0; k < F; k++) D = c ? R(S[k], q[k], C) : S[k], M ? (y.copy(v.normals[0]).multiplyScalar(D.x), g.copy(v.binormals[0]).multiplyScalar(D.y), _.copy(m[0]).add(y).add(g), Z(_.x, _.y, _.z)) : Z(D.x, D.y, 0);
                    for (W = 1; W <= s; W++)
                        for (k = 0; k < F; k++) D = c ? R(S[k], q[k], C) : S[k], M ? (y.copy(v.normals[W]).multiplyScalar(D.x), g.copy(v.binormals[W]).multiplyScalar(D.y), _.copy(m[W]).add(y).add(g), Z(_.x, _.y, _.z)) : Z(D.x, D.y, u / s * W);
                    for (L = p - 1; L >= 0; L--) {
                        for (O = L / p, I = l * Math.cos(O * Math.PI / 2), C = h * Math.sin(O * Math.PI / 2), k = 0, G = P.length; k < G; k++) Z((D = R(P[k], z[k], C)).x, D.y, u + I);
                        for (b = 0, w = T.length; b < w; b++)
                            for (x = T[b], V = X[b], k = 0, G = x.length; k < G; k++) D = R(x[k], V[k], C), M ? Z(D.x, D.y + m[s - 1].y, m[s - 1].x + I) : Z(D.x, D.y, u + I)
                    }

                    function Y(e, t) {
                        var n, r;
                        for (k = e.length; --k >= 0;) {
                            n = k, (r = k - 1) < 0 && (r = e.length - 1);
                            var i = 0,
                                o = s + 2 * p;
                            for (i = 0; i < o; i++) {
                                var a = F * i,
                                    u = F * (i + 1);
                                K(t + n + a, t + r + a, t + r + u, t + n + u)
                            }
                        }
                    }

                    function Z(e, t, n) { o.push(e), o.push(t), o.push(n) }

                    function J(e, t, i) {
                        $(e), $(t), $(i);
                        var o = r.length / 3,
                            a = f.generateTopUV(n, r, o - 3, o - 2, o - 1);
                        Q(a[0]), Q(a[1]), Q(a[2])
                    }

                    function K(e, t, i, o) {
                        $(e), $(t), $(o), $(t), $(i), $(o);
                        var a = r.length / 3,
                            s = f.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                        Q(s[0]), Q(s[1]), Q(s[3]), Q(s[1]), Q(s[2]), Q(s[3])
                    }

                    function $(e) { r.push(o[3 * e + 0]), r.push(o[3 * e + 1]), r.push(o[3 * e + 2]) }

                    function Q(e) { i.push(e.x), i.push(e.y) }! function() {
                        var e = r.length / 3;
                        if (c) {
                            var t = 0,
                                i = F * t;
                            for (k = 0; k < N; k++) J((U = A[k])[2] + i, U[1] + i, U[0] + i);
                            for (i = F * (t = s + 2 * p), k = 0; k < N; k++) J((U = A[k])[0] + i, U[1] + i, U[2] + i)
                        } else { for (k = 0; k < N; k++) J((U = A[k])[2], U[1], U[0]); for (k = 0; k < N; k++) J((U = A[k])[0] + F * s, U[1] + F * s, U[2] + F * s) }
                        n.addGroup(e, r.length / 3 - e, 0)
                    }(),
                    function() {
                        var e = r.length / 3,
                            t = 0;
                        for (Y(P, t), t += P.length, b = 0, w = T.length; b < w; b++) Y(x = T[b], t), t += x.length;
                        n.addGroup(e, r.length / 3 - e, 1)
                    }()
                }
                this.addAttribute("position", new Kn(r, 3)), this.addAttribute("uv", new Kn(i, 2)), this.computeVertexNormals()
            }
            ha.prototype = Object.create(jn.prototype), ha.prototype.constructor = ha, ha.prototype.toJSON = function() { var e = jn.prototype.toJSON.call(this); return fa(this.parameters.shapes, this.parameters.options, e) }, pa.prototype = Object.create(nr.prototype), pa.prototype.constructor = pa, pa.prototype.toJSON = function() { var e = nr.prototype.toJSON.call(this); return fa(this.parameters.shapes, this.parameters.options, e) };
            var da = {
                generateTopUV: function(e, t, n, r, i) {
                    var o = t[3 * n],
                        a = t[3 * n + 1],
                        s = t[3 * r],
                        u = t[3 * r + 1],
                        c = t[3 * i],
                        l = t[3 * i + 1];
                    return [new Jt(o, a), new Jt(s, u), new Jt(c, l)]
                },
                generateSideWallUV: function(e, t, n, r, i, o) {
                    var a = t[3 * n],
                        s = t[3 * n + 1],
                        u = t[3 * n + 2],
                        c = t[3 * r],
                        l = t[3 * r + 1],
                        h = t[3 * r + 2],
                        p = t[3 * i],
                        d = t[3 * i + 1],
                        f = t[3 * i + 2],
                        m = t[3 * o],
                        v = t[3 * o + 1],
                        g = t[3 * o + 2];
                    return Math.abs(s - l) < .01 ? [new Jt(a, 1 - u), new Jt(c, 1 - h), new Jt(p, 1 - f), new Jt(m, 1 - g)] : [new Jt(s, 1 - u), new Jt(l, 1 - h), new Jt(d, 1 - f), new Jt(v, 1 - g)]
                }
            };

            function fa(e, t, n) {
                if (n.shapes = [], Array.isArray(e))
                    for (var r = 0, i = e.length; r < i; r++) {
                        var o = e[r];
                        n.shapes.push(o.uuid)
                    } else n.shapes.push(e.uuid);
                return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
            }

            function ma(e, t) { jn.call(this), this.type = "TextGeometry", this.parameters = { text: e, parameters: t }, this.fromBufferGeometry(new va(e, t)), this.mergeVertices() }

            function va(e, t) {
                var n = (t = t || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new jn;
                var r = n.generateShapes(e, t.size);
                t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), pa.call(this, r, t), this.type = "TextBufferGeometry"
            }

            function ga(e, t, n, r, i, o, a) { jn.call(this), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: i, thetaStart: o, thetaLength: a }, this.fromBufferGeometry(new ya(e, t, n, r, i, o, a)), this.mergeVertices() }

            function ya(e, t, n, r, i, o, a) {
                nr.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: i, thetaStart: o, thetaLength: a }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI;
                var s, u, c = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI),
                    l = 0,
                    h = [],
                    p = new Qt,
                    d = new Qt,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (u = 0; u <= n; u++) {
                    var y = [],
                        _ = u / n;
                    for (s = 0; s <= t; s++) {
                        var x = s / t;
                        p.x = -e * Math.cos(r + x * i) * Math.sin(o + _ * a), p.y = e * Math.cos(o + _ * a), p.z = e * Math.sin(r + x * i) * Math.sin(o + _ * a), m.push(p.x, p.y, p.z), d.set(p.x, p.y, p.z).normalize(), v.push(d.x, d.y, d.z), g.push(x, 1 - _), y.push(l++)
                    }
                    h.push(y)
                }
                for (u = 0; u < n; u++)
                    for (s = 0; s < t; s++) {
                        var b = h[u][s + 1],
                            w = h[u][s],
                            M = h[u + 1][s],
                            E = h[u + 1][s + 1];
                        (0 !== u || o > 0) && f.push(b, w, E), (u !== n - 1 || c < Math.PI) && f.push(w, M, E)
                    }
                this.setIndex(f), this.addAttribute("position", new Kn(m, 3)), this.addAttribute("normal", new Kn(v, 3)), this.addAttribute("uv", new Kn(g, 2))
            }

            function _a(e, t, n, r, i, o) { jn.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: o }, this.fromBufferGeometry(new xa(e, t, n, r, i, o)), this.mergeVertices() }

            function xa(e, t, n, r, i, o) {
                nr.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: o }, e = e || .5, t = t || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
                var a, s, u, c = [],
                    l = [],
                    h = [],
                    p = [],
                    d = e,
                    f = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
                    m = new Qt,
                    v = new Jt;
                for (s = 0; s <= r; s++) {
                    for (u = 0; u <= n; u++) a = i + u / n * o, m.x = d * Math.cos(a), m.y = d * Math.sin(a), l.push(m.x, m.y, m.z), h.push(0, 0, 1), v.x = (m.x / t + 1) / 2, v.y = (m.y / t + 1) / 2, p.push(v.x, v.y);
                    d += f
                }
                for (s = 0; s < r; s++) {
                    var g = s * (n + 1);
                    for (u = 0; u < n; u++) {
                        var y = a = u + g,
                            _ = a + n + 1,
                            x = a + n + 2,
                            b = a + 1;
                        c.push(y, _, b), c.push(_, x, b)
                    }
                }
                this.setIndex(c), this.addAttribute("position", new Kn(l, 3)), this.addAttribute("normal", new Kn(h, 3)), this.addAttribute("uv", new Kn(p, 2))
            }

            function ba(e, t, n, r) { jn.call(this), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, this.fromBufferGeometry(new wa(e, t, n, r)), this.mergeVertices() }

            function wa(e, t, n, r) {
                nr.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = Zt.clamp(r, 0, 2 * Math.PI);
                var i, o, a, s = [],
                    u = [],
                    c = [],
                    l = 1 / t,
                    h = new Qt,
                    p = new Jt;
                for (o = 0; o <= t; o++) {
                    var d = n + o * l * r,
                        f = Math.sin(d),
                        m = Math.cos(d);
                    for (a = 0; a <= e.length - 1; a++) h.x = e[a].x * f, h.y = e[a].y, h.z = e[a].x * m, u.push(h.x, h.y, h.z), p.x = o / t, p.y = a / (e.length - 1), c.push(p.x, p.y)
                }
                for (o = 0; o < t; o++)
                    for (a = 0; a < e.length - 1; a++) {
                        var v = i = a + o * e.length,
                            g = i + e.length,
                            y = i + e.length + 1,
                            _ = i + 1;
                        s.push(v, g, _), s.push(g, y, _)
                    }
                if (this.setIndex(s), this.addAttribute("position", new Kn(u, 3)), this.addAttribute("uv", new Kn(c, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                    var x = this.attributes.normal.array,
                        b = new Qt,
                        w = new Qt,
                        M = new Qt;
                    for (i = t * e.length * 3, o = 0, a = 0; o < e.length; o++, a += 3) b.x = x[a + 0], b.y = x[a + 1], b.z = x[a + 2], w.x = x[i + a + 0], w.y = x[i + a + 1], w.z = x[i + a + 2], M.addVectors(b, w).normalize(), x[a + 0] = x[i + a + 0] = M.x, x[a + 1] = x[i + a + 1] = M.y, x[a + 2] = x[i + a + 2] = M.z
                }
            }

            function Ma(e, t) { jn.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = { shapes: e, curveSegments: t }, this.fromBufferGeometry(new Ea(e, t)), this.mergeVertices() }

            function Ea(e, t) {
                nr.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: e, curveSegments: t }, t = t || 12;
                var n = [],
                    r = [],
                    i = [],
                    o = [],
                    a = 0,
                    s = 0;
                if (!1 === Array.isArray(e)) c(e);
                else
                    for (var u = 0; u < e.length; u++) c(e[u]), this.addGroup(a, s, u), a += s, s = 0;

                function c(e) {
                    var a, u, c, l = r.length / 3,
                        h = e.extractPoints(t),
                        p = h.shape,
                        d = h.holes;
                    if (!1 === ua.isClockWise(p))
                        for (p = p.reverse(), a = 0, u = d.length; a < u; a++) c = d[a], !0 === ua.isClockWise(c) && (d[a] = c.reverse());
                    var f = ua.triangulateShape(p, d);
                    for (a = 0, u = d.length; a < u; a++) c = d[a], p = p.concat(c);
                    for (a = 0, u = p.length; a < u; a++) {
                        var m = p[a];
                        r.push(m.x, m.y, 0), i.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (a = 0, u = f.length; a < u; a++) {
                        var v = f[a],
                            g = v[0] + l,
                            y = v[1] + l,
                            _ = v[2] + l;
                        n.push(g, y, _), s += 3
                    }
                }
                this.setIndex(n), this.addAttribute("position", new Kn(r, 3)), this.addAttribute("normal", new Kn(i, 3)), this.addAttribute("uv", new Kn(o, 2))
            }

            function Sa(e, t) {
                if (t.shapes = [], Array.isArray(e))
                    for (var n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.shapes.push(i.uuid)
                    } else t.shapes.push(e.uuid);
                return t
            }

            function Ta(e, t) {
                nr.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1;
                var n, r, i, o, a = [],
                    s = Math.cos(Zt.DEG2RAD * t),
                    u = [0, 0],
                    c = {},
                    l = ["a", "b", "c"];
                e.isBufferGeometry ? (o = new jn).fromBufferGeometry(e) : o = e.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var h = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
                    for (var m = p[d], v = 0; v < 3; v++) n = m[l[v]], r = m[l[(v + 1) % 3]], u[0] = Math.min(n, r), u[1] = Math.max(n, r), void 0 === c[i = u[0] + "," + u[1]] ? c[i] = { index1: u[0], index2: u[1], face1: d, face2: void 0 } : c[i].face2 = d;
                for (i in c) {
                    var g = c[i];
                    if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) {
                        var y = h[g.index1];
                        a.push(y.x, y.y, y.z), y = h[g.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new Kn(a, 3))
            }

            function Aa(e, t, n, r, i, o, a, s) { jn.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: i, openEnded: o, thetaStart: a, thetaLength: s }, this.fromBufferGeometry(new Pa(e, t, n, r, i, o, a, s)), this.mergeVertices() }

            function Pa(e, t, n, r, i, o, a, s) {
                nr.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: i, openEnded: o, thetaStart: a, thetaLength: s };
                var u = this;
                e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, n = n || 1, r = Math.floor(r) || 8, i = Math.floor(i) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var c = [],
                    l = [],
                    h = [],
                    p = [],
                    d = 0,
                    f = [],
                    m = n / 2,
                    v = 0;

                function g(n) {
                    var i, o, f, g = new Jt,
                        y = new Qt,
                        _ = 0,
                        x = !0 === n ? e : t,
                        b = !0 === n ? 1 : -1;
                    for (o = d, i = 1; i <= r; i++) l.push(0, m * b, 0), h.push(0, b, 0), p.push(.5, .5), d++;
                    for (f = d, i = 0; i <= r; i++) {
                        var w = i / r * s + a,
                            M = Math.cos(w),
                            E = Math.sin(w);
                        y.x = x * E, y.y = m * b, y.z = x * M, l.push(y.x, y.y, y.z), h.push(0, b, 0), g.x = .5 * M + .5, g.y = .5 * E * b + .5, p.push(g.x, g.y), d++
                    }
                    for (i = 0; i < r; i++) {
                        var S = o + i,
                            T = f + i;
                        !0 === n ? c.push(T, T + 1, S) : c.push(T + 1, T, S), _ += 3
                    }
                    u.addGroup(v, _, !0 === n ? 1 : 2), v += _
                }! function() {
                    var o, g, y = new Qt,
                        _ = new Qt,
                        x = 0,
                        b = (t - e) / n;
                    for (g = 0; g <= i; g++) {
                        var w = [],
                            M = g / i,
                            E = M * (t - e) + e;
                        for (o = 0; o <= r; o++) {
                            var S = o / r,
                                T = S * s + a,
                                A = Math.sin(T),
                                P = Math.cos(T);
                            _.x = E * A, _.y = -M * n + m, _.z = E * P, l.push(_.x, _.y, _.z), y.set(A, b, P).normalize(), h.push(y.x, y.y, y.z), p.push(S, 1 - M), w.push(d++)
                        }
                        f.push(w)
                    }
                    for (o = 0; o < r; o++)
                        for (g = 0; g < i; g++) {
                            var R = f[g][o],
                                L = f[g + 1][o],
                                C = f[g + 1][o + 1],
                                O = f[g][o + 1];
                            c.push(R, L, O), c.push(L, C, O), x += 6
                        }
                    u.addGroup(v, x, 0), v += x
                }(), !1 === o && (e > 0 && g(!0), t > 0 && g(!1)), this.setIndex(c), this.addAttribute("position", new Kn(l, 3)), this.addAttribute("normal", new Kn(h, 3)), this.addAttribute("uv", new Kn(p, 2))
            }

            function Ra(e, t, n, r, i, o, a) { Aa.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: o, thetaLength: a } }

            function La(e, t, n, r, i, o, a) { Pa.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: o, thetaLength: a } }

            function Ca(e, t, n, r) { jn.call(this), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, this.fromBufferGeometry(new Oa(e, t, n, r)), this.mergeVertices() }

            function Oa(e, t, n, r) {
                nr.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var i, o, a = [],
                    s = [],
                    u = [],
                    c = [],
                    l = new Qt,
                    h = new Jt;
                for (s.push(0, 0, 0), u.push(0, 0, 1), c.push(.5, .5), o = 0, i = 3; o <= t; o++, i += 3) {
                    var p = n + o / t * r;
                    l.x = e * Math.cos(p), l.y = e * Math.sin(p), s.push(l.x, l.y, l.z), u.push(0, 0, 1), h.x = (s[i] / e + 1) / 2, h.y = (s[i + 1] / e + 1) / 2, c.push(h.x, h.y)
                }
                for (i = 1; i <= t; i++) a.push(i, i + 1, 0);
                this.setIndex(a), this.addAttribute("position", new Kn(s, 3)), this.addAttribute("normal", new Kn(u, 3)), this.addAttribute("uv", new Kn(c, 2))
            }
            ma.prototype = Object.create(jn.prototype), ma.prototype.constructor = ma, va.prototype = Object.create(pa.prototype), va.prototype.constructor = va, ga.prototype = Object.create(jn.prototype), ga.prototype.constructor = ga, ya.prototype = Object.create(nr.prototype), ya.prototype.constructor = ya, _a.prototype = Object.create(jn.prototype), _a.prototype.constructor = _a, xa.prototype = Object.create(nr.prototype), xa.prototype.constructor = xa, ba.prototype = Object.create(jn.prototype), ba.prototype.constructor = ba, wa.prototype = Object.create(nr.prototype), wa.prototype.constructor = wa, Ma.prototype = Object.create(jn.prototype), Ma.prototype.constructor = Ma, Ma.prototype.toJSON = function() { var e = jn.prototype.toJSON.call(this); return Sa(this.parameters.shapes, e) }, Ea.prototype = Object.create(nr.prototype), Ea.prototype.constructor = Ea, Ea.prototype.toJSON = function() { var e = nr.prototype.toJSON.call(this); return Sa(this.parameters.shapes, e) }, Ta.prototype = Object.create(nr.prototype), Ta.prototype.constructor = Ta, Aa.prototype = Object.create(jn.prototype), Aa.prototype.constructor = Aa, Pa.prototype = Object.create(nr.prototype), Pa.prototype.constructor = Pa, Ra.prototype = Object.create(Aa.prototype), Ra.prototype.constructor = Ra, La.prototype = Object.create(Pa.prototype), La.prototype.constructor = La, Ca.prototype = Object.create(jn.prototype), Ca.prototype.constructor = Ca, Oa.prototype = Object.create(nr.prototype), Oa.prototype.constructor = Oa;
            var Ia = Object.freeze({ WireframeGeometry: bo, ParametricGeometry: wo, ParametricBufferGeometry: Mo, TetrahedronGeometry: To, TetrahedronBufferGeometry: Ao, OctahedronGeometry: Po, OctahedronBufferGeometry: Ro, IcosahedronGeometry: Lo, IcosahedronBufferGeometry: Co, DodecahedronGeometry: Oo, DodecahedronBufferGeometry: Io, PolyhedronGeometry: Eo, PolyhedronBufferGeometry: So, TubeGeometry: Do, TubeBufferGeometry: Uo, TorusKnotGeometry: Fo, TorusKnotBufferGeometry: No, TorusGeometry: Bo, TorusBufferGeometry: zo, TextGeometry: ma, TextBufferGeometry: va, SphereGeometry: ga, SphereBufferGeometry: ya, RingGeometry: _a, RingBufferGeometry: xa, PlaneGeometry: or, PlaneBufferGeometry: ar, LatheGeometry: ba, LatheBufferGeometry: wa, ShapeGeometry: Ma, ShapeBufferGeometry: Ea, ExtrudeGeometry: ha, ExtrudeBufferGeometry: pa, EdgesGeometry: Ta, ConeGeometry: Ra, ConeBufferGeometry: La, CylinderGeometry: Aa, CylinderBufferGeometry: Pa, CircleGeometry: Ca, CircleBufferGeometry: Oa, BoxGeometry: rr, BoxBufferGeometry: ir });

            function Da(e) { xr.call(this), this.type = "ShadowMaterial", this.color = new En(0), this.transparent = !0, this.setValues(e) }

            function Ua(e) { br.call(this, e), this.type = "RawShaderMaterial" }

            function Fa(e) { xr.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new En(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new En(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qt, this.normalScale = new Jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function Na(e) { Fa.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e) }

            function Ba(e) { xr.call(this), this.type = "MeshPhongMaterial", this.color = new En(16777215), this.specular = new En(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new En(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qt, this.normalScale = new Jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = le, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function za(e) { Ba.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e) }

            function ka(e) { xr.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qt, this.normalScale = new Jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function Ga(e) { xr.call(this), this.type = "MeshLambertMaterial", this.color = new En(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new En(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = le, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function ja(e) {
                if (xr.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new En(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qt, this.normalScale = new Jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(e), null === this.matcap) {
                    var t = document.createElement("canvas");
                    t.width = 1, t.height = 1;
                    var n = t.getContext("2d");
                    n.fillStyle = "#fff", n.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(t)
                }
            }

            function Ha(e) { lo.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) }
            Da.prototype = Object.create(xr.prototype), Da.prototype.constructor = Da, Da.prototype.isShadowMaterial = !0, Da.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.color.copy(e.color), this }, Ua.prototype = Object.create(br.prototype), Ua.prototype.constructor = Ua, Ua.prototype.isRawShaderMaterial = !0, Fa.prototype = Object.create(xr.prototype), Fa.prototype.constructor = Fa, Fa.prototype.isMeshStandardMaterial = !0, Fa.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Na.prototype = Object.create(Fa.prototype), Na.prototype.constructor = Na, Na.prototype.isMeshPhysicalMaterial = !0, Na.prototype.copy = function(e) { return Fa.prototype.copy.call(this, e), this.defines = { PHYSICAL: "" }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this }, Ba.prototype = Object.create(xr.prototype), Ba.prototype.constructor = Ba, Ba.prototype.isMeshPhongMaterial = !0, Ba.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, za.prototype = Object.create(Ba.prototype), za.prototype.constructor = za, za.prototype.isMeshToonMaterial = !0, za.prototype.copy = function(e) { return Ba.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this }, ka.prototype = Object.create(xr.prototype), ka.prototype.constructor = ka, ka.prototype.isMeshNormalMaterial = !0, ka.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Ga.prototype = Object.create(xr.prototype), Ga.prototype.constructor = Ga, Ga.prototype.isMeshLambertMaterial = !0, Ga.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, ja.prototype = Object.create(xr.prototype), ja.prototype.constructor = ja, ja.prototype.isMeshMatcapMaterial = !0, ja.prototype.copy = function(e) { return xr.prototype.copy.call(this, e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Ha.prototype = Object.create(lo.prototype), Ha.prototype.constructor = Ha, Ha.prototype.isLineDashedMaterial = !0, Ha.prototype.copy = function(e) { return lo.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this };
            var Va = Object.freeze({ ShadowMaterial: Da, SpriteMaterial: io, RawShaderMaterial: Ua, ShaderMaterial: br, PointsMaterial: mo, MeshPhysicalMaterial: Na, MeshStandardMaterial: Fa, MeshPhongMaterial: Ba, MeshToonMaterial: za, MeshNormalMaterial: ka, MeshLambertMaterial: Ga, MeshDepthMaterial: ji, MeshDistanceMaterial: Hi, MeshBasicMaterial: Er, MeshMatcapMaterial: ja, LineDashedMaterial: Ha, LineBasicMaterial: lo, Material: xr }),
                Wa = { enabled: !1, files: {}, add: function(e, t) {!1 !== this.enabled && (this.files[e] = t) }, get: function(e) { if (!1 !== this.enabled) return this.files[e] }, remove: function(e) { delete this.files[e] }, clear: function() { this.files = {} } };

            function Xa(e, t, n) {
                var r = this,
                    i = !1,
                    o = 0,
                    a = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) { a++, !1 === i && void 0 !== r.onStart && r.onStart(e, o, a), i = !0 }, this.itemEnd = function(e) { o++, void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function(e) { void 0 !== r.onError && r.onError(e) }, this.resolveURL = function(e) { return s ? s(e) : e }, this.setURLModifier = function(e) { return s = e, this }
            }
            var qa = new Xa,
                Ya = {};

            function Za(e) { this.manager = void 0 !== e ? e : qa }

            function Ja(e) { this.manager = void 0 !== e ? e : qa, this._parser = null }

            function Ka(e) { this.manager = void 0 !== e ? e : qa, this._parser = null }

            function $a(e) { this.manager = void 0 !== e ? e : qa }

            function Qa(e) { this.manager = void 0 !== e ? e : qa }

            function es(e) { this.manager = void 0 !== e ? e : qa }

            function ts() { this.type = "Curve", this.arcLengthDivisions = 200 }

            function ns(e, t, n, r, i, o, a, s) { ts.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0 }

            function rs(e, t, n, r, i, o) { ns.call(this, e, t, n, n, r, i, o), this.type = "ArcCurve" }

            function is() {
                var e = 0,
                    t = 0,
                    n = 0,
                    r = 0;

                function i(i, o, a, s) { e = i, t = a, n = -3 * i + 3 * o - 2 * a - s, r = 2 * i - 2 * o + a + s }
                return {
                    initCatmullRom: function(e, t, n, r, o) { i(t, n, o * (n - e), o * (r - t)) },
                    initNonuniformCatmullRom: function(e, t, n, r, o, a, s) {
                        var u = (t - e) / o - (n - e) / (o + a) + (n - t) / a,
                            c = (n - t) / a - (r - t) / (a + s) + (r - n) / s;
                        i(t, n, u *= a, c *= a)
                    },
                    calc: function(i) { var o = i * i; return e + t * i + n * o + r * (o * i) }
                }
            }
            Object.assign(Za.prototype, {
                load: function(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var i = this,
                        o = Wa.get(e);
                    if (void 0 !== o) return i.manager.itemStart(e), setTimeout(function() { t && t(o), i.manager.itemEnd(e) }, 0), o;
                    if (void 0 === Ya[e]) {
                        var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (a) {
                            var s = a[1],
                                u = !!a[2],
                                c = a[3];
                            c = window.decodeURIComponent(c), u && (c = window.atob(c));
                            try {
                                var l, h = (this.responseType || "").toLowerCase();
                                switch (h) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var p = new Uint8Array(c.length), d = 0; d < c.length; d++) p[d] = c.charCodeAt(d);
                                        l = "blob" === h ? new Blob([p.buffer], { type: s }) : p.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        l = f.parseFromString(c, s);
                                        break;
                                    case "json":
                                        l = JSON.parse(c);
                                        break;
                                    default:
                                        l = c
                                }
                                window.setTimeout(function() { t && t(l), i.manager.itemEnd(e) }, 0)
                            } catch (t) { window.setTimeout(function() { r && r(t), i.manager.itemEnd(e), i.manager.itemError(e) }, 0) }
                        } else {
                            Ya[e] = [], Ya[e].push({ onLoad: t, onProgress: n, onError: r });
                            var m = new XMLHttpRequest;
                            for (var v in m.open("GET", e, !0), m.addEventListener("load", function(t) {
                                    var n = this.response;
                                    Wa.add(e, n);
                                    var r = Ya[e];
                                    if (delete Ya[e], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (var o = 0, a = r.length; o < a; o++) {
                                            (s = r[o]).onLoad && s.onLoad(n)
                                        }
                                        i.manager.itemEnd(e)
                                    } else {
                                        for (o = 0, a = r.length; o < a; o++) {
                                            var s;
                                            (s = r[o]).onError && s.onError(t)
                                        }
                                        i.manager.itemEnd(e), i.manager.itemError(e)
                                    }
                                }, !1), m.addEventListener("progress", function(t) {
                                    for (var n = Ya[e], r = 0, i = n.length; r < i; r++) {
                                        var o = n[r];
                                        o.onProgress && o.onProgress(t)
                                    }
                                }, !1), m.addEventListener("error", function(t) {
                                    var n = Ya[e];
                                    delete Ya[e];
                                    for (var r = 0, o = n.length; r < o; r++) {
                                        var a = n[r];
                                        a.onError && a.onError(t)
                                    }
                                    i.manager.itemEnd(e), i.manager.itemError(e)
                                }, !1), m.addEventListener("abort", function(t) {
                                    var n = Ya[e];
                                    delete Ya[e];
                                    for (var r = 0, o = n.length; r < o; r++) {
                                        var a = n[r];
                                        a.onError && a.onError(t)
                                    }
                                    i.manager.itemEnd(e), i.manager.itemError(e)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                            m.send(null)
                        }
                        return i.manager.itemStart(e), m
                    }
                    Ya[e].push({ onLoad: t, onProgress: n, onError: r })
                },
                setPath: function(e) { return this.path = e, this },
                setResponseType: function(e) { return this.responseType = e, this },
                setWithCredentials: function(e) { return this.withCredentials = e, this },
                setMimeType: function(e) { return this.mimeType = e, this },
                setRequestHeader: function(e) { return this.requestHeader = e, this }
            }), Object.assign(Ja.prototype, {
                load: function(e, t, n, r) {
                    var i = this,
                        o = [],
                        a = new yo;
                    a.image = o;
                    var s = new Za(this.manager);

                    function u(u) {
                        s.load(e[u], function(e) {
                            var n = i._parser(e, !0);
                            o[u] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === (c += 1) && (1 === n.mipmapCount && (a.minFilter = Oe), a.format = n.format, a.needsUpdate = !0, t && t(a))
                        }, n, r)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var c = 0, l = 0, h = e.length; l < h; ++l) u(l);
                    else s.load(e, function(e) {
                        var n = i._parser(e, !0);
                        if (n.isCubemap)
                            for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) { o[s] = { mipmaps: [] }; for (var u = 0; u < n.mipmapCount; u++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + u]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = Oe), a.format = n.format, a.needsUpdate = !0, t && t(a)
                    }, n, r);
                    return a
                },
                setPath: function(e) { return this.path = e, this }
            }), Object.assign(Ka.prototype, {
                load: function(e, t, n, r) {
                    var i = this,
                        o = new dn,
                        a = new Za(this.manager);
                    return a.setResponseType("arraybuffer"), a.load(e, function(e) {
                        var n = i._parser(e);
                        n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : Ae, o.wrapT = void 0 !== n.wrapT ? n.wrapT : Ae, o.magFilter = void 0 !== n.magFilter ? n.magFilter : Oe, o.minFilter = void 0 !== n.minFilter ? n.minFilter : De, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = Oe), o.needsUpdate = !0, t && t(o, n))
                    }, n, r), o
                }
            }), Object.assign($a.prototype, {
                crossOrigin: "anonymous",
                load: function(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var i = this,
                        o = Wa.get(e);
                    if (void 0 !== o) return i.manager.itemStart(e), setTimeout(function() { t && t(o), i.manager.itemEnd(e) }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() { a.removeEventListener("load", s, !1), a.removeEventListener("error", u, !1), Wa.add(e, this), t && t(this), i.manager.itemEnd(e) }

                    function u(t) { a.removeEventListener("load", s, !1), a.removeEventListener("error", u, !1), r && r(t), i.manager.itemEnd(e), i.manager.itemError(e) }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", u, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a
                },
                setCrossOrigin: function(e) { return this.crossOrigin = e, this },
                setPath: function(e) { return this.path = e, this }
            }), Object.assign(Qa.prototype, {
                crossOrigin: "anonymous",
                load: function(e, t, n, r) {
                    var i = new Ar,
                        o = new $a(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(n) { o.load(e[n], function(e) { i.images[n] = e, 6 === ++a && (i.needsUpdate = !0, t && t(i)) }, void 0, r) }
                    for (var u = 0; u < e.length; ++u) s(u);
                    return i
                },
                setCrossOrigin: function(e) { return this.crossOrigin = e, this },
                setPath: function(e) { return this.path = e, this }
            }), Object.assign(es.prototype, {
                crossOrigin: "anonymous",
                load: function(e, t, n, r) {
                    var i = new cn,
                        o = new $a(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(n) {
                        i.image = n;
                        var r = e.search(/\.jpe?g$/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                        i.format = r ? Ye : Ze, i.needsUpdate = !0, void 0 !== t && t(i)
                    }, n, r), i
                },
                setCrossOrigin: function(e) { return this.crossOrigin = e, this },
                setPath: function(e) { return this.path = e, this }
            }), Object.assign(ts.prototype, {
                getPoint: function() { return console.warn("THREE.Curve: .getPoint() not implemented."), null },
                getPointAt: function(e, t) { var n = this.getUtoTmapping(e); return this.getPoint(n, t) },
                getPoints: function(e) { void 0 === e && (e = 5); for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e)); return t },
                getSpacedPoints: function(e) { void 0 === e && (e = 5); for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e)); return t },
                getLength: function() { var e = this.getLengths(); return e[e.length - 1] },
                getLengths: function(e) {
                    if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t, n, r = [],
                        i = this.getPoint(0),
                        o = 0;
                    for (r.push(0), n = 1; n <= e; n++) o += (t = this.getPoint(n / e)).distanceTo(i), r.push(o), i = t;
                    return this.cacheArcLengths = r, r
                },
                updateArcLengths: function() { this.needsUpdate = !0, this.getLengths() },
                getUtoTmapping: function(e, t) {
                    var n, r = this.getLengths(),
                        i = 0,
                        o = r.length;
                    n = t || e * r[o - 1];
                    for (var a, s = 0, u = o - 1; s <= u;)
                        if ((a = r[i = Math.floor(s + (u - s) / 2)] - n) < 0) s = i + 1;
                        else {
                            if (!(a > 0)) { u = i; break }
                            u = i - 1
                        }
                    if (r[i = u] === n) return i / (o - 1);
                    var c = r[i];
                    return (i + (n - c) / (r[i + 1] - c)) / (o - 1)
                },
                getTangent: function(e) {
                    var t = e - 1e-4,
                        n = e + 1e-4;
                    t < 0 && (t = 0), n > 1 && (n = 1);
                    var r = this.getPoint(t);
                    return this.getPoint(n).clone().sub(r).normalize()
                },
                getTangentAt: function(e) { var t = this.getUtoTmapping(e); return this.getTangent(t) },
                computeFrenetFrames: function(e, t) {
                    var n, r, i, o = new Qt,
                        a = [],
                        s = [],
                        u = [],
                        c = new Qt,
                        l = new Kt;
                    for (n = 0; n <= e; n++) r = n / e, a[n] = this.getTangentAt(r), a[n].normalize();
                    s[0] = new Qt, u[0] = new Qt;
                    var h = Number.MAX_VALUE,
                        p = Math.abs(a[0].x),
                        d = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (p <= h && (h = p, o.set(1, 0, 0)), d <= h && (h = d, o.set(0, 1, 0)), f <= h && o.set(0, 0, 1), c.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], c), u[0].crossVectors(a[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), u[n] = u[n - 1].clone(), c.crossVectors(a[n - 1], a[n]), c.length() > Number.EPSILON && (c.normalize(), i = Math.acos(Zt.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(l.makeRotationAxis(c, i))), u[n].crossVectors(a[n], s[n]);
                    if (!0 === t)
                        for (i = Math.acos(Zt.clamp(s[0].dot(s[e]), -1, 1)), i /= e, a[0].dot(c.crossVectors(s[0], s[e])) > 0 && (i = -i), n = 1; n <= e; n++) s[n].applyMatrix4(l.makeRotationAxis(a[n], i * n)), u[n].crossVectors(a[n], s[n]);
                    return { tangents: a, normals: s, binormals: u }
                },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this },
                toJSON: function() { var e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e },
                fromJSON: function(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this }
            }), ns.prototype = Object.create(ts.prototype), ns.prototype.constructor = ns, ns.prototype.isEllipseCurve = !0, ns.prototype.getPoint = function(e, t) {
                for (var n = t || new Jt, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
                for (; i > r;) i -= r;
                i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                var a = this.aStartAngle + e * i,
                    s = this.aX + this.xRadius * Math.cos(a),
                    u = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var c = Math.cos(this.aRotation),
                        l = Math.sin(this.aRotation),
                        h = s - this.aX,
                        p = u - this.aY;
                    s = h * c - p * l + this.aX, u = h * l + p * c + this.aY
                }
                return n.set(s, u)
            }, ns.prototype.copy = function(e) { return ts.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, ns.prototype.toJSON = function() { var e = ts.prototype.toJSON.call(this); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e }, ns.prototype.fromJSON = function(e) { return ts.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, rs.prototype = Object.create(ns.prototype), rs.prototype.constructor = rs, rs.prototype.isArcCurve = !0;
            var os = new Qt,
                as = new is,
                ss = new is,
                us = new is;

            function cs(e, t, n, r) { ts.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = r || .5 }

            function ls(e, t, n, r, i) {
                var o = .5 * (r - t),
                    a = .5 * (i - n),
                    s = e * e;
                return (2 * n - 2 * r + o + a) * (e * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
            }

            function hs(e, t, n, r) { return function(e, t) { var n = 1 - e; return n * n * t }(e, t) + function(e, t) { return 2 * (1 - e) * e * t }(e, n) + function(e, t) { return e * e * t }(e, r) }

            function ps(e, t, n, r, i) { return function(e, t) { var n = 1 - e; return n * n * n * t }(e, t) + function(e, t) { var n = 1 - e; return 3 * n * n * e * t }(e, n) + function(e, t) { return 3 * (1 - e) * e * e * t }(e, r) + function(e, t) { return e * e * e * t }(e, i) }

            function ds(e, t, n, r) { ts.call(this), this.type = "CubicBezierCurve", this.v0 = e || new Jt, this.v1 = t || new Jt, this.v2 = n || new Jt, this.v3 = r || new Jt }

            function fs(e, t, n, r) { ts.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Qt, this.v1 = t || new Qt, this.v2 = n || new Qt, this.v3 = r || new Qt }

            function ms(e, t) { ts.call(this), this.type = "LineCurve", this.v1 = e || new Jt, this.v2 = t || new Jt }

            function vs(e, t) { ts.call(this), this.type = "LineCurve3", this.v1 = e || new Qt, this.v2 = t || new Qt }

            function gs(e, t, n) { ts.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new Jt, this.v1 = t || new Jt, this.v2 = n || new Jt }

            function ys(e, t, n) { ts.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Qt, this.v1 = t || new Qt, this.v2 = n || new Qt }

            function _s(e) { ts.call(this), this.type = "SplineCurve", this.points = e || [] }
            cs.prototype = Object.create(ts.prototype), cs.prototype.constructor = cs, cs.prototype.isCatmullRomCurve3 = !0, cs.prototype.getPoint = function(e, t) {
                var n, r, i, o, a = t || new Qt,
                    s = this.points,
                    u = s.length,
                    c = (u - (this.closed ? 0 : 1)) * e,
                    l = Math.floor(c),
                    h = c - l;
                if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / u) + 1) * u : 0 === h && l === u - 1 && (l = u - 2, h = 1), this.closed || l > 0 ? n = s[(l - 1) % u] : (os.subVectors(s[0], s[1]).add(s[0]), n = os), r = s[l % u], i = s[(l + 1) % u], this.closed || l + 2 < u ? o = s[(l + 2) % u] : (os.subVectors(s[u - 1], s[u - 2]).add(s[u - 1]), o = os), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var p = "chordal" === this.curveType ? .5 : .25,
                        d = Math.pow(n.distanceToSquared(r), p),
                        f = Math.pow(r.distanceToSquared(i), p),
                        m = Math.pow(i.distanceToSquared(o), p);
                    f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), as.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, d, f, m), ss.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, d, f, m), us.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, d, f, m)
                } else "catmullrom" === this.curveType && (as.initCatmullRom(n.x, r.x, i.x, o.x, this.tension), ss.initCatmullRom(n.y, r.y, i.y, o.y, this.tension), us.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
                return a.set(as.calc(h), ss.calc(h), us.calc(h)), a
            }, cs.prototype.copy = function(e) {
                ts.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push(r.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, cs.prototype.toJSON = function() {
                var e = ts.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var r = this.points[t];
                    e.points.push(r.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }, cs.prototype.fromJSON = function(e) {
                ts.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push((new Qt).fromArray(r))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, ds.prototype = Object.create(ts.prototype), ds.prototype.constructor = ds, ds.prototype.isCubicBezierCurve = !0, ds.prototype.getPoint = function(e, t) {
                var n = t || new Jt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(ps(e, r.x, i.x, o.x, a.x), ps(e, r.y, i.y, o.y, a.y)), n
            }, ds.prototype.copy = function(e) { return ts.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, ds.prototype.toJSON = function() { var e = ts.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, ds.prototype.fromJSON = function(e) { return ts.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, fs.prototype = Object.create(ts.prototype), fs.prototype.constructor = fs, fs.prototype.isCubicBezierCurve3 = !0, fs.prototype.getPoint = function(e, t) {
                var n = t || new Qt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(ps(e, r.x, i.x, o.x, a.x), ps(e, r.y, i.y, o.y, a.y), ps(e, r.z, i.z, o.z, a.z)), n
            }, fs.prototype.copy = function(e) { return ts.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, fs.prototype.toJSON = function() { var e = ts.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, fs.prototype.fromJSON = function(e) { return ts.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, ms.prototype = Object.create(ts.prototype), ms.prototype.constructor = ms, ms.prototype.isLineCurve = !0, ms.prototype.getPoint = function(e, t) { var n = t || new Jt; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n }, ms.prototype.getPointAt = function(e, t) { return this.getPoint(e, t) }, ms.prototype.getTangent = function() { return this.v2.clone().sub(this.v1).normalize() }, ms.prototype.copy = function(e) { return ts.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, ms.prototype.toJSON = function() { var e = ts.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, ms.prototype.fromJSON = function(e) { return ts.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, vs.prototype = Object.create(ts.prototype), vs.prototype.constructor = vs, vs.prototype.isLineCurve3 = !0, vs.prototype.getPoint = function(e, t) { var n = t || new Qt; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n }, vs.prototype.getPointAt = function(e, t) { return this.getPoint(e, t) }, vs.prototype.copy = function(e) { return ts.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, vs.prototype.toJSON = function() { var e = ts.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, vs.prototype.fromJSON = function(e) { return ts.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, gs.prototype = Object.create(ts.prototype), gs.prototype.constructor = gs, gs.prototype.isQuadraticBezierCurve = !0, gs.prototype.getPoint = function(e, t) {
                var n = t || new Jt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(hs(e, r.x, i.x, o.x), hs(e, r.y, i.y, o.y)), n
            }, gs.prototype.copy = function(e) { return ts.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, gs.prototype.toJSON = function() { var e = ts.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, gs.prototype.fromJSON = function(e) { return ts.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, ys.prototype = Object.create(ts.prototype), ys.prototype.constructor = ys, ys.prototype.isQuadraticBezierCurve3 = !0, ys.prototype.getPoint = function(e, t) {
                var n = t || new Qt,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(hs(e, r.x, i.x, o.x), hs(e, r.y, i.y, o.y), hs(e, r.z, i.z, o.z)), n
            }, ys.prototype.copy = function(e) { return ts.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, ys.prototype.toJSON = function() { var e = ts.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, ys.prototype.fromJSON = function(e) { return ts.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, _s.prototype = Object.create(ts.prototype), _s.prototype.constructor = _s, _s.prototype.isSplineCurve = !0, _s.prototype.getPoint = function(e, t) {
                var n = t || new Jt,
                    r = this.points,
                    i = (r.length - 1) * e,
                    o = Math.floor(i),
                    a = i - o,
                    s = r[0 === o ? o : o - 1],
                    u = r[o],
                    c = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    l = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return n.set(ls(a, s.x, u.x, c.x, l.x), ls(a, s.y, u.y, c.y, l.y)), n
            }, _s.prototype.copy = function(e) {
                ts.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push(r.clone())
                }
                return this
            }, _s.prototype.toJSON = function() {
                var e = ts.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var r = this.points[t];
                    e.points.push(r.toArray())
                }
                return e
            }, _s.prototype.fromJSON = function(e) {
                ts.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var r = e.points[t];
                    this.points.push((new Jt).fromArray(r))
                }
                return this
            };
            var xs = Object.freeze({ ArcCurve: rs, CatmullRomCurve3: cs, CubicBezierCurve: ds, CubicBezierCurve3: fs, EllipseCurve: ns, LineCurve: ms, LineCurve3: vs, QuadraticBezierCurve: gs, QuadraticBezierCurve3: ys, SplineCurve: _s });

            function bs() { ts.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 }

            function ws(e) { bs.call(this), this.type = "Path", this.currentPoint = new Jt, e && this.setFromPoints(e) }

            function Ms(e) { ws.call(this, e), this.uuid = Zt.generateUUID(), this.type = "Shape", this.holes = [] }

            function Es(e, t) { Bn.call(this), this.type = "Light", this.color = new En(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0 }

            function Ss(e, t, n) { Es.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Bn.DefaultUp), this.updateMatrix(), this.groundColor = new En(t) }

            function Ts(e) { this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new Jt(512, 512), this.map = null, this.matrix = new Kt }

            function As() { Ts.call(this, new Zi(50, 1, .5, 500)) }

            function Ps(e, t, n, r, i, o) { Es.call(this, e, t), this.type = "SpotLight", this.position.copy(Bn.DefaultUp), this.updateMatrix(), this.target = new Bn, Object.defineProperty(this, "power", { get: function() { return this.intensity * Math.PI }, set: function(e) { this.intensity = e / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new As }

            function Rs(e, t, n, r) { Es.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", { get: function() { return 4 * this.intensity * Math.PI }, set: function(e) { this.intensity = e / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Ts(new Zi(90, 1, .5, 500)) }

            function Ls(e, t, n, r, i, o) { Yi.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix() }

            function Cs() { Ts.call(this, new Ls(-5, 5, 5, -5, .5, 500)) }

            function Os(e, t) { Es.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Bn.DefaultUp), this.updateMatrix(), this.target = new Bn, this.shadow = new Cs }

            function Is(e, t) { Es.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0 }

            function Ds(e, t, n, r) { Es.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10 }
            bs.prototype = Object.assign(Object.create(ts.prototype), {
                constructor: bs,
                add: function(e) { this.curves.push(e) },
                closePath: function() {
                    var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new ms(t, e))
                },
                getPoint: function(e) {
                    for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                        if (n[r] >= t) {
                            var i = n[r] - t,
                                o = this.curves[r],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - i / a;
                            return o.getPointAt(s)
                        }
                        r++
                    }
                    return null
                },
                getLength: function() { var e = this.getCurveLengths(); return e[e.length - 1] },
                updateArcLengths: function() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() },
                getCurveLengths: function() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e, e },
                getSpacedPoints: function(e) { void 0 === e && (e = 40); for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t },
                getPoints: function(e) {
                    e = e || 12;
                    for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
                        for (var o = i[r], a = o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), u = 0; u < s.length; u++) {
                            var c = s[u];
                            t && t.equals(c) || (n.push(c), t = c)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function(e) {
                    ts.prototype.copy.call(this, e), this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var r = e.curves[t];
                        this.curves.push(r.clone())
                    }
                    return this.autoClose = e.autoClose, this
                },
                toJSON: function() {
                    var e = ts.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = [];
                    for (var t = 0, n = this.curves.length; t < n; t++) {
                        var r = this.curves[t];
                        e.curves.push(r.toJSON())
                    }
                    return e
                },
                fromJSON: function(e) {
                    ts.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var r = e.curves[t];
                        this.curves.push((new xs[r.type]).fromJSON(r))
                    }
                    return this
                }
            }), ws.prototype = Object.assign(Object.create(bs.prototype), {
                constructor: ws,
                setFromPoints: function(e) { this.moveTo(e[0].x, e[0].y); for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y) },
                moveTo: function(e, t) { this.currentPoint.set(e, t) },
                lineTo: function(e, t) {
                    var n = new ms(this.currentPoint.clone(), new Jt(e, t));
                    this.curves.push(n), this.currentPoint.set(e, t)
                },
                quadraticCurveTo: function(e, t, n, r) {
                    var i = new gs(this.currentPoint.clone(), new Jt(e, t), new Jt(n, r));
                    this.curves.push(i), this.currentPoint.set(n, r)
                },
                bezierCurveTo: function(e, t, n, r, i, o) {
                    var a = new ds(this.currentPoint.clone(), new Jt(e, t), new Jt(n, r), new Jt(i, o));
                    this.curves.push(a), this.currentPoint.set(i, o)
                },
                splineThru: function(e) {
                    var t = new _s([this.currentPoint.clone()].concat(e));
                    this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
                },
                arc: function(e, t, n, r, i, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(e + a, t + s, n, r, i, o)
                },
                absarc: function(e, t, n, r, i, o) { this.absellipse(e, t, n, n, r, i, o) },
                ellipse: function(e, t, n, r, i, o, a, s) {
                    var u = this.currentPoint.x,
                        c = this.currentPoint.y;
                    this.absellipse(e + u, t + c, n, r, i, o, a, s)
                },
                absellipse: function(e, t, n, r, i, o, a, s) {
                    var u = new ns(e, t, n, r, i, o, a, s);
                    if (this.curves.length > 0) {
                        var c = u.getPoint(0);
                        c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
                    }
                    this.curves.push(u);
                    var l = u.getPoint(1);
                    this.currentPoint.copy(l)
                },
                copy: function(e) { return bs.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this },
                toJSON: function() { var e = bs.prototype.toJSON.call(this); return e.currentPoint = this.currentPoint.toArray(), e },
                fromJSON: function(e) { return bs.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this }
            }), Ms.prototype = Object.assign(Object.create(ws.prototype), {
                constructor: Ms,
                getPointsHoles: function(e) { for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e); return t },
                extractPoints: function(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } },
                copy: function(e) {
                    ws.prototype.copy.call(this, e), this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var r = e.holes[t];
                        this.holes.push(r.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var e = ws.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = [];
                    for (var t = 0, n = this.holes.length; t < n; t++) {
                        var r = this.holes[t];
                        e.holes.push(r.toJSON())
                    }
                    return e
                },
                fromJSON: function(e) {
                    ws.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var r = e.holes[t];
                        this.holes.push((new ws).fromJSON(r))
                    }
                    return this
                }
            }), Es.prototype = Object.assign(Object.create(Bn.prototype), { constructor: Es, isLight: !0, copy: function(e) { return Bn.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this }, toJSON: function(e) { var t = Bn.prototype.toJSON.call(this, e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), Ss.prototype = Object.assign(Object.create(Es.prototype), { constructor: Ss, isHemisphereLight: !0, copy: function(e) { return Es.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } }), Object.assign(Ts.prototype, { copy: function(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this }, clone: function() { return (new this.constructor).copy(this) }, toJSON: function() { var e = {}; return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } }), As.prototype = Object.assign(Object.create(Ts.prototype), {
                constructor: As,
                isSpotLightShadow: !0,
                update: function(e) {
                    var t = this.camera,
                        n = 2 * Zt.RAD2DEG * e.angle,
                        r = this.mapSize.width / this.mapSize.height,
                        i = e.distance || t.far;
                    n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix())
                }
            }), Ps.prototype = Object.assign(Object.create(Es.prototype), { constructor: Ps, isSpotLight: !0, copy: function(e) { return Es.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), Rs.prototype = Object.assign(Object.create(Es.prototype), { constructor: Rs, isPointLight: !0, copy: function(e) { return Es.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } }), Ls.prototype = Object.assign(Object.create(Yi.prototype), {
                constructor: Ls,
                isOrthographicCamera: !0,
                copy: function(e, t) { return Yi.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this },
                setViewOffset: function(e, t, n, r, i, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix() },
                clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() },
                updateProjectionMatrix: function() {
                    var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2,
                        i = n - e,
                        o = n + e,
                        a = r + t,
                        s = r - t;
                    if (null !== this.view && this.view.enabled) {
                        var u = this.zoom / (this.view.width / this.view.fullWidth),
                            c = this.zoom / (this.view.height / this.view.fullHeight),
                            l = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        o = (i += l * (this.view.offsetX / u)) + l * (this.view.width / u), s = (a -= h * (this.view.offsetY / c)) - h * (this.view.height / c)
                    }
                    this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(e) { var t = Bn.prototype.toJSON.call(this, e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t }
            }), Cs.prototype = Object.assign(Object.create(Ts.prototype), { constructor: Cs }), Os.prototype = Object.assign(Object.create(Es.prototype), { constructor: Os, isDirectionalLight: !0, copy: function(e) { return Es.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), Is.prototype = Object.assign(Object.create(Es.prototype), { constructor: Is, isAmbientLight: !0 }), Ds.prototype = Object.assign(Object.create(Es.prototype), { constructor: Ds, isRectAreaLight: !0, copy: function(e) { return Es.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this }, toJSON: function(e) { var t = Es.prototype.toJSON.call(this, e); return t.object.width = this.width, t.object.height = this.height, t } });
            var Us = {
                arraySlice: function(e, t, n) { return Us.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n) },
                convertArray: function(e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) },
                isTypedArray: function(e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) },
                getKeyframeOrder: function(e) { for (var t = e.length, n = new Array(t), r = 0; r !== t; ++r) n[r] = r; return n.sort(function(t, n) { return e[t] - e[n] }), n },
                sortedArray: function(e, t, n) {
                    for (var r = e.length, i = new e.constructor(r), o = 0, a = 0; a !== r; ++o)
                        for (var s = n[o] * t, u = 0; u !== t; ++u) i[a++] = e[s + u];
                    return i
                },
                flattenJSON: function(e, t, n, r) {
                    for (var i = 1, o = e[0]; void 0 !== o && void 0 === o[r];) o = e[i++];
                    if (void 0 !== o) {
                        var a = o[r];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                do { void 0 !== (a = o[r]) && (t.push(o.time), n.push.apply(n, a)), o = e[i++] } while (void 0 !== o);
                            else if (void 0 !== a.toArray)
                            do { void 0 !== (a = o[r]) && (t.push(o.time), a.toArray(n, n.length)), o = e[i++] } while (void 0 !== o);
                        else
                            do { void 0 !== (a = o[r]) && (t.push(o.time), n.push(a)), o = e[i++] } while (void 0 !== o)
                    }
                }
            };

            function Fs(e, t, n, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n }

            function Ns(e, t, n, r) { Fs.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 }

            function Bs(e, t, n, r) { Fs.call(this, e, t, n, r) }

            function zs(e, t, n, r) { Fs.call(this, e, t, n, r) }

            function ks(e, t, n, r) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Us.convertArray(t, this.TimeBufferType), this.values = Us.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }

            function Gs(e, t, n) { ks.call(this, e, t, n) }

            function js(e, t, n, r) { ks.call(this, e, t, n, r) }

            function Hs(e, t, n, r) { ks.call(this, e, t, n, r) }

            function Vs(e, t, n, r) { Fs.call(this, e, t, n, r) }

            function Ws(e, t, n, r) { ks.call(this, e, t, n, r) }

            function Xs(e, t, n, r) { ks.call(this, e, t, n, r) }

            function qs(e, t, n, r) { ks.call(this, e, t, n, r) }

            function Ys(e, t, n) { this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = Zt.generateUUID(), this.duration < 0 && this.resetDuration() }

            function Zs(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var t = function(e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Hs;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return qs;
                        case "color":
                            return js;
                        case "quaternion":
                            return Ws;
                        case "bool":
                        case "boolean":
                            return Gs;
                        case "string":
                            return Xs
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    var n = [],
                        r = [];
                    Us.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }

            function Js(e) { this.manager = void 0 !== e ? e : qa, this.textures = {} }

            function Ks(e) { this.manager = void 0 !== e ? e : qa }
            Object.assign(Fs.prototype, {
                evaluate: function(e) {
                    var t = this.parameterPositions,
                        n = this._cachedIndex,
                        r = t[n],
                        i = t[n - 1];
                    e: {
                        t: {
                            var o;n: {
                                r: if (!(e < r)) {
                                    for (var a = n + 2;;) { if (void 0 === r) { if (e < i) break r; return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i) } if (n === a) break; if (i = r, e < (r = t[++n])) break t }
                                    o = t.length;
                                    break n
                                }if (e >= i) break e;
                                var s = t[1];e < s && (n = 2, i = s);
                                for (a = n - 2;;) { if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r); if (n === a) break; if (r = i, e >= (i = t[--n - 1])) break t }
                                o = n,
                                n = 0
                            }
                            for (; n < o;) {
                                var u = n + o >>> 1;
                                e < t[u] ? o = u : n = u + 1
                            }
                            if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                            if (void 0 === r) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, e)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, e, r)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() { return this.settings || this.DefaultSettings_ },
                copySampleValue_: function(e) { for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, o = 0; o !== r; ++o) t[o] = n[i + o]; return t },
                interpolate_: function() { throw new Error("call to abstract method") },
                intervalChanged_: function() {}
            }), Object.assign(Fs.prototype, { beforeStart_: Fs.prototype.copySampleValue_, afterEnd_: Fs.prototype.copySampleValue_ }), Ns.prototype = Object.assign(Object.create(Fs.prototype), {
                constructor: Ns,
                DefaultSettings_: { endingStart: Ct, endingEnd: Ct },
                intervalChanged_: function(e, t, n) {
                    var r = this.parameterPositions,
                        i = e - 2,
                        o = e + 1,
                        a = r[i],
                        s = r[o];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case Ot:
                            i = e, a = 2 * t - n;
                            break;
                        case It:
                            a = t + r[i = r.length - 2] - r[i + 1];
                            break;
                        default:
                            i = e, a = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case Ot:
                            o = e, s = 2 * n - t;
                            break;
                        case It:
                            o = 1, s = n + r[1] - r[0];
                            break;
                        default:
                            o = e - 1, s = t
                    }
                    var u = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = u / (t - a), this._weightNext = u / (s - n), this._offsetPrev = i * c, this._offsetNext = o * c
                },
                interpolate_: function(e, t, n, r) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, u = s - a, c = this._offsetPrev, l = this._offsetNext, h = this._weightPrev, p = this._weightNext, d = (n - t) / (r - t), f = d * d, m = f * d, v = -h * m + 2 * h * f - h * d, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, _ = p * m - p * f, x = 0; x !== a; ++x) i[x] = v * o[c + x] + g * o[u + x] + y * o[s + x] + _ * o[l + x]; return i }
            }), Bs.prototype = Object.assign(Object.create(Fs.prototype), { constructor: Bs, interpolate_: function(e, t, n, r) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, u = s - a, c = (n - t) / (r - t), l = 1 - c, h = 0; h !== a; ++h) i[h] = o[u + h] * l + o[s + h] * c; return i } }), zs.prototype = Object.assign(Object.create(Fs.prototype), { constructor: zs, interpolate_: function(e) { return this.copySampleValue_(e - 1) } }), Object.assign(ks, {
                toJSON: function(e) {
                    var t, n = e.constructor;
                    if (void 0 !== n.toJSON) t = n.toJSON(e);
                    else {
                        t = { name: e.name, times: Us.convertArray(e.times, Array), values: Us.convertArray(e.values, Array) };
                        var r = e.getInterpolation();
                        r !== e.DefaultInterpolation && (t.interpolation = r)
                    }
                    return t.type = e.ValueTypeName, t
                }
            }), Object.assign(ks.prototype, {
                constructor: ks,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: Rt,
                InterpolantFactoryMethodDiscrete: function(e) { return new zs(this.times, this.values, this.getValueSize(), e) },
                InterpolantFactoryMethodLinear: function(e) { return new Bs(this.times, this.values, this.getValueSize(), e) },
                InterpolantFactoryMethodSmooth: function(e) { return new Ns(this.times, this.values, this.getValueSize(), e) },
                setInterpolation: function(e) {
                    var t;
                    switch (e) {
                        case Pt:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case Rt:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case Lt:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(n);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", n), this
                    }
                    return this.createInterpolant = t, this
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Pt;
                        case this.InterpolantFactoryMethodLinear:
                            return Rt;
                        case this.InterpolantFactoryMethodSmooth:
                            return Lt
                    }
                },
                getValueSize: function() { return this.values.length / this.times.length },
                shift: function(e) {
                    if (0 !== e)
                        for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
                    return this
                },
                scale: function(e) {
                    if (1 !== e)
                        for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
                    return this
                },
                trim: function(e, t) {
                    for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < e;) ++i;
                    for (; - 1 !== o && n[o] > t;) --o;
                    if (++o, 0 !== i || o !== r) {
                        i >= o && (i = (o = Math.max(o, 1)) - 1);
                        var a = this.getValueSize();
                        this.times = Us.arraySlice(n, i, o), this.values = Us.arraySlice(this.values, i * a, o * a)
                    }
                    return this
                },
                validate: function() {
                    var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    var n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    for (var o = null, a = 0; a !== i; a++) {
                        var s = n[a];
                        if ("number" == typeof s && isNaN(s)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), e = !1; break }
                        if (null !== o && o > s) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), e = !1; break }
                        o = s
                    }
                    if (void 0 !== r && Us.isTypedArray(r)) { a = 0; for (var u = r.length; a !== u; ++a) { var c = r[a]; if (isNaN(c)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1; break } } }
                    return e
                },
                optimize: function() {
                    for (var e = this.times, t = this.values, n = this.getValueSize(), r = this.getInterpolation() === Lt, i = 1, o = e.length - 1, a = 1; a < o; ++a) {
                        var s = !1,
                            u = e[a];
                        if (u !== e[a + 1] && (1 !== a || u !== u[0]))
                            if (r) s = !0;
                            else
                                for (var c = a * n, l = c - n, h = c + n, p = 0; p !== n; ++p) { var d = t[c + p]; if (d !== t[l + p] || d !== t[h + p]) { s = !0; break } }
                        if (s) {
                            if (a !== i) {
                                e[i] = e[a];
                                var f = a * n,
                                    m = i * n;
                                for (p = 0; p !== n; ++p) t[m + p] = t[f + p]
                            }++i
                        }
                    }
                    if (o > 0) { e[i] = e[o]; for (f = o * n, m = i * n, p = 0; p !== n; ++p) t[m + p] = t[f + p];++i }
                    return i !== e.length && (this.times = Us.arraySlice(e, 0, i), this.values = Us.arraySlice(t, 0, i * n)), this
                }
            }), Gs.prototype = Object.assign(Object.create(ks.prototype), { constructor: Gs, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: Pt, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), js.prototype = Object.assign(Object.create(ks.prototype), { constructor: js, ValueTypeName: "color" }), Hs.prototype = Object.assign(Object.create(ks.prototype), { constructor: Hs, ValueTypeName: "number" }), Vs.prototype = Object.assign(Object.create(Fs.prototype), { constructor: Vs, interpolate_: function(e, t, n, r) { for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, u = (n - t) / (r - t), c = s + a; s !== c; s += 4) $t.slerpFlat(i, 0, o, s - a, o, s, u); return i } }), Ws.prototype = Object.assign(Object.create(ks.prototype), { constructor: Ws, ValueTypeName: "quaternion", DefaultInterpolation: Rt, InterpolantFactoryMethodLinear: function(e) { return new Vs(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: void 0 }), Xs.prototype = Object.assign(Object.create(ks.prototype), { constructor: Xs, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: Pt, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), qs.prototype = Object.assign(Object.create(ks.prototype), { constructor: qs, ValueTypeName: "vector" }), Object.assign(Ys, {
                parse: function(e) { for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, o = n.length; i !== o; ++i) t.push(Zs(n[i]).scale(r)); return new Ys(e.name, e.duration, t) },
                toJSON: function(e) { for (var t = [], n = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid }, i = 0, o = n.length; i !== o; ++i) t.push(ks.toJSON(n[i])); return r },
                CreateFromMorphTargetSequence: function(e, t, n, r) {
                    for (var i = t.length, o = [], a = 0; a < i; a++) {
                        var s = [],
                            u = [];
                        s.push((a + i - 1) % i, a, (a + 1) % i), u.push(0, 1, 0);
                        var c = Us.getKeyframeOrder(s);
                        s = Us.sortedArray(s, 1, c), u = Us.sortedArray(u, 1, c), r || 0 !== s[0] || (s.push(i), u.push(u[0])), o.push(new Hs(".morphTargetInfluences[" + t[a].name + "]", s, u).scale(1 / n))
                    }
                    return new Ys(e, -1, o)
                },
                findByName: function(e, t) {
                    var n = e;
                    if (!Array.isArray(e)) {
                        var r = e;
                        n = r.geometry && r.geometry.animations || r.animations
                    }
                    for (var i = 0; i < n.length; i++)
                        if (n[i].name === t) return n[i];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(e, t, n) {
                    for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                        var s = e[o],
                            u = s.name.match(i);
                        if (u && u.length > 1) {
                            var c = r[h = u[1]];
                            c || (r[h] = c = []), c.push(s)
                        }
                    }
                    var l = [];
                    for (var h in r) l.push(Ys.CreateFromMorphTargetSequence(h, r[h], t, n));
                    return l
                },
                parseAnimation: function(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (var n = function(e, t, n, r, i) {
                            if (0 !== n.length) {
                                var o = [],
                                    a = [];
                                Us.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new e(t, o, a))
                            }
                        }, r = [], i = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], u = 0; u < s.length; u++) {
                        var c = s[u].keys;
                        if (c && 0 !== c.length)
                            if (c[0].morphTargets) {
                                for (var l = {}, h = 0; h < c.length; h++)
                                    if (c[h].morphTargets)
                                        for (var p = 0; p < c[h].morphTargets.length; p++) l[c[h].morphTargets[p]] = -1;
                                for (var d in l) {
                                    var f = [],
                                        m = [];
                                    for (p = 0; p !== c[h].morphTargets.length; ++p) {
                                        var v = c[h];
                                        f.push(v.time), m.push(v.morphTarget === d ? 1 : 0)
                                    }
                                    r.push(new Hs(".morphTargetInfluence[" + d + "]", f, m))
                                }
                                o = l.length * (a || 1)
                            } else {
                                var g = ".bones[" + t[u].name + "]";
                                n(qs, g + ".position", c, "pos", r), n(Ws, g + ".quaternion", c, "rot", r), n(qs, g + ".scale", c, "scl", r)
                            }
                    }
                    return 0 === r.length ? null : new Ys(i, o, r)
                }
            }), Object.assign(Ys.prototype, {
                resetDuration: function() {
                    for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                        var r = this.tracks[t];
                        e = Math.max(e, r.times[r.times.length - 1])
                    }
                    return this.duration = e, this
                },
                trim: function() { for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration); return this },
                validate: function() { for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate(); return e },
                optimize: function() { for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize(); return this }
            }), Object.assign(Js.prototype, {
                load: function(e, t, n, r) {
                    var i = this;
                    new Za(i.manager).load(e, function(e) { t(i.parse(JSON.parse(e))) }, n, r)
                },
                setTextures: function(e) { this.textures = e },
                parse: function(e) {
                    var t = this.textures;

                    function n(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] }
                    var r = new Va[e.type];
                    if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearCoat && (r.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (r.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.uniforms)
                        for (var i in e.uniforms) {
                            var o = e.uniforms[i];
                            switch (r.uniforms[i] = {}, o.type) {
                                case "t":
                                    r.uniforms[i].value = n(o.value);
                                    break;
                                case "c":
                                    r.uniforms[i].value = (new En).setHex(o.value);
                                    break;
                                case "v2":
                                    r.uniforms[i].value = (new Jt).fromArray(o.value);
                                    break;
                                case "v3":
                                    r.uniforms[i].value = (new Qt).fromArray(o.value);
                                    break;
                                case "v4":
                                    r.uniforms[i].value = (new ln).fromArray(o.value);
                                    break;
                                case "m4":
                                    r.uniforms[i].value = (new Kt).fromArray(o.value);
                                    break;
                                default:
                                    r.uniforms[i].value = o.value
                            }
                        }
                    if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) { var a = e.normalScale;!1 === Array.isArray(a) && (a = [a, a]), r.normalScale = (new Jt).fromArray(a) }
                    return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), r
                }
            }), Object.assign(Ks.prototype, {
                load: function(e, t, n, r) {
                    var i = this;
                    new Za(i.manager).load(e, function(e) { t(i.parse(JSON.parse(e))) }, n, r)
                },
                parse: function(e) {
                    var t = new nr,
                        n = e.data.index;
                    if (void 0 !== n) {
                        var r = new nu[n.type](n.array);
                        t.setIndex(new Hn(r, 1))
                    }
                    var i = e.data.attributes;
                    for (var o in i) {
                        var a = i[o];
                        r = new nu[a.type](a.array);
                        t.addAttribute(o, new Hn(r, a.itemSize, a.normalized))
                    }
                    var s = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== s)
                        for (var u = 0, c = s.length; u !== c; ++u) {
                            var l = s[u];
                            t.addGroup(l.start, l.count, l.materialIndex)
                        }
                    var h = e.data.boundingSphere;
                    if (void 0 !== h) {
                        var p = new Qt;
                        void 0 !== h.center && p.fromArray(h.center), t.boundingSphere = new mn(p, h.radius)
                    }
                    return t
                }
            });
            var $s, Qs, eu, tu, nu = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array };

            function ru() {}
            ru.Handlers = {
                handlers: [],
                add: function(e, t) { this.handlers.push(e, t) },
                get: function(e) {
                    for (var t = this.handlers, n = 0, r = t.length; n < r; n += 2) {
                        var i = t[n],
                            o = t[n + 1];
                        if (i.test(e)) return o
                    }
                    return null
                }
            }, Object.assign(ru.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function() {},
                onLoadProgress: function() {},
                onLoadComplete: function() {},
                initMaterials: function(e, t, n) { for (var r = [], i = 0; i < e.length; ++i) r[i] = this.createMaterial(e[i], t, n); return r },
                createMaterial: ($s = { NoBlending: D, NormalBlending: U, AdditiveBlending: F, SubtractiveBlending: N, MultiplyBlending: B, CustomBlending: z }, Qs = new En, eu = new es, tu = new Js, function(e, t, n) {
                    var r = {};

                    function i(e, i, o, a, s) {
                        var u, c = t + e,
                            l = ru.Handlers.get(c);
                        null !== l ? u = l.load(c) : (eu.setCrossOrigin(n), u = eu.load(c)), void 0 !== i && (u.repeat.fromArray(i), 1 !== i[0] && (u.wrapS = Te), 1 !== i[1] && (u.wrapT = Te)), void 0 !== o && u.offset.fromArray(o), void 0 !== a && ("repeat" === a[0] && (u.wrapS = Te), "mirror" === a[0] && (u.wrapS = Pe), "repeat" === a[1] && (u.wrapT = Te), "mirror" === a[1] && (u.wrapT = Pe)), void 0 !== s && (u.anisotropy = s);
                        var h = Zt.generateUUID();
                        return r[h] = u, h
                    }
                    var o = { uuid: Zt.generateUUID(), type: "MeshLambertMaterial" };
                    for (var a in e) {
                        var s = e[a];
                        switch (a) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                o.name = s;
                                break;
                            case "blending":
                                o.blending = $s[s];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", a, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                o.color = Qs.fromArray(s).getHex();
                                break;
                            case "colorSpecular":
                                o.specular = Qs.fromArray(s).getHex();
                                break;
                            case "colorEmissive":
                                o.emissive = Qs.fromArray(s).getHex();
                                break;
                            case "specularCoef":
                                o.shininess = s;
                                break;
                            case "shading":
                                "basic" === s.toLowerCase() && (o.type = "MeshBasicMaterial"), "phong" === s.toLowerCase() && (o.type = "MeshPhongMaterial"), "standard" === s.toLowerCase() && (o.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                o.map = i(s, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                o.emissiveMap = i(s, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                o.lightMap = i(s, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                o.aoMap = i(s, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                o.bumpMap = i(s, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                o.bumpScale = s;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                o.normalMap = i(s, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                o.normalScale = s;
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                o.specularMap = i(s, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                o.metalnessMap = i(s, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                o.roughnessMap = i(s, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                o.alphaMap = i(s, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                o.side = A;
                                break;
                            case "doubleSided":
                                o.side = P;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), o.opacity = s;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                o[a] = s;
                                break;
                            case "vertexColors":
                                !0 === s && (o.vertexColors = I), "face" === s && (o.vertexColors = O);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", a, s)
                        }
                    }
                    return "MeshBasicMaterial" === o.type && delete o.emissive, "MeshPhongMaterial" !== o.type && delete o.specular, o.opacity < 1 && (o.transparent = !0), tu.setTextures(r), tu.parse(o)
                })
            });
            var iu = { decodeText: function(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]); return decodeURIComponent(escape(t)) }, extractUrlBase: function(e) { var t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } };

            function ou(e) { "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : qa, this.withCredentials = !1 }

            function au(e) { this.manager = void 0 !== e ? e : qa, this.texturePath = "" }
            Object.assign(ou.prototype, {
                crossOrigin: "anonymous",
                load: function(e, t, n, r) {
                    var i = this,
                        o = void 0 === this.path ? iu.extractUrlBase(e) : this.path,
                        a = new Za(this.manager);
                    a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(e, function(n) {
                        var r = JSON.parse(n),
                            a = r.metadata;
                        if (void 0 !== a) { var s = a.type; if (void 0 !== s && "object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.") }
                        var u = i.parse(r, o);
                        t(u.geometry, u.materials)
                    }, n, r)
                },
                setPath: function(e) { return this.path = e, this },
                setResourcePath: function(e) { return this.resourcePath = e, this },
                setCrossOrigin: function(e) { return this.crossOrigin = e, this },
                parse: function() {
                    return function(e, t) {
                        void 0 !== e.data && (e = e.data), void 0 !== e.scale ? e.scale = 1 / e.scale : e.scale = 1;
                        var n = new jn;
                        return function(e, t) {
                                function n(e, t) { return e & 1 << t }
                                var r, i, o, a, s, u, c, l, h, p, d, f, m, v, g, y, _, x, b, w, M, E, S, T, A, P = e.faces,
                                    R = e.vertices,
                                    L = e.normals,
                                    C = e.colors,
                                    O = e.scale,
                                    I = 0;
                                if (void 0 !== e.uvs) { for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && I++; for (r = 0; r < I; r++) t.faceVertexUvs[r] = [] }
                                for (a = 0, s = R.length; a < s;)(x = new Qt).x = R[a++] * O, x.y = R[a++] * O, x.z = R[a++] * O, t.vertices.push(x);
                                for (a = 0, s = P.length; a < s;)
                                    if (d = n(p = P[a++], 0), f = n(p, 1), m = n(p, 3), v = n(p, 4), g = n(p, 5), y = n(p, 6), _ = n(p, 7), d) {
                                        if ((w = new Ln).a = P[a], w.b = P[a + 1], w.c = P[a + 3], (M = new Ln).a = P[a + 1], M.b = P[a + 2], M.c = P[a + 3], a += 4, f && (h = P[a++], w.materialIndex = h, M.materialIndex = h), o = t.faces.length, m)
                                            for (r = 0; r < I; r++)
                                                for (T = e.uvs[r], t.faceVertexUvs[r][o] = [], t.faceVertexUvs[r][o + 1] = [], i = 0; i < 4; i++) A = new Jt(T[2 * (l = P[a++])], T[2 * l + 1]), 2 !== i && t.faceVertexUvs[r][o].push(A), 0 !== i && t.faceVertexUvs[r][o + 1].push(A);
                                        if (v && (c = 3 * P[a++], w.normal.set(L[c++], L[c++], L[c]), M.normal.copy(w.normal)), g)
                                            for (r = 0; r < 4; r++) c = 3 * P[a++], S = new Qt(L[c++], L[c++], L[c]), 2 !== r && w.vertexNormals.push(S), 0 !== r && M.vertexNormals.push(S);
                                        if (y && (E = C[u = P[a++]], w.color.setHex(E), M.color.setHex(E)), _)
                                            for (r = 0; r < 4; r++) E = C[u = P[a++]], 2 !== r && w.vertexColors.push(new En(E)), 0 !== r && M.vertexColors.push(new En(E));
                                        t.faces.push(w), t.faces.push(M)
                                    } else {
                                        if ((b = new Ln).a = P[a++], b.b = P[a++], b.c = P[a++], f && (h = P[a++], b.materialIndex = h), o = t.faces.length, m)
                                            for (r = 0; r < I; r++)
                                                for (T = e.uvs[r], t.faceVertexUvs[r][o] = [], i = 0; i < 3; i++) A = new Jt(T[2 * (l = P[a++])], T[2 * l + 1]), t.faceVertexUvs[r][o].push(A);
                                        if (v && (c = 3 * P[a++], b.normal.set(L[c++], L[c++], L[c])), g)
                                            for (r = 0; r < 3; r++) c = 3 * P[a++], S = new Qt(L[c++], L[c++], L[c]), b.vertexNormals.push(S);
                                        if (y && (u = P[a++], b.color.setHex(C[u])), _)
                                            for (r = 0; r < 3; r++) u = P[a++], b.vertexColors.push(new En(C[u]));
                                        t.faces.push(b)
                                    }
                            }(e, n),
                            function(e, t) {
                                var n = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                                if (e.skinWeights)
                                    for (var r = 0, i = e.skinWeights.length; r < i; r += n) {
                                        var o = e.skinWeights[r],
                                            a = n > 1 ? e.skinWeights[r + 1] : 0,
                                            s = n > 2 ? e.skinWeights[r + 2] : 0,
                                            u = n > 3 ? e.skinWeights[r + 3] : 0;
                                        t.skinWeights.push(new ln(o, a, s, u))
                                    }
                                if (e.skinIndices)
                                    for (r = 0, i = e.skinIndices.length; r < i; r += n) {
                                        var c = e.skinIndices[r],
                                            l = n > 1 ? e.skinIndices[r + 1] : 0,
                                            h = n > 2 ? e.skinIndices[r + 2] : 0,
                                            p = n > 3 ? e.skinIndices[r + 3] : 0;
                                        t.skinIndices.push(new ln(c, l, h, p))
                                    }
                                t.bones = e.bones, t.bones && t.bones.length > 0 && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match.")
                            }(e, n),
                            function(e, t) {
                                var n = e.scale;
                                if (void 0 !== e.morphTargets)
                                    for (var r = 0, i = e.morphTargets.length; r < i; r++) {
                                        t.morphTargets[r] = {}, t.morphTargets[r].name = e.morphTargets[r].name, t.morphTargets[r].vertices = [];
                                        for (var o = t.morphTargets[r].vertices, a = e.morphTargets[r].vertices, s = 0, u = a.length; s < u; s += 3) {
                                            var c = new Qt;
                                            c.x = a[s] * n, c.y = a[s + 1] * n, c.z = a[s + 2] * n, o.push(c)
                                        }
                                    }
                                if (void 0 !== e.morphColors && e.morphColors.length > 0) {
                                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                                    var l = t.faces,
                                        h = e.morphColors[0].colors;
                                    for (r = 0, i = l.length; r < i; r++) l[r].color.fromArray(h, 3 * r)
                                }
                            }(e, n),
                            function(e, t) {
                                var n = [],
                                    r = [];
                                void 0 !== e.animation && r.push(e.animation), void 0 !== e.animations && (e.animations.length ? r = r.concat(e.animations) : r.push(e.animations));
                                for (var i = 0; i < r.length; i++) {
                                    var o = Ys.parseAnimation(r[i], t.bones);
                                    o && n.push(o)
                                }
                                if (t.morphTargets) {
                                    var a = Ys.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
                                    n = n.concat(a)
                                }
                                n.length > 0 && (t.animations = n)
                            }(e, n), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length ? { geometry: n } : { geometry: n, materials: ru.prototype.initMaterials(e.materials, this.resourcePath || t, this.crossOrigin) }
                    }
                }()
            }), Object.assign(au.prototype, {
                crossOrigin: "anonymous",
                load: function(e, t, n, r) {
                    "" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
                    var i = this;
                    new Za(i.manager).load(e, function(n) {
                        var o = null;
                        try { o = JSON.parse(n) } catch (t) { return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message) }
                        var a = o.metadata;
                        void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(o, t) : console.error("THREE.ObjectLoader: Can't load " + e + ". Use THREE.JSONLoader instead.")
                    }, n, r)
                },
                setTexturePath: function(e) { return this.texturePath = e, this },
                setCrossOrigin: function(e) { return this.crossOrigin = e, this },
                parse: function(e, t) {
                    var n = this.parseShape(e.shapes),
                        r = this.parseGeometries(e.geometries, n),
                        i = this.parseImages(e.images, function() { void 0 !== t && t(s) }),
                        o = this.parseTextures(e.textures, i),
                        a = this.parseMaterials(e.materials, o),
                        s = this.parseObject(e.object, r, a);
                    return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
                },
                parseShape: function(e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = 0, r = e.length; n < r; n++) {
                            var i = (new Ms).fromJSON(e[n]);
                            t[i.uuid] = i
                        }
                    return t
                },
                parseGeometries: function(e, t) {
                    var n = {};
                    if (void 0 !== e)
                        for (var r = new ou, i = new Ks, o = 0, a = e.length; o < a; o++) {
                            var s, u = e[o];
                            switch (u.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new Ia[u.type](u.width, u.height, u.widthSegments, u.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new Ia[u.type](u.width, u.height, u.depth, u.widthSegments, u.heightSegments, u.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new Ia[u.type](u.radius, u.segments, u.thetaStart, u.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new Ia[u.type](u.radiusTop, u.radiusBottom, u.height, u.radialSegments, u.heightSegments, u.openEnded, u.thetaStart, u.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new Ia[u.type](u.radius, u.height, u.radialSegments, u.heightSegments, u.openEnded, u.thetaStart, u.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new Ia[u.type](u.radius, u.widthSegments, u.heightSegments, u.phiStart, u.phiLength, u.thetaStart, u.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new Ia[u.type](u.radius, u.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new Ia[u.type](u.innerRadius, u.outerRadius, u.thetaSegments, u.phiSegments, u.thetaStart, u.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new Ia[u.type](u.radius, u.tube, u.radialSegments, u.tubularSegments, u.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new Ia[u.type](u.radius, u.tube, u.tubularSegments, u.radialSegments, u.p, u.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new Ia[u.type](u.points, u.segments, u.phiStart, u.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new Ia[u.type](u.vertices, u.indices, u.radius, u.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var c = [], l = 0, h = u.shapes.length; l < h; l++) {
                                        var p = t[u.shapes[l]];
                                        c.push(p)
                                    }
                                    s = new Ia[u.type](c, u.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (c = [], l = 0, h = u.shapes.length; l < h; l++) {
                                        p = t[u.shapes[l]];
                                        c.push(p)
                                    }
                                    var d = u.options.extrudePath;
                                    void 0 !== d && (u.options.extrudePath = (new xs[d.type]).fromJSON(d)), s = new Ia[u.type](c, u.options);
                                    break;
                                case "BufferGeometry":
                                    s = i.parse(u);
                                    break;
                                case "Geometry":
                                    s = r.parse(u, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + u.type + '"');
                                    continue
                            }
                            s.uuid = u.uuid, void 0 !== u.name && (s.name = u.name), !0 === s.isBufferGeometry && void 0 !== u.userData && (s.userData = u.userData), n[u.uuid] = s
                        }
                    return n
                },
                parseMaterials: function(e, t) {
                    var n = {};
                    if (void 0 !== e) {
                        var r = new Js;
                        r.setTextures(t);
                        for (var i = 0, o = e.length; i < o; i++) {
                            var a = e[i];
                            if ("MultiMaterial" === a.type) {
                                for (var s = [], u = 0; u < a.materials.length; u++) s.push(r.parse(a.materials[u]));
                                n[a.uuid] = s
                            } else n[a.uuid] = r.parse(a)
                        }
                    }
                    return n
                },
                parseAnimations: function(e) {
                    for (var t = [], n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = Ys.parse(r);
                        void 0 !== r.uuid && (i.uuid = r.uuid), t.push(i)
                    }
                    return t
                },
                parseImages: function(e, t) {
                    var n = this,
                        r = {};

                    function i(e) { return n.manager.itemStart(e), o.load(e, function() { n.manager.itemEnd(e) }, void 0, function() { n.manager.itemEnd(e), n.manager.itemError(e) }) }
                    if (void 0 !== e && e.length > 0) {
                        var o = new $a(new Xa(t));
                        o.setCrossOrigin(this.crossOrigin);
                        for (var a = 0, s = e.length; a < s; a++) {
                            var u = e[a],
                                c = u.url;
                            if (Array.isArray(c)) {
                                r[u.uuid] = [];
                                for (var l = 0, h = c.length; l < h; l++) {
                                    var p = c[l],
                                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.texturePath + p;
                                    r[u.uuid].push(i(d))
                                }
                            } else {
                                d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u.url) ? u.url : n.texturePath + u.url;
                                r[u.uuid] = i(d)
                            }
                        }
                    }
                    return r
                },
                parseTextures: function(e, t) {
                    function n(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) }
                    var r = {};
                    if (void 0 !== e)
                        for (var i = 0, o = e.length; i < o; i++) {
                            var a, s = e[i];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(t[s.image]) ? new Ar(t[s.image]) : new cn(t[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, uu)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], cu), a.wrapT = n(s.wrap[1], cu)), void 0 !== s.format && (a.format = s.format), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, lu)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, lu)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), r[s.uuid] = a
                        }
                    return r
                },
                parseObject: function(e, t, n) {
                    var r;

                    function i(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] }

                    function o(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                for (var t = [], r = 0, i = e.length; r < i; r++) {
                                    var o = e[r];
                                    void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(n[o])
                                }
                                return t
                            }
                            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                        }
                    }
                    switch (e.type) {
                        case "Scene":
                            r = new to, void 0 !== e.background && Number.isInteger(e.background) && (r.background = new En(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? r.fog = new eo(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (r.fog = new Qi(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            r = new Zi(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (r.focus = e.focus), void 0 !== e.zoom && (r.zoom = e.zoom), void 0 !== e.filmGauge && (r.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (r.filmOffset = e.filmOffset), void 0 !== e.view && (r.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            r = new Ls(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (r.zoom = e.zoom), void 0 !== e.view && (r.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            r = new Is(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            r = new Os(e.color, e.intensity);
                            break;
                        case "PointLight":
                            r = new Rs(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            r = new Ds(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            r = new Ps(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            r = new Ss(e.color, e.groundColor, e.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = i(e.geometry),
                                s = o(e.material);
                            r = a.bones && a.bones.length > 0 ? new co(a, s) : new Sr(a, s);
                            break;
                        case "LOD":
                            r = new ao;
                            break;
                        case "Line":
                            r = new ho(i(e.geometry), o(e.material), e.mode);
                            break;
                        case "LineLoop":
                            r = new fo(i(e.geometry), o(e.material));
                            break;
                        case "LineSegments":
                            r = new po(i(e.geometry), o(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            r = new vo(i(e.geometry), o(e.material));
                            break;
                        case "Sprite":
                            r = new oo(o(e.material));
                            break;
                        case "Group":
                            r = new qi;
                            break;
                        default:
                            r = new Bn
                    }
                    if (r.uuid = e.uuid, void 0 !== e.name && (r.name = e.name), void 0 !== e.matrix ? (r.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (r.matrixAutoUpdate = e.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== e.position && r.position.fromArray(e.position), void 0 !== e.rotation && r.rotation.fromArray(e.rotation), void 0 !== e.quaternion && r.quaternion.fromArray(e.quaternion), void 0 !== e.scale && r.scale.fromArray(e.scale)), void 0 !== e.castShadow && (r.castShadow = e.castShadow), void 0 !== e.receiveShadow && (r.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (r.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (r.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && r.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (r.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.frustumCulled && (r.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (r.renderOrder = e.renderOrder), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.layers && (r.layers.mask = e.layers), void 0 !== e.children)
                        for (var u = e.children, c = 0; c < u.length; c++) r.add(this.parseObject(u[c], t, n));
                    if ("LOD" === e.type)
                        for (var l = e.levels, h = 0; h < l.length; h++) {
                            var p = l[h],
                                d = r.getObjectByProperty("uuid", p.object);
                            void 0 !== d && r.addLevel(d, p.distance)
                        }
                    return r
                }
            });
            var su, uu = { UVMapping: ye, CubeReflectionMapping: _e, CubeRefractionMapping: xe, EquirectangularReflectionMapping: be, EquirectangularRefractionMapping: we, SphericalReflectionMapping: Me, CubeUVReflectionMapping: Ee, CubeUVRefractionMapping: Se },
                cu = { RepeatWrapping: Te, ClampToEdgeWrapping: Ae, MirroredRepeatWrapping: Pe },
                lu = { NearestFilter: Re, NearestMipMapNearestFilter: Le, NearestMipMapLinearFilter: Ce, LinearFilter: Oe, LinearMipMapNearestFilter: Ie, LinearMipMapLinearFilter: De };

            function hu(e) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : qa, this.options = void 0 }

            function pu() { this.type = "ShapePath", this.color = new En, this.subPaths = [], this.currentPath = null }

            function du(e) { this.type = "Font", this.data = e }

            function fu(e, t, n, r, i) {
                var o = i.glyphs[e] || i.glyphs["?"];
                if (o) {
                    var a, s, u, c, l, h, p, d, f = new pu;
                    if (o.o)
                        for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g;) {
                            switch (m[v++]) {
                                case "m":
                                    a = m[v++] * t + n, s = m[v++] * t + r, f.moveTo(a, s);
                                    break;
                                case "l":
                                    a = m[v++] * t + n, s = m[v++] * t + r, f.lineTo(a, s);
                                    break;
                                case "q":
                                    u = m[v++] * t + n, c = m[v++] * t + r, l = m[v++] * t + n, h = m[v++] * t + r, f.quadraticCurveTo(l, h, u, c);
                                    break;
                                case "b":
                                    u = m[v++] * t + n, c = m[v++] * t + r, l = m[v++] * t + n, h = m[v++] * t + r, p = m[v++] * t + n, d = m[v++] * t + r, f.bezierCurveTo(l, h, p, d, u, c)
                            }
                        }
                    return { offsetX: o.ha * t, path: f }
                }
            }

            function mu(e) { this.manager = void 0 !== e ? e : qa }
            hu.prototype = {
                constructor: hu,
                setOptions: function(e) { return this.options = e, this },
                load: function(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var i = this,
                        o = Wa.get(e);
                    if (void 0 !== o) return i.manager.itemStart(e), setTimeout(function() { t && t(o), i.manager.itemEnd(e) }, 0), o;
                    fetch(e).then(function(e) { return e.blob() }).then(function(e) { return createImageBitmap(e, i.options) }).then(function(n) { Wa.add(e, n), t && t(n), i.manager.itemEnd(e) }).catch(function(t) { r && r(t), i.manager.itemEnd(e), i.manager.itemError(e) })
                },
                setCrossOrigin: function() { return this },
                setPath: function(e) { return this.path = e, this }
            }, Object.assign(pu.prototype, {
                moveTo: function(e, t) { this.currentPath = new ws, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t) },
                lineTo: function(e, t) { this.currentPath.lineTo(e, t) },
                quadraticCurveTo: function(e, t, n, r) { this.currentPath.quadraticCurveTo(e, t, n, r) },
                bezierCurveTo: function(e, t, n, r, i, o) { this.currentPath.bezierCurveTo(e, t, n, r, i, o) },
                splineThru: function(e) { this.currentPath.splineThru(e) },
                toShapes: function(e, t) {
                    function n(e) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var i = e[n],
                                o = new Ms;
                            o.curves = i.curves, t.push(o)
                        }
                        return t
                    }

                    function r(e, t) {
                        for (var n = t.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                            var a = t[i],
                                s = t[o],
                                u = s.x - a.x,
                                c = s.y - a.y;
                            if (Math.abs(c) > Number.EPSILON) {
                                if (c < 0 && (a = t[o], u = -u, s = t[i], c = -c), e.y < a.y || e.y > s.y) continue;
                                if (e.y === a.y) { if (e.x === a.x) return !0 } else {
                                    var l = c * (e.x - a.x) - u * (e.y - a.y);
                                    if (0 === l) return !0;
                                    if (l < 0) continue;
                                    r = !r
                                }
                            } else { if (e.y !== a.y) continue; if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0 }
                        }
                        return r
                    }
                    var i = ua.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === t) return n(o);
                    var a, s, u, c = [];
                    if (1 === o.length) return s = o[0], (u = new Ms).curves = s.curves, c.push(u), c;
                    var l = !i(o[0].getPoints());
                    l = e ? !l : l;
                    var h, p, d = [],
                        f = [],
                        m = [],
                        v = 0;
                    f[v] = void 0, m[v] = [];
                    for (var g = 0, y = o.length; g < y; g++) a = i(h = (s = o[g]).getPoints()), (a = e ? !a : a) ? (!l && f[v] && v++, f[v] = { s: new Ms, p: h }, f[v].s.curves = s.curves, l && v++, m[v] = []) : m[v].push({ h: s, p: h[0] });
                    if (!f[0]) return n(o);
                    if (f.length > 1) {
                        for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) d[b] = [];
                        for (b = 0, w = f.length; b < w; b++)
                            for (var M = m[b], E = 0; E < M.length; E++) {
                                for (var S = M[E], T = !0, A = 0; A < f.length; A++) r(S.p, f[A].p) && (b !== A && x.push({ froms: b, tos: A, hole: E }), T ? (T = !1, d[A].push(S)) : _ = !0);
                                T && d[b].push(S)
                            }
                        x.length > 0 && (_ || (m = d))
                    }
                    g = 0;
                    for (var P = f.length; g < P; g++) { u = f[g].s, c.push(u); for (var R = 0, L = (p = m[g]).length; R < L; R++) u.holes.push(p[R].h) }
                    return c
                }
            }), Object.assign(du.prototype, {
                isFont: !0,
                generateShapes: function(e, t) {
                    void 0 === t && (t = 100);
                    for (var n = [], r = function(e, t, n) {
                            for (var r = Array.from ? Array.from(e) : String(e).split(""), i = t / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, a = [], s = 0, u = 0, c = 0; c < r.length; c++) {
                                var l = r[c];
                                if ("\n" === l) s = 0, u -= o;
                                else {
                                    var h = fu(l, i, s, u, n);
                                    s += h.offsetX, a.push(h.path)
                                }
                            }
                            return a
                        }(e, t, this.data), i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
                    return n
                }
            }), Object.assign(mu.prototype, {
                load: function(e, t, n, r) {
                    var i = this,
                        o = new Za(this.manager);
                    o.setPath(this.path), o.load(e, function(e) {
                        var n;
                        try { n = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2)) }
                        var r = i.parse(n);
                        t && t(r)
                    }, n, r)
                },
                parse: function(e) { return new du(e) },
                setPath: function(e) { return this.path = e, this }
            });
            var vu, gu, yu, _u, xu, bu, wu, Mu, Eu, Su, Tu = { getContext: function() { return void 0 === su && (su = new(window.AudioContext || window.webkitAudioContext)), su }, setContext: function(e) { su = e } };

            function Au(e) { this.manager = void 0 !== e ? e : qa }

            function Pu() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Zi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Zi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1 }

            function Ru(e, t, n) {
                Bn.call(this), this.type = "CubeCamera";
                var r = new Zi(90, 1, e, t);
                r.up.set(0, -1, 0), r.lookAt(new Qt(1, 0, 0)), this.add(r);
                var i = new Zi(90, 1, e, t);
                i.up.set(0, -1, 0), i.lookAt(new Qt(-1, 0, 0)), this.add(i);
                var o = new Zi(90, 1, e, t);
                o.up.set(0, 0, 1), o.lookAt(new Qt(0, 1, 0)), this.add(o);
                var a = new Zi(90, 1, e, t);
                a.up.set(0, 0, -1), a.lookAt(new Qt(0, -1, 0)), this.add(a);
                var s = new Zi(90, 1, e, t);
                s.up.set(0, -1, 0), s.lookAt(new Qt(0, 0, 1)), this.add(s);
                var u = new Zi(90, 1, e, t);
                u.up.set(0, -1, 0), u.lookAt(new Qt(0, 0, -1)), this.add(u);
                var c = { format: Ye, magFilter: Oe, minFilter: Oe };
                this.renderTarget = new pn(n, n, c), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = this.renderTarget,
                        c = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, r, n), n.activeCubeFace = 1, e.render(t, i, n), n.activeCubeFace = 2, e.render(t, o, n), n.activeCubeFace = 3, e.render(t, a, n), n.activeCubeFace = 4, e.render(t, s, n), n.texture.generateMipmaps = c, n.activeCubeFace = 5, e.render(t, u, n), e.setRenderTarget(null)
                }, this.clear = function(e, t, n, r) {
                    for (var i = this.renderTarget, o = 0; o < 6; o++) i.activeCubeFace = o, e.setRenderTarget(i), e.clear(t, n, r);
                    e.setRenderTarget(null)
                }
            }

            function Lu() { Bn.call(this), this.type = "AudioListener", this.context = Tu.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null }

            function Cu(e) { Bn.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [] }

            function Ou(e) { Cu.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain) }

            function Iu(e, t) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) }

            function Du(e, t, n) {
                this.binding = e, this.valueSize = n;
                var r, i = Float64Array;
                switch (t) {
                    case "quaternion":
                        r = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        i = Array, r = this._select;
                        break;
                    default:
                        r = this._lerp
                }
                this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(Au.prototype, {
                load: function(e, t, n, r) {
                    var i = new Za(this.manager);
                    i.setResponseType("arraybuffer"), i.load(e, function(e) {
                        var n = e.slice(0);
                        Tu.getContext().decodeAudioData(n, function(e) { t(e) })
                    }, n, r)
                }
            }), Object.assign(Pu.prototype, {
                update: (Eu = new Kt, Su = new Kt, function(e) {
                    if (vu !== this || gu !== e.focus || yu !== e.fov || _u !== e.aspect * this.aspect || xu !== e.near || bu !== e.far || wu !== e.zoom || Mu !== this.eyeSep) {
                        vu = this, gu = e.focus, yu = e.fov, _u = e.aspect * this.aspect, xu = e.near, bu = e.far, wu = e.zoom;
                        var t, n, r = e.projectionMatrix.clone(),
                            i = (Mu = this.eyeSep / 2) * xu / gu,
                            o = xu * Math.tan(Zt.DEG2RAD * yu * .5) / wu;
                        Su.elements[12] = -Mu, Eu.elements[12] = Mu, t = -o * _u + i, n = o * _u + i, r.elements[0] = 2 * xu / (n - t), r.elements[8] = (n + t) / (n - t), this.cameraL.projectionMatrix.copy(r), t = -o * _u - i, n = o * _u - i, r.elements[0] = 2 * xu / (n - t), r.elements[8] = (n + t) / (n - t), this.cameraR.projectionMatrix.copy(r)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Su), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Eu)
                })
            }), Ru.prototype = Object.create(Bn.prototype), Ru.prototype.constructor = Ru, Lu.prototype = Object.assign(Object.create(Bn.prototype), {
                constructor: Lu,
                getInput: function() { return this.gain },
                removeFilter: function() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this },
                getFilter: function() { return this.filter },
                setFilter: function(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this },
                getMasterVolume: function() { return this.gain.gain.value },
                setMasterVolume: function(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this },
                updateMatrixWorld: function() {
                    var e = new Qt,
                        t = new $t,
                        n = new Qt,
                        r = new Qt;
                    return function(i) {
                        Bn.prototype.updateMatrixWorld.call(this, i);
                        var o = this.context.listener,
                            a = this.up;
                        this.matrixWorld.decompose(e, t, n), r.set(0, 0, -1).applyQuaternion(t), o.positionX ? (o.positionX.setValueAtTime(e.x, this.context.currentTime), o.positionY.setValueAtTime(e.y, this.context.currentTime), o.positionZ.setValueAtTime(e.z, this.context.currentTime), o.forwardX.setValueAtTime(r.x, this.context.currentTime), o.forwardY.setValueAtTime(r.y, this.context.currentTime), o.forwardZ.setValueAtTime(r.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(e.x, e.y, e.z), o.setOrientation(r.x, r.y, r.z, a.x, a.y, a.z))
                    }
                }()
            }), Cu.prototype = Object.assign(Object.create(Bn.prototype), {
                constructor: Cu,
                getOutput: function() { return this.gain },
                setNodeSource: function(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this },
                setMediaElementSource: function(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this },
                setBuffer: function(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this },
                play: function() {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) { var e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.connect() }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() { return this.filters },
                setFilters: function(e) { return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this },
                getFilter: function() { return this.getFilters()[0] },
                setFilter: function(e) { return this.setFilters(e ? [e] : []) },
                setPlaybackRate: function(e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() { return this.playbackRate },
                onEnded: function() { this.isPlaying = !1 },
                getLoop: function() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop },
                setLoop: function(e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() { return this.gain.gain.value },
                setVolume: function(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this }
            }), Ou.prototype = Object.assign(Object.create(Cu.prototype), {
                constructor: Ou,
                getOutput: function() { return this.panner },
                getRefDistance: function() { return this.panner.refDistance },
                setRefDistance: function(e) { return this.panner.refDistance = e, this },
                getRolloffFactor: function() { return this.panner.rolloffFactor },
                setRolloffFactor: function(e) { return this.panner.rolloffFactor = e, this },
                getDistanceModel: function() { return this.panner.distanceModel },
                setDistanceModel: function(e) { return this.panner.distanceModel = e, this },
                getMaxDistance: function() { return this.panner.maxDistance },
                setMaxDistance: function(e) { return this.panner.maxDistance = e, this },
                setDirectionalCone: function(e, t, n) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this },
                updateMatrixWorld: function() {
                    var e = new Qt,
                        t = new $t,
                        n = new Qt,
                        r = new Qt;
                    return function(i) {
                        Bn.prototype.updateMatrixWorld.call(this, i);
                        var o = this.panner;
                        this.matrixWorld.decompose(e, t, n), r.set(0, 0, 1).applyQuaternion(t), o.setPosition(e.x, e.y, e.z), o.setOrientation(r.x, r.y, r.z)
                    }
                }()
            }), Object.assign(Iu.prototype, { getFrequencyData: function() { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function() { for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n]; return e / t.length } }), Object.assign(Du.prototype, {
                accumulate: function(e, t) {
                    var n = this.buffer,
                        r = this.valueSize,
                        i = e * r + r,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                        o = t
                    } else {
                        var s = t / (o += t);
                        this._mixBufferRegion(n, i, 0, s, r)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(e) {
                    var t = this.valueSize,
                        n = this.buffer,
                        r = e * t + t,
                        i = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, i < 1) {
                        var a = 3 * t;
                        this._mixBufferRegion(n, r, a, 1 - i, t)
                    }
                    for (var s = t, u = t + t; s !== u; ++s)
                        if (n[s] !== n[s + t]) { o.setValue(n, r); break }
                },
                saveOriginalState: function() {
                    var e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        r = 3 * n;
                    e.getValue(t, r);
                    for (var i = n, o = r; i !== o; ++i) t[i] = t[r + i % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                },
                _select: function(e, t, n, r, i) {
                    if (r >= .5)
                        for (var o = 0; o !== i; ++o) e[t + o] = e[n + o]
                },
                _slerp: function(e, t, n, r) { $t.slerpFlat(e, t, e, t, e, n, r) },
                _lerp: function(e, t, n, r, i) {
                    for (var o = 1 - r, a = 0; a !== i; ++a) {
                        var s = t + a;
                        e[s] = e[s] * o + e[n + a] * r
                    }
                }
            });
            var Uu, Fu, Nu, Bu, zu, ku, Gu, ju, Hu, Vu, Wu, Xu, qu, Yu, Zu;

            function Ju(e, t, n) {
                var r = n || Ku.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, r)
            }

            function Ku(e, t, n) { this.path = t, this.parsedPath = n || Ku.parseTrackName(t), this.node = Ku.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e }

            function $u() {
                this.uuid = Zt.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var e = {};
                this._indicesByUUID = e;
                for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var r = this;
                this.stats = { objects: {get total() { return r._objects.length }, get inUse() { return this.total - r.nCachedObjects_ } }, get bindingsPerObject() { return r._bindings.length } }
            }

            function Qu(e, t, n) {
                this._mixer = e, this._clip = t, this._localRoot = n || null;
                for (var r = t.tracks, i = r.length, o = new Array(i), a = { endingStart: Ct, endingEnd: Ct }, s = 0; s !== i; ++s) {
                    var u = r[s].createInterpolant(null);
                    o[s] = u, u.settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Tt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function ec(e) { this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 }

            function tc(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e }

            function nc() { nr.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0 }

            function rc(e, t, n) { no.call(this, e, t), this.meshPerAttribute = n || 1 }

            function ic(e, t, n, r) { "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Hn.call(this, e, t, n), this.meshPerAttribute = r || 1 }

            function oc(e, t, n, r) { this.ray = new wr(e, t), this.near = n || 0, this.far = r || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) }

            function ac(e, t) { return e.distance - t.distance }

            function sc(e, t, n, r) {
                if (!1 !== e.visible && (e.raycast(t, n), !0 === r))
                    for (var i = e.children, o = 0, a = i.length; o < a; o++) sc(i[o], t, n, !0)
            }

            function uc(e) { this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 }

            function cc(e, t, n) { return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this }

            function lc(e, t, n) { return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this }

            function hc(e, t) { this.min = void 0 !== e ? e : new Jt(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Jt(-1 / 0, -1 / 0) }

            function pc(e, t) { this.start = void 0 !== e ? e : new Qt, this.end = void 0 !== t ? t : new Qt }

            function dc(e) { Bn.call(this), this.material = e, this.render = function() {} }

            function fc(e, t, n, r) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var i = void 0 !== n ? n : 16711680,
                    o = void 0 !== r ? r : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var u = new nr,
                    c = new Kn(2 * a * 3, 3);
                u.addAttribute("position", c), po.call(this, u, new lo({ color: i, linewidth: o })), this.matrixAutoUpdate = !1, this.update()
            }

            function mc(e, t) {
                Bn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                for (var n = new nr, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++, o++) {
                    var a = i / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.addAttribute("position", new Kn(r, 3));
                var u = new lo({ fog: !1 });
                this.cone = new po(n, u), this.add(this.cone), this.update()
            }

            function vc(e) {
                for (var t = function e(t) {
                        var n = [];
                        t && t.isBone && n.push(t);
                        for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                        return n
                    }(e), n = new nr, r = [], i = [], o = new En(0, 0, 1), a = new En(0, 1, 0), s = 0; s < t.length; s++) {
                    var u = t[s];
                    u.parent && u.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
                }
                n.addAttribute("position", new Kn(r, 3)), n.addAttribute("color", new Kn(i, 3));
                var c = new lo({ vertexColors: I, depthTest: !1, depthWrite: !1, transparent: !0 });
                po.call(this, n, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }

            function gc(e, t, n) {
                this.light = e, this.light.updateMatrixWorld(), this.color = n;
                var r = new ya(t, 4, 2),
                    i = new Er({ wireframe: !0, fog: !1 });
                Sr.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function yc(e, t) {
                Bn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                var n = new lo({ fog: !1 }),
                    r = new nr;
                r.addAttribute("position", new Hn(new Float32Array(15), 3)), this.line = new ho(r, n), this.add(this.line), this.update()
            }

            function _c(e, t, n) {
                Bn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var r = new Ro(t);
                r.rotateY(.5 * Math.PI), this.material = new Er({ wireframe: !0, fog: !1 }), void 0 === this.color && (this.material.vertexColors = I);
                var i = r.getAttribute("position"),
                    o = new Float32Array(3 * i.count);
                r.addAttribute("color", new Hn(o, 3)), this.add(new Sr(r, this.material)), this.update()
            }

            function xc(e, t, n, r) {
                e = e || 10, t = t || 10, n = new En(void 0 !== n ? n : 4473924), r = new En(void 0 !== r ? r : 8947848);
                for (var i = t / 2, o = e / t, a = e / 2, s = [], u = [], c = 0, l = 0, h = -a; c <= t; c++, h += o) {
                    s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                    var p = c === i ? n : r;
                    p.toArray(u, l), l += 3, p.toArray(u, l), l += 3, p.toArray(u, l), l += 3, p.toArray(u, l), l += 3
                }
                var d = new nr;
                d.addAttribute("position", new Kn(s, 3)), d.addAttribute("color", new Kn(u, 3));
                var f = new lo({ vertexColors: I });
                po.call(this, d, f)
            }

            function bc(e, t, n, r, i, o) {
                e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new En(void 0 !== i ? i : 4473924), o = new En(void 0 !== o ? o : 8947848);
                var a, s, u, c, l, h, p, d = [],
                    f = [];
                for (c = 0; c <= t; c++) u = c / t * (2 * Math.PI), a = Math.sin(u) * e, s = Math.cos(u) * e, d.push(0, 0, 0), d.push(a, 0, s), p = 1 & c ? i : o, f.push(p.r, p.g, p.b), f.push(p.r, p.g, p.b);
                for (c = 0; c <= n; c++)
                    for (p = 1 & c ? i : o, h = e - e / n * c, l = 0; l < r; l++) u = l / r * (2 * Math.PI), a = Math.sin(u) * h, s = Math.cos(u) * h, d.push(a, 0, s), f.push(p.r, p.g, p.b), u = (l + 1) / r * (2 * Math.PI), a = Math.sin(u) * h, s = Math.cos(u) * h, d.push(a, 0, s), f.push(p.r, p.g, p.b);
                var m = new nr;
                m.addAttribute("position", new Kn(d, 3)), m.addAttribute("color", new Kn(f, 3));
                var v = new lo({ vertexColors: I });
                po.call(this, m, v)
            }

            function wc(e, t, n, r) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var i = void 0 !== n ? n : 16776960,
                    o = void 0 !== r ? r : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var u = new nr,
                    c = new Kn(2 * a * 3, 3);
                u.addAttribute("position", c), po.call(this, u, new lo({ color: i, linewidth: o })), this.matrixAutoUpdate = !1, this.update()
            }

            function Mc(e, t, n) {
                Bn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                var r = new nr;
                r.addAttribute("position", new Kn([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                var i = new lo({ fog: !1 });
                this.lightPlane = new ho(r, i), this.add(this.lightPlane), (r = new nr).addAttribute("position", new Kn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ho(r, i), this.add(this.targetLine), this.update()
            }

            function Ec(e) {
                var t = new nr,
                    n = new lo({ color: 16777215, vertexColors: O }),
                    r = [],
                    i = [],
                    o = {},
                    a = new En(16755200),
                    s = new En(16711680),
                    u = new En(43775),
                    c = new En(16777215),
                    l = new En(3355443);

                function h(e, t, n) { p(e, n), p(t, n) }

                function p(e, t) { r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === o[e] && (o[e] = []), o[e].push(r.length / 3 - 1) }
                h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", u), h("u2", "u3", u), h("u3", "u1", u), h("c", "t", c), h("p", "c", l), h("cn1", "cn2", l), h("cn3", "cn4", l), h("cf1", "cf2", l), h("cf3", "cf4", l), t.addAttribute("position", new Kn(r, 3)), t.addAttribute("color", new Kn(i, 3)), po.call(this, t, n), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function Sc(e, t) {
                this.object = e, void 0 === t && (t = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new nr;
                i.setIndex(new Hn(n, 1)), i.addAttribute("position", new Hn(r, 3)), po.call(this, i, new lo({ color: t })), this.matrixAutoUpdate = !1, this.update()
            }

            function Tc(e, t) {
                this.type = "Box3Helper", this.box = e;
                var n = void 0 !== t ? t : 16776960,
                    r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new nr;
                i.setIndex(new Hn(r, 1)), i.addAttribute("position", new Kn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), po.call(this, i, new lo({ color: n })), this.geometry.computeBoundingSphere()
            }

            function Ac(e, t, n) {
                this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
                var r = void 0 !== n ? n : 16776960,
                    i = new nr;
                i.addAttribute("position", new Kn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), ho.call(this, i, new lo({ color: r }));
                var o = new nr;
                o.addAttribute("position", new Kn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Sr(o, new Er({ color: r, opacity: .2, transparent: !0, depthWrite: !1 })))
            }

            function Pc(e, t, n, r, i, o) { Bn.call(this), void 0 === r && (r = 16776960), void 0 === n && (n = 1), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === Xu && ((Xu = new nr).addAttribute("position", new Kn([0, 0, 0, 0, 1, 0], 3)), (qu = new Pa(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new ho(Xu, new lo({ color: r })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Sr(qu, new Er({ color: r })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, o) }

            function Rc(e) {
                var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    n = new nr;
                n.addAttribute("position", new Kn(t, 3)), n.addAttribute("color", new Kn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var r = new lo({ vertexColors: I });
                po.call(this, n, r)
            }

            function Lc(e, t, n, r, i, o, a) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Ln(e, t, n, i, o, a) }
            Object.assign(Ju.prototype, {
                getValue: function(e, t) {
                    this.bind();
                    var n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(e, t)
                },
                setValue: function(e, t) { for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t) },
                bind: function() { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind() },
                unbind: function() { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind() }
            }), Object.assign(Ku, {
                Composite: Ju,
                create: function(e, t, n) { return e && e.isAnimationObjectGroup ? new Ku.Composite(e, t, n) : new Ku(e, t, n) },
                sanitizeNodeName: (Hu = new RegExp("[\\[\\]\\.:\\/]", "g"), function(e) { return e.replace(/\s/g, "_").replace(Hu, "") }),
                parseTrackName: (Uu = "[^\\[\\]\\.:\\/]", Fu = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Nu = /((?:WC+[\/:])*)/.source.replace("WC", Uu), Bu = /(WCOD+)?/.source.replace("WCOD", Fu), zu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Uu), ku = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Uu), Gu = new RegExp("^" + Nu + Bu + zu + ku + "$"), ju = ["material", "materials", "bones"], function(e) {
                    var t = Gu.exec(e);
                    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    var n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) { var i = n.nodeName.substring(r + 1); - 1 !== ju.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i) }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }),
                findNode: function(e, t) {
                    if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) { var n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n }
                    if (e.children) {
                        var r = function(e) { for (var n = 0; n < e.length; n++) { var i = e[n]; if (i.name === t || i.uuid === t) return i; var o = r(i.children); if (o) return o } return null },
                            i = r(e.children);
                        if (i) return i
                    }
                    return null
                }
            }), Object.assign(Ku.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
                Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
                GetterByBindingType: [function(e, t) { e[t] = this.node[this.propertyName] }, function(e, t) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r] }, function(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] }, function(e, t) { this.resolvedProperty.toArray(e, t) }],
                SetterByBindingTypeAndVersioning: [
                    [function(e, t) { this.targetObject[this.propertyName] = e[t] }, function(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 }, function(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++] }, function(e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] }, function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 }, function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { this.resolvedProperty.fromArray(e, t) }, function(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 }, function(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 }]
                ],
                getValue: function(e, t) { this.bind(), this.getValue(e, t) },
                setValue: function(e, t) { this.bind(), this.setValue(e, t) },
                bind: function() {
                    var e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        r = t.propertyName,
                        i = t.propertyIndex;
                    if (e || (e = Ku.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                        if (n) {
                            var o = t.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    e = e.material.materials;
                                    break;
                                case "bones":
                                    if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    e = e.skeleton.bones;
                                    for (var a = 0; a < e.length; a++)
                                        if (e[a].name === o) { o = a; break }
                                    break;
                                default:
                                    if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    e = e[n]
                            }
                            if (void 0 !== o) {
                                if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                e = e[o]
                            }
                        }
                        var s = e[r];
                        if (void 0 !== s) {
                            var u = this.Versioning.None;
                            this.targetObject = e, void 0 !== e.needsUpdate ? u = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (u = this.Versioning.MatrixWorldNeedsUpdate);
                            var c = this.BindingType.Direct;
                            if (void 0 !== i) {
                                if ("morphTargetInfluences" === r) {
                                    if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (e.geometry.isBufferGeometry) {
                                        if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                        for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                            if (e.geometry.morphAttributes.position[a].name === i) { i = a; break }
                                    } else {
                                        if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                        for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                            if (e.geometry.morphTargets[a].name === i) { i = a; break }
                                    }
                                }
                                c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][u]
                        } else {
                            var l = t.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", e)
                        }
                    } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                },
                unbind: function() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
            }), Object.assign(Ku.prototype, { _getValue_unbound: Ku.prototype.getValue, _setValue_unbound: Ku.prototype.setValue }), Object.assign($u.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, u = void 0, c = 0, l = arguments.length; c !== l; ++c) {
                        var h = arguments[c],
                            p = h.uuid,
                            d = r[p];
                        if (void 0 === d) { d = t++, r[p] = d, e.push(h); for (var f = 0, m = s; f !== m; ++f) a[f].push(new Ku(h, i[f], o[f])) } else if (d < n) {
                            u = e[d];
                            var v = --n,
                                g = e[v];
                            r[g.uuid] = d, e[d] = g, r[p] = v, e[v] = h;
                            for (f = 0, m = s; f !== m; ++f) {
                                var y = a[f],
                                    _ = y[v],
                                    x = y[d];
                                y[d] = _, void 0 === x && (x = new Ku(h, i[f], o[f])), y[v] = x
                            }
                        } else e[d] !== u && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function() {
                    for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                        var s = arguments[o],
                            u = s.uuid,
                            c = n[u];
                        if (void 0 !== c && c >= t) {
                            var l = t++,
                                h = e[l];
                            n[h.uuid] = c, e[c] = h, n[u] = l, e[l] = s;
                            for (var p = 0, d = i; p !== d; ++p) {
                                var f = r[p],
                                    m = f[l],
                                    v = f[c];
                                f[c] = m, f[l] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = t
                },
                uncache: function() {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                        var u = arguments[a].uuid,
                            c = r[u];
                        if (void 0 !== c)
                            if (delete r[u], c < n) {
                                var l = --n,
                                    h = e[l],
                                    p = e[g = --t];
                                r[h.uuid] = c, e[c] = h, r[p.uuid] = l, e[l] = p, e.pop();
                                for (var d = 0, f = o; d !== f; ++d) {
                                    var m = (y = i[d])[l],
                                        v = y[g];
                                    y[c] = m, y[l] = v, y.pop()
                                }
                            } else {
                                var g;
                                r[(p = e[g = --t]).uuid] = c, e[c] = p, e.pop();
                                for (d = 0, f = o; d !== f; ++d) {
                                    var y;
                                    (y = i[d])[c] = y[g], y.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = n
                },
                subscribe_: function(e, t) {
                    var n = this._bindingsIndicesByPath,
                        r = n[e],
                        i = this._bindings;
                    if (void 0 !== r) return i[r];
                    var o = this._paths,
                        a = this._parsedPaths,
                        s = this._objects,
                        u = s.length,
                        c = this.nCachedObjects_,
                        l = new Array(u);
                    r = i.length, n[e] = r, o.push(e), a.push(t), i.push(l);
                    for (var h = c, p = s.length; h !== p; ++h) {
                        var d = s[h];
                        l[h] = new Ku(d, e, t)
                    }
                    return l
                },
                unsubscribe_: function(e) {
                    var t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        var r = this._paths,
                            i = this._parsedPaths,
                            o = this._bindings,
                            a = o.length - 1,
                            s = o[a];
                        t[e[a]] = n, o[n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                    }
                }
            }), Object.assign(Qu.prototype, {
                play: function() { return this._mixer._activateAction(this), this },
                stop: function() { return this._mixer._deactivateAction(this), this.reset() },
                reset: function() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() },
                isRunning: function() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) },
                isScheduled: function() { return this._mixer._isActiveAction(this) },
                startAt: function(e) { return this._startTime = e, this },
                setLoop: function(e, t) { return this.loop = e, this.repetitions = t, this },
                setEffectiveWeight: function(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() },
                getEffectiveWeight: function() { return this._effectiveWeight },
                fadeIn: function(e) { return this._scheduleFading(e, 0, 1) },
                fadeOut: function(e) { return this._scheduleFading(e, 1, 0) },
                crossFadeFrom: function(e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        var r = this._clip.duration,
                            i = e._clip.duration,
                            o = i / r,
                            a = r / i;
                        e.warp(1, o, t), this.warp(a, 1, t)
                    }
                    return this
                },
                crossFadeTo: function(e, t, n) { return e.crossFadeFrom(this, t, n) },
                stopFading: function() { var e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this },
                setEffectiveTimeScale: function(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() },
                getEffectiveTimeScale: function() { return this._effectiveTimeScale },
                setDuration: function(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() },
                syncWith: function(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() },
                halt: function(e) { return this.warp(this._effectiveTimeScale, 0, e) },
                warp: function(e, t, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._timeScaleInterpolant,
                        a = this.timeScale;
                    null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    var s = o.parameterPositions,
                        u = o.sampleValues;
                    return s[0] = i, s[1] = i + n, u[0] = e / a, u[1] = t / a, this
                },
                stopWarping: function() { var e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this },
                getMixer: function() { return this._mixer },
                getClip: function() { return this._clip },
                getRoot: function() { return this._localRoot || this._mixer._root },
                _update: function(e, t, n, r) {
                    if (this.enabled) {
                        var i = this._startTime;
                        if (null !== i) {
                            var o = (e - i) * n;
                            if (o < 0 || 0 === n) return;
                            this._startTime = null, t = n * o
                        }
                        t *= this._updateTimeScale(e);
                        var a = this._updateTime(t),
                            s = this._updateWeight(e);
                        if (s > 0)
                            for (var u = this._interpolants, c = this._propertyBindings, l = 0, h = u.length; l !== h; ++l) u[l].evaluate(a), c[l].accumulate(r, s)
                    } else this._updateWeight(e)
                },
                _updateWeight: function(e) {
                    var t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var r = n.evaluate(e)[0];
                            t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                },
                _updateTimeScale: function(e) { var t = 0; if (!this.paused) { t = this.timeScale; var n = this._timeScaleInterpolant; if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } return this._effectiveTimeScale = t, t },
                _updateTime: function(e) {
                    var t = this.time + e,
                        n = this._clip.duration,
                        r = this.loop,
                        i = this._loopCount,
                        o = r === At;
                    if (0 === e) return -1 === i ? t : o && 1 == (1 & i) ? n - t : t;
                    if (r === St) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (t >= n) t = n;
                            else {
                                if (!(t < 0)) break e;
                                t = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 })
                        }
                    } else {
                        if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= n || t < 0) {
                            var a = Math.floor(t / n);
                            t -= n * a, i += Math.abs(a);
                            var s = this.repetitions - i;
                            if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? n : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
                            else {
                                if (1 === s) {
                                    var u = e < 0;
                                    this._setEndings(u, !u, o)
                                } else this._setEndings(!1, !1, o);
                                this._loopCount = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a })
                            }
                        }
                        if (o && 1 == (1 & i)) return this.time = t, n - t
                    }
                    return this.time = t, t
                },
                _setEndings: function(e, t, n) {
                    var r = this._interpolantSettings;
                    n ? (r.endingStart = Ot, r.endingEnd = Ot) : (r.endingStart = e ? this.zeroSlopeAtStart ? Ot : Ct : It, r.endingEnd = t ? this.zeroSlopeAtEnd ? Ot : Ct : It)
                },
                _scheduleFading: function(e, t, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._weightInterpolant;
                    null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                    var a = o.parameterPositions,
                        s = o.sampleValues;
                    return a[0] = i, s[0] = t, a[1] = i + e, s[1] = n, this
                }
            }), ec.prototype = Object.assign(Object.create(r.prototype), {
                constructor: ec,
                _bindAction: function(e, t) {
                    var n = e._localRoot || this._root,
                        r = e._clip.tracks,
                        i = r.length,
                        o = e._propertyBindings,
                        a = e._interpolants,
                        s = n.uuid,
                        u = this._bindingsByRootAndName,
                        c = u[s];
                    void 0 === c && (c = {}, u[s] = c);
                    for (var l = 0; l !== i; ++l) {
                        var h = r[l],
                            p = h.name,
                            d = c[p];
                        if (void 0 !== d) o[l] = d;
                        else { if (void 0 !== (d = o[l])) { null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p)); continue } var f = t && t._propertyBindings[l].binding.parsedPath;++(d = new Du(Ku.create(n, p, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), o[l] = d }
                        a[l].resultBuffer = d.buffer
                    }
                },
                _activateAction: function(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            var t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        for (var i = e._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                            var s = i[o];
                            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                },
                _deactivateAction: function(e) {
                    if (this._isActiveAction(e)) {
                        for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                            var i = t[n];
                            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                        }
                        this._takeBackAction(e)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var e = this;
                    this.stats = { actions: {get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: {get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: {get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } }
                },
                _isActiveAction: function(e) { var t = e._cacheIndex; return null !== t && t < this._nActiveActions },
                _addInactiveAction: function(e, t, n) {
                    var r = this._actions,
                        i = this._actionsByClip,
                        o = i[t];
                    if (void 0 === o) o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, i[t] = o;
                    else {
                        var a = o.knownActions;
                        e._byClipCacheIndex = a.length, a.push(e)
                    }
                    e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e
                },
                _removeInactiveAction: function(e) {
                    var t = this._actions,
                        n = t[t.length - 1],
                        r = e._cacheIndex;
                    n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                    var i = e._clip.uuid,
                        o = this._actionsByClip,
                        a = o[i],
                        s = a.knownActions,
                        u = s[s.length - 1],
                        c = e._byClipCacheIndex;
                    u._byClipCacheIndex = c, s[c] = u, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(e)
                },
                _removeInactiveBindingsForAction: function(e) {
                    for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                        var i = t[n];
                        0 == --i.referenceCount && this._removeInactiveBinding(i)
                    }
                },
                _lendAction: function(e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        r = this._nActiveActions++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                },
                _takeBackAction: function(e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        r = --this._nActiveActions,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                },
                _addInactiveBinding: function(e, t, n) {
                    var r = this._bindingsByRootAndName,
                        i = r[t],
                        o = this._bindings;
                    void 0 === i && (i = {}, r[t] = i), i[n] = e, e._cacheIndex = o.length, o.push(e)
                },
                _removeInactiveBinding: function(e) {
                    var t = this._bindings,
                        n = e.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        o = this._bindingsByRootAndName,
                        a = o[r],
                        s = t[t.length - 1],
                        u = e._cacheIndex;
                    s._cacheIndex = u, t[u] = s, t.pop(), delete a[i];
                    e: { for (var c in a) break e;delete o[r] }
                },
                _lendBinding: function(e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        r = this._nActiveBindings++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                },
                _takeBackBinding: function(e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        r = --this._nActiveBindings,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                },
                _lendControlInterpolant: function() {
                    var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && ((n = new Bs(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n
                },
                _takeBackControlInterpolant: function(e) {
                    var t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = t[r];
                    e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(e, t) {
                    var n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? Ys.findByName(n, e) : e,
                        o = null !== i ? i.uuid : e,
                        a = this._actionsByClip[o],
                        s = null;
                    if (void 0 !== a) {
                        var u = a.actionByRoot[r];
                        if (void 0 !== u) return u;
                        s = a.knownActions[0], null === i && (i = s._clip)
                    }
                    if (null === i) return null;
                    var c = new Qu(this, i, t);
                    return this._bindAction(c, s), this._addInactiveAction(c, o, r), c
                },
                existingAction: function(e, t) {
                    var n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? Ys.findByName(n, e) : e,
                        o = i ? i.uuid : e,
                        a = this._actionsByClip[o];
                    return void 0 !== a && a.actionByRoot[r] || null
                },
                stopAllAction: function() {
                    var e = this._actions,
                        t = this._nActiveActions,
                        n = this._bindings,
                        r = this._nActiveBindings;
                    this._nActiveActions = 0, this._nActiveBindings = 0;
                    for (var i = 0; i !== t; ++i) e[i].reset();
                    for (i = 0; i !== r; ++i) n[i].useCount = 0;
                    return this
                },
                update: function(e) {
                    e *= this.timeScale;
                    for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) { t[a]._update(r, e, i, o) }
                    var s = this._bindings,
                        u = this._nActiveBindings;
                    for (a = 0; a !== u; ++a) s[a].apply(o);
                    return this
                },
                getRoot: function() { return this._root },
                uncacheClip: function(e) {
                    var t = this._actions,
                        n = e.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                            var u = o[a];
                            this._deactivateAction(u);
                            var c = u._cacheIndex,
                                l = t[t.length - 1];
                            u._cacheIndex = null, u._byClipCacheIndex = null, l._cacheIndex = c, t[c] = l, t.pop(), this._removeInactiveBindingsForAction(u)
                        }
                        delete r[n]
                    }
                },
                uncacheRoot: function(e) {
                    var t = e.uuid,
                        n = this._actionsByClip;
                    for (var r in n) {
                        var i = n[r].actionByRoot[t];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                    var o = this._bindingsByRootAndName[t];
                    if (void 0 !== o)
                        for (var a in o) {
                            var s = o[a];
                            s.restoreOriginalState(), this._removeInactiveBinding(s)
                        }
                },
                uncacheAction: function(e, t) {
                    var n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }), tc.prototype.clone = function() { return new tc(void 0 === this.value.clone ? this.value : this.value.clone()) }, nc.prototype = Object.assign(Object.create(nr.prototype), { constructor: nc, isInstancedBufferGeometry: !0, copy: function(e) { return nr.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this }, clone: function() { return (new this.constructor).copy(this) } }), rc.prototype = Object.assign(Object.create(no.prototype), { constructor: rc, isInstancedInterleavedBuffer: !0, copy: function(e) { return no.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this } }), ic.prototype = Object.assign(Object.create(Hn.prototype), { constructor: ic, isInstancedBufferAttribute: !0, copy: function(e) { return Hn.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this } }), Object.assign(oc.prototype, { linePrecision: 1, set: function(e, t) { this.ray.set(e, t) }, setFromCamera: function(e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function(e, t, n) { var r = n || []; return sc(e, this, r, t), r.sort(ac), r }, intersectObjects: function(e, t, n) { var r = n || []; if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r; for (var i = 0, o = e.length; i < o; i++) sc(e[i], this, r, t); return r.sort(ac), r } }), Object.assign(uc.prototype, {
                start: function() { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 },
                stop: function() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 },
                getElapsedTime: function() { return this.getDelta(), this.elapsedTime },
                getDelta: function() {
                    var e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var t = ("undefined" == typeof performance ? Date : performance).now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }), Object.assign(cc.prototype, { set: function(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this }, makeSafe: function() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Zt.clamp(t / this.radius, -1, 1))), this } }), Object.assign(lc.prototype, { set: function(e, t, n) { return this.radius = e, this.theta = t, this.y = n, this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this }, setFromVector3: function(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function(e, t, n) { return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this } }), Object.assign(hc.prototype, { set: function(e, t) { return this.min.copy(e), this.max.copy(t), this }, setFromPoints: function(e) { this.makeEmpty(); for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]); return this }, setFromCenterAndSize: function() { var e = new Jt; return function(t, n) { var r = e.copy(n).multiplyScalar(.5); return this.min.copy(t).sub(r), this.max.copy(t).add(r), this } }(), clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.min.copy(e.min), this.max.copy(e.max), this }, makeEmpty: function() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function() { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function(e) { return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new Jt), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function(e) { return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new Jt), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) }, expandByPoint: function(e) { return this.min.min(e), this.max.max(e), this }, expandByVector: function(e) { return this.min.sub(e), this.max.add(e), this }, expandByScalar: function(e) { return this.min.addScalar(-e), this.max.addScalar(e), this }, containsPoint: function(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) }, containsBox: function(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y }, getParameter: function(e, t) { return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new Jt), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) }, clampPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new Jt), t.copy(e).clamp(this.min, this.max) }, distanceToPoint: function() { var e = new Jt; return function(t) { return e.copy(t).clamp(this.min, this.max).sub(t).length() } }(), intersect: function(e) { return this.min.max(e.min), this.max.min(e.max), this }, union: function(e) { return this.min.min(e.min), this.max.max(e.max), this }, translate: function(e) { return this.min.add(e), this.max.add(e), this }, equals: function(e) { return e.min.equals(this.min) && e.max.equals(this.max) } }), Object.assign(pc.prototype, {
                set: function(e, t) { return this.start.copy(e), this.end.copy(t), this },
                clone: function() { return (new this.constructor).copy(this) },
                copy: function(e) { return this.start.copy(e.start), this.end.copy(e.end), this },
                getCenter: function(e) { return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Qt), e.addVectors(this.start, this.end).multiplyScalar(.5) },
                delta: function(e) { return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new Qt), e.subVectors(this.end, this.start) },
                distanceSq: function() { return this.start.distanceToSquared(this.end) },
                distance: function() { return this.start.distanceTo(this.end) },
                at: function(e, t) { return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new Qt), this.delta(t).multiplyScalar(e).add(this.start) },
                closestPointToPointParameter: (Vu = new Qt, Wu = new Qt, function(e, t) {
                    Vu.subVectors(e, this.start), Wu.subVectors(this.end, this.start);
                    var n = Wu.dot(Wu),
                        r = Wu.dot(Vu) / n;
                    return t && (r = Zt.clamp(r, 0, 1)), r
                }),
                closestPointToPoint: function(e, t, n) { var r = this.closestPointToPointParameter(e, t); return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Qt), this.delta(n).multiplyScalar(r).add(this.start) },
                applyMatrix4: function(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this },
                equals: function(e) { return e.start.equals(this.start) && e.end.equals(this.end) }
            }), dc.prototype = Object.create(Bn.prototype), dc.prototype.constructor = dc, dc.prototype.isImmediateRenderObject = !0, fc.prototype = Object.create(po.prototype), fc.prototype.constructor = fc, fc.prototype.update = function() {
                var e = new Qt,
                    t = new Qt,
                    n = new en;
                return function() {
                    var r = ["a", "b", "c"];
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    var i = this.object.matrixWorld,
                        o = this.geometry.attributes.position,
                        a = this.object.geometry;
                    if (a && a.isGeometry)
                        for (var s = a.vertices, u = a.faces, c = 0, l = 0, h = u.length; l < h; l++)
                            for (var p = u[l], d = 0, f = p.vertexNormals.length; d < f; d++) {
                                var m = s[p[r[d]]],
                                    v = p.vertexNormals[d];
                                e.copy(m).applyMatrix4(i), t.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), o.setXYZ(c, e.x, e.y, e.z), c += 1, o.setXYZ(c, t.x, t.y, t.z), c += 1
                            } else if (a && a.isBufferGeometry) {
                                var g = a.attributes.position,
                                    y = a.attributes.normal;
                                for (c = 0, d = 0, f = g.count; d < f; d++) e.set(g.getX(d), g.getY(d), g.getZ(d)).applyMatrix4(i), t.set(y.getX(d), y.getY(d), y.getZ(d)), t.applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), o.setXYZ(c, e.x, e.y, e.z), c += 1, o.setXYZ(c, t.x, t.y, t.z), c += 1
                            }
                    o.needsUpdate = !0
                }
            }(), mc.prototype = Object.create(Bn.prototype), mc.prototype.constructor = mc, mc.prototype.dispose = function() { this.cone.geometry.dispose(), this.cone.material.dispose() }, mc.prototype.update = function() {
                var e = new Qt,
                    t = new Qt;
                return function() {
                    this.light.updateMatrixWorld();
                    var n = this.light.distance ? this.light.distance : 1e3,
                        r = n * Math.tan(this.light.angle);
                    this.cone.scale.set(r, r, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }(), vc.prototype = Object.create(po.prototype), vc.prototype.constructor = vc, vc.prototype.updateMatrixWorld = function() {
                var e = new Qt,
                    t = new Kt,
                    n = new Kt;
                return function(r) {
                    var i = this.bones,
                        o = this.geometry,
                        a = o.getAttribute("position");
                    n.getInverse(this.root.matrixWorld);
                    for (var s = 0, u = 0; s < i.length; s++) {
                        var c = i[s];
                        c.parent && c.parent.isBone && (t.multiplyMatrices(n, c.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(u, e.x, e.y, e.z), t.multiplyMatrices(n, c.parent.matrixWorld), e.setFromMatrixPosition(t), a.setXYZ(u + 1, e.x, e.y, e.z), u += 2)
                    }
                    o.getAttribute("position").needsUpdate = !0, Bn.prototype.updateMatrixWorld.call(this, r)
                }
            }(), gc.prototype = Object.create(Sr.prototype), gc.prototype.constructor = gc, gc.prototype.dispose = function() { this.geometry.dispose(), this.material.dispose() }, gc.prototype.update = function() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }, yc.prototype = Object.create(Bn.prototype), yc.prototype.constructor = yc, yc.prototype.dispose = function() { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, yc.prototype.update = function() {
                var e = .5 * this.light.width,
                    t = .5 * this.light.height,
                    n = this.line.geometry.attributes.position,
                    r = n.array;
                r[0] = e, r[1] = -t, r[2] = 0, r[3] = e, r[4] = t, r[5] = 0, r[6] = -e, r[7] = t, r[8] = 0, r[9] = -e, r[10] = -t, r[11] = 0, r[12] = e, r[13] = -t, r[14] = 0, n.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
            }, _c.prototype = Object.create(Bn.prototype), _c.prototype.constructor = _c, _c.prototype.dispose = function() { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, _c.prototype.update = function() {
                var e = new Qt,
                    t = new En,
                    n = new En;
                return function() {
                    var r = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        var i = r.geometry.getAttribute("color");
                        t.copy(this.light.color), n.copy(this.light.groundColor);
                        for (var o = 0, a = i.count; o < a; o++) {
                            var s = o < a / 2 ? t : n;
                            i.setXYZ(o, s.r, s.g, s.b)
                        }
                        i.needsUpdate = !0
                    }
                    r.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }(), xc.prototype = Object.create(po.prototype), xc.prototype.constructor = xc, bc.prototype = Object.create(po.prototype), bc.prototype.constructor = bc, wc.prototype = Object.create(po.prototype), wc.prototype.constructor = wc, wc.prototype.update = function() {
                var e = new Qt,
                    t = new Qt,
                    n = new en;
                return function() {
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    for (var r = this.object.matrixWorld, i = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, u = 0, c = 0, l = s.length; c < l; c++) {
                        var h = s[c],
                            p = h.normal;
                        e.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(r), t.copy(p).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), i.setXYZ(u, e.x, e.y, e.z), u += 1, i.setXYZ(u, t.x, t.y, t.z), u += 1
                    }
                    i.needsUpdate = !0
                }
            }(), Mc.prototype = Object.create(Bn.prototype), Mc.prototype.constructor = Mc, Mc.prototype.dispose = function() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, Mc.prototype.update = function() {
                var e = new Qt,
                    t = new Qt,
                    n = new Qt;
                return function() { e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(n), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n), this.targetLine.scale.z = n.length() }
            }(), Ec.prototype = Object.create(po.prototype), Ec.prototype.constructor = Ec, Ec.prototype.update = function() {
                var e, t, n = new Qt,
                    r = new Yi;

                function i(i, o, a, s) {
                    n.set(o, a, s).unproject(r);
                    var u = t[i];
                    if (void 0 !== u)
                        for (var c = e.getAttribute("position"), l = 0, h = u.length; l < h; l++) c.setXYZ(u[l], n.x, n.y, n.z)
                }
                return function() {
                    e = this.geometry, t = this.pointMap;
                    r.projectionMatrix.copy(this.camera.projectionMatrix), i("c", 0, 0, -1), i("t", 0, 0, 1), i("n1", -1, -1, -1), i("n2", 1, -1, -1), i("n3", -1, 1, -1), i("n4", 1, 1, -1), i("f1", -1, -1, 1), i("f2", 1, -1, 1), i("f3", -1, 1, 1), i("f4", 1, 1, 1), i("u1", .7, 1.1, -1), i("u2", -.7, 1.1, -1), i("u3", 0, 2, -1), i("cf1", -1, 0, 1), i("cf2", 1, 0, 1), i("cf3", 0, -1, 1), i("cf4", 0, 1, 1), i("cn1", -1, 0, -1), i("cn2", 1, 0, -1), i("cn3", 0, -1, -1), i("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0
                }
            }(), Sc.prototype = Object.create(po.prototype), Sc.prototype.constructor = Sc, Sc.prototype.update = function() {
                var e = new fn;
                return function(t) {
                    if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                        var n = e.min,
                            r = e.max,
                            i = this.geometry.attributes.position,
                            o = i.array;
                        o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = n.x, o[4] = r.y, o[5] = r.z, o[6] = n.x, o[7] = n.y, o[8] = r.z, o[9] = r.x, o[10] = n.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = n.z, o[15] = n.x, o[16] = r.y, o[17] = n.z, o[18] = n.x, o[19] = n.y, o[20] = n.z, o[21] = r.x, o[22] = n.y, o[23] = n.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                }
            }(), Sc.prototype.setFromObject = function(e) { return this.object = e, this.update(), this }, Tc.prototype = Object.create(po.prototype), Tc.prototype.constructor = Tc, Tc.prototype.updateMatrixWorld = function(e) {
                var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), Bn.prototype.updateMatrixWorld.call(this, e))
            }, Ac.prototype = Object.create(ho.prototype), Ac.prototype.constructor = Ac, Ac.prototype.updateMatrixWorld = function(e) {
                var t = -this.plane.constant;
                Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? A : T, this.lookAt(this.plane.normal), Bn.prototype.updateMatrixWorld.call(this, e)
            }, Pc.prototype = Object.create(Bn.prototype), Pc.prototype.constructor = Pc, Pc.prototype.setDirection = (Zu = new Qt, function(e) { e.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Zu.set(e.z, 0, -e.x).normalize(), Yu = Math.acos(e.y), this.quaternion.setFromAxisAngle(Zu, Yu)) }), Pc.prototype.setLength = function(e, t, n) { void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix() }, Pc.prototype.setColor = function(e) { this.line.material.color.copy(e), this.cone.material.color.copy(e) }, Rc.prototype = Object.create(po.prototype), Rc.prototype.constructor = Rc;
            var Cc = 0,
                Oc = 1;

            function Ic(e) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e }

            function Dc(e) { return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() { return e.slice() }, e }

            function Uc(e, t) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new vo(e, t) }

            function Fc(e) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new oo(e) }

            function Nc(e, t) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new vo(e, t) }

            function Bc(e) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new mo(e) }

            function zc(e) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new mo(e) }

            function kc(e) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new mo(e) }

            function Gc(e, t, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Qt(e, t, n) }

            function jc(e, t) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new Hn(e, t).setDynamic(!0) }

            function Hc(e, t) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Vn(e, t) }

            function Vc(e, t) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Wn(e, t) }

            function Wc(e, t) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Xn(e, t) }

            function Xc(e, t) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new qn(e, t) }

            function qc(e, t) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Yn(e, t) }

            function Yc(e, t) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Zn(e, t) }

            function Zc(e, t) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Jn(e, t) }

            function Jc(e, t) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Kn(e, t) }

            function Kc(e, t) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new $n(e, t) }

            function $c(e) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), cs.call(this, e), this.type = "catmullrom", this.closed = !0 }

            function Qc(e) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), cs.call(this, e), this.type = "catmullrom" }

            function el(e) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), cs.call(this, e), this.type = "catmullrom" }

            function tl(e) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Rc(e) }

            function nl(e, t) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Sc(e, t) }

            function rl(e, t) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new po(new Ta(e.geometry), new lo({ color: void 0 !== t ? t : 16777215 })) }

            function il(e, t) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new po(new bo(e.geometry), new lo({ color: void 0 !== t ? t : 16777215 })) }

            function ol(e) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Za(e) }

            function al(e) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ka(e) }
            ts.create = function(e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(ts.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, Object.assign(bs.prototype, {
                createPointsGeometry: function(e) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getPoints(e); return this.createGeometry(t) },
                createSpacedPointsGeometry: function(e) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getSpacedPoints(e); return this.createGeometry(t) },
                createGeometry: function(e) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var t = new jn, n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        t.vertices.push(new Qt(i.x, i.y, i.z || 0))
                    }
                    return t
                }
            }), Object.assign(ws.prototype, { fromPoints: function(e) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) } }), $c.prototype = Object.create(cs.prototype), Qc.prototype = Object.create(cs.prototype), el.prototype = Object.create(cs.prototype), Object.assign(el.prototype, { initFromArray: function() { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function() { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function() { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), xc.prototype.setColors = function() { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, vc.prototype.update = function() { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(ru.prototype, { extractUrlBase: function(e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), iu.extractUrlBase(e) } }), Object.assign(ou.prototype, { setTexturePath: function(e) { return console.warn("THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } }), Object.assign(hc.prototype, { center: function(e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function() { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, size: function(e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) } }), Object.assign(fn.prototype, { center: function(e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function() { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionSphere: function(e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, size: function(e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) } }), pc.prototype.center = function(e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Object.assign(Zt, { random16: function() { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function(e) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Zt.floorPowerOfTwo(e) }, nextPowerOfTwo: function(e) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Zt.ceilPowerOfTwo(e) } }), Object.assign(en.prototype, { flattenToArrayOffset: function(e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, multiplyVector3: function(e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function(e) { return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e) }, applyToVector3Array: function() { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(Kt.prototype, { extractPosition: function(e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, flattenToArrayOffset: function(e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, getPosition: function() { var e; return function() { return void 0 === e && (e = new Qt), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3) } }(), setRotationFromQuaternion: function(e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, multiplyToArray: function() { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function(e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector4: function(e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function(e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, crossVector: function(e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, translate: function() { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function() { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function() { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function() { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function() { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function(e) { return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e) }, applyToVector3Array: function() { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function(e, t, n, r, i, o) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, o) } }), vn.prototype.isIntersectionLine = function(e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, $t.prototype.multiplyVector3 = function(e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Object.assign(wr.prototype, { isIntersectionBox: function(e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionPlane: function(e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, isIntersectionSphere: function(e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) } }), Object.assign(Mr.prototype, { area: function() { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function(e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, midpoint: function(e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, normal: function(e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, plane: function(e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) } }), Object.assign(Mr, { barycoordFromPoint: function(e, t, n, r, i) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Mr.getBarycoord(e, t, n, r, i) }, normal: function(e, t, n, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Mr.getNormal(e, t, n, r) } }), Object.assign(Ms.prototype, { extractAllPoints: function(e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, extrude: function(e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ha(this, e) }, makeGeometry: function(e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ma(this, e) } }), Object.assign(Jt.prototype, { fromAttribute: function(e, t, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, distanceToManhattan: function(e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function() { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Qt.prototype, { setEulerFromRotationMatrix: function() { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function() { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function(e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, getScaleFromMatrix: function(e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, getColumnFromMatrix: function(e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, applyProjection: function(e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, fromAttribute: function(e, t, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, distanceToManhattan: function(e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function() { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(ln.prototype, { fromAttribute: function(e, t, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, lengthManhattan: function() { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(jn.prototype, { computeTangents: function() { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function() { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } }), Object.assign(Bn.prototype, { getChildByName: function(e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, renderDepth: function() { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function(e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, getWorldRotation: function() { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") } }), Object.defineProperties(Bn.prototype, { eulerOrder: { get: function() { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function(e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.defineProperties(ao.prototype, { objects: { get: function() { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(so.prototype, "useVertexTexture", { get: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), Object.defineProperty(ts.prototype, "__arcLengthDivisions", { get: function() { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function(e) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e } }), Zi.prototype.setLens = function(e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(Es.prototype, { onlyShadow: { set: function() { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function(e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function(e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function(e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function(e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function(e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function(e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function(e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function() { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function(e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function() { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function(e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function(e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(Hn.prototype, { length: { get: function() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, copyIndicesArray: function() { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") } }), Object.assign(nr.prototype, { addIndex: function(e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, addDrawCall: function(e, t, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, clearDrawCalls: function() { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function() { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function() { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") } }), Object.defineProperties(nr.prototype, { drawcalls: { get: function() { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function() { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.assign(pa.prototype, { getArrays: function() { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function() { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function() { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(tc.prototype, { dynamic: { set: function() { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function() { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(xr.prototype, { wrapAround: { get: function() { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function() { console.warn("THREE.Material: .wrapAround has been removed.") } }, wrapRGB: { get: function() { return console.warn("THREE.Material: .wrapRGB has been removed."), new En } }, shading: { get: function() { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function(e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === R } } }), Object.defineProperties(Ba.prototype, { metal: { get: function() { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function() { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(br.prototype, { derivatives: { get: function() { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function(e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), Object.assign($i.prototype, { clearTarget: function(e, t, n, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r) }, animate: function(e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, getCurrentRenderTarget: function() { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function() { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function() { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function() { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function() { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function() { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function() { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function(e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, initMaterial: function() { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function() { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function() { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function() { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function() { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") } }), Object.defineProperties($i.prototype, { shadowMapEnabled: { get: function() { return this.shadowMap.enabled }, set: function(e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function() { return this.shadowMap.type }, set: function(e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Vi.prototype, { cullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(hn.prototype, { wrapS: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function() { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function() { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function() { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function() { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function() { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function() { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Object.defineProperties(Ki.prototype, { standing: { set: function() { console.warn("THREE.WebVRManager: .standing has been removed.") } }, userHeight: { set: function() { console.warn("THREE.WebVRManager: .userHeight has been removed.") } } }), Cu.prototype.load = function(e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var t = this; return (new Au).load(e, function(e) { t.setBuffer(e) }), this }, Iu.prototype.getData = function() { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Ru.prototype.updateCubeMap = function(e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) };
            var sl = {
                merge: function(e, t, n) {
                    var r;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
                },
                center: function(e) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center() }
            };

            function ul() { console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) { console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t) }, this.unprojectVector = function(e, t) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t) }, this.pickingRay = function() { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") } }

            function cl() { console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {} }
            sn.crossOrigin = void 0, sn.loadTexture = function(e, t, n, r) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var i = new es;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(e, n, void 0, r);
                return t && (o.mapping = t), o
            }, sn.loadTextureCube = function(e, t, n, r) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var i = new Qa;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(e, n, void 0, r);
                return t && (o.mapping = t), o
            }, sn.loadCompressedTexture = function() { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, sn.loadCompressedTextureCube = function() { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") };
            var ll = { createMultiMaterialObject: function() { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, detach: function() { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, attach: function() { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") } };

            function hl() { console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js") }
        }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(e, t, n) { e.exports = n(224) }, function(e, t, n) { e.exports = { default: n(110), __esModule: !0 } }, function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var r, i = n(120),
                o = (r = i) && r.__esModule ? r : { default: r };
            t.default = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" !== (void 0 === t ? "undefined" : (0, o.default)(t)) && "function" != typeof t ? e : t }
        }, function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var r = a(n(235)),
                i = a(n(236)),
                o = "function" == typeof i.default && "symbol" == typeof r.default ? function(e) { return typeof e } : function(e) { return e && "function" == typeof i.default && e.constructor === i.default && e !== i.default.prototype ? "symbol" : typeof e };

            function a(e) { return e && e.__esModule ? e : { default: e } }
            t.default = "function" == typeof i.default && "symbol" === o(r.default) ? function(e) { return void 0 === e ? "undefined" : o(e) } : function(e) { return e && "function" == typeof i.default && e.constructor === i.default && e !== i.default.prototype ? "symbol" : void 0 === e ? "undefined" : o(e) }
        }, function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var r = a(n(237)),
                i = a(n(238)),
                o = a(n(120));

            function a(e) { return e && e.__esModule ? e : { default: e } }
            t.default = function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === t ? "undefined" : (0, o.default)(t)));
                e.prototype = (0, i.default)(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (r.default ? (0, r.default)(e, t) : e.__proto__ = t)
            }
        }, function(e, t, n) {
            (function(e, n) {
                var r = 200,
                    i = "__lodash_hash_undefined__",
                    o = 800,
                    a = 16,
                    s = 9007199254740991,
                    u = "[object Arguments]",
                    c = "[object AsyncFunction]",
                    l = "[object Function]",
                    h = "[object GeneratorFunction]",
                    p = "[object Null]",
                    d = "[object Object]",
                    f = "[object Proxy]",
                    m = "[object Undefined]",
                    v = /^\[object .+?Constructor\]$/,
                    g = /^(?:0|[1-9]\d*)$/,
                    y = {};
                y["[object Float32Array]"] = y["[object Float64Array]"] = y["[object Int8Array]"] = y["[object Int16Array]"] = y["[object Int32Array]"] = y["[object Uint8Array]"] = y["[object Uint8ClampedArray]"] = y["[object Uint16Array]"] = y["[object Uint32Array]"] = !0, y[u] = y["[object Array]"] = y["[object ArrayBuffer]"] = y["[object Boolean]"] = y["[object DataView]"] = y["[object Date]"] = y["[object Error]"] = y[l] = y["[object Map]"] = y["[object Number]"] = y[d] = y["[object RegExp]"] = y["[object Set]"] = y["[object String]"] = y["[object WeakMap]"] = !1;
                var _ = "object" == typeof e && e && e.Object === Object && e,
                    x = "object" == typeof self && self && self.Object === Object && self,
                    b = _ || x || Function("return this")(),
                    w = "object" == typeof t && t && !t.nodeType && t,
                    M = w && "object" == typeof n && n && !n.nodeType && n,
                    E = M && M.exports === w,
                    S = E && _.process,
                    T = function() { try { return S && S.binding && S.binding("util") } catch (e) {} }(),
                    A = T && T.isTypedArray;

                function P(e, t) { return "__proto__" == t ? void 0 : e[t] }
                var R, L, C, O = Array.prototype,
                    I = Function.prototype,
                    D = Object.prototype,
                    U = b["__core-js_shared__"],
                    F = I.toString,
                    N = D.hasOwnProperty,
                    B = (R = /[^.]+$/.exec(U && U.keys && U.keys.IE_PROTO || "")) ? "Symbol(src)_1." + R : "",
                    z = D.toString,
                    k = F.call(Object),
                    G = RegExp("^" + F.call(N).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    j = E ? b.Buffer : void 0,
                    H = b.Symbol,
                    V = b.Uint8Array,
                    W = j ? j.allocUnsafe : void 0,
                    X = (L = Object.getPrototypeOf, C = Object, function(e) { return L(C(e)) }),
                    q = Object.create,
                    Y = D.propertyIsEnumerable,
                    Z = O.splice,
                    J = H ? H.toStringTag : void 0,
                    K = function() { try { var e = we(Object, "defineProperty"); return e({}, "", {}), e } catch (e) {} }(),
                    $ = j ? j.isBuffer : void 0,
                    Q = Math.max,
                    ee = Date.now,
                    te = we(b, "Map"),
                    ne = we(Object, "create"),
                    re = function() {
                        function e() {}
                        return function(t) {
                            if (!Ie(t)) return {};
                            if (q) return q(t);
                            e.prototype = t;
                            var n = new e;
                            return e.prototype = void 0, n
                        }
                    }();

                function ie(e) {
                    var t = -1,
                        n = null == e ? 0 : e.length;
                    for (this.clear(); ++t < n;) {
                        var r = e[t];
                        this.set(r[0], r[1])
                    }
                }

                function oe(e) {
                    var t = -1,
                        n = null == e ? 0 : e.length;
                    for (this.clear(); ++t < n;) {
                        var r = e[t];
                        this.set(r[0], r[1])
                    }
                }

                function ae(e) {
                    var t = -1,
                        n = null == e ? 0 : e.length;
                    for (this.clear(); ++t < n;) {
                        var r = e[t];
                        this.set(r[0], r[1])
                    }
                }

                function se(e) {
                    var t = this.__data__ = new oe(e);
                    this.size = t.size
                }

                function ue(e, t) {
                    var n = Pe(e),
                        r = !n && Ae(e),
                        i = !n && !r && Le(e),
                        o = !n && !r && !i && Ue(e),
                        a = n || r || i || o,
                        s = a ? function(e, t) { for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n); return r }(e.length, String) : [],
                        u = s.length;
                    for (var c in e) !t && !N.call(e, c) || a && ("length" == c || i && ("offset" == c || "parent" == c) || o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || Me(c, u)) || s.push(c);
                    return s
                }

                function ce(e, t, n) {
                    (void 0 === n || Te(e[t], n)) && (void 0 !== n || t in e) || pe(e, t, n)
                }

                function le(e, t, n) {
                    var r = e[t];
                    N.call(e, t) && Te(r, n) && (void 0 !== n || t in e) || pe(e, t, n)
                }

                function he(e, t) {
                    for (var n = e.length; n--;)
                        if (Te(e[n][0], t)) return n;
                    return -1
                }

                function pe(e, t, n) { "__proto__" == t && K ? K(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : e[t] = n }
                ie.prototype.clear = function() { this.__data__ = ne ? ne(null) : {}, this.size = 0 }, ie.prototype.delete = function(e) { var t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t }, ie.prototype.get = function(e) { var t = this.__data__; if (ne) { var n = t[e]; return n === i ? void 0 : n } return N.call(t, e) ? t[e] : void 0 }, ie.prototype.has = function(e) { var t = this.__data__; return ne ? void 0 !== t[e] : N.call(t, e) }, ie.prototype.set = function(e, t) { var n = this.__data__; return this.size += this.has(e) ? 0 : 1, n[e] = ne && void 0 === t ? i : t, this }, oe.prototype.clear = function() { this.__data__ = [], this.size = 0 }, oe.prototype.delete = function(e) {
                    var t = this.__data__,
                        n = he(t, e);
                    return !(n < 0 || (n == t.length - 1 ? t.pop() : Z.call(t, n, 1), --this.size, 0))
                }, oe.prototype.get = function(e) {
                    var t = this.__data__,
                        n = he(t, e);
                    return n < 0 ? void 0 : t[n][1]
                }, oe.prototype.has = function(e) { return he(this.__data__, e) > -1 }, oe.prototype.set = function(e, t) {
                    var n = this.__data__,
                        r = he(n, e);
                    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this
                }, ae.prototype.clear = function() { this.size = 0, this.__data__ = { hash: new ie, map: new(te || oe), string: new ie } }, ae.prototype.delete = function(e) { var t = be(this, e).delete(e); return this.size -= t ? 1 : 0, t }, ae.prototype.get = function(e) { return be(this, e).get(e) }, ae.prototype.has = function(e) { return be(this, e).has(e) }, ae.prototype.set = function(e, t) {
                    var n = be(this, e),
                        r = n.size;
                    return n.set(e, t), this.size += n.size == r ? 0 : 1, this
                }, se.prototype.clear = function() { this.__data__ = new oe, this.size = 0 }, se.prototype.delete = function(e) {
                    var t = this.__data__,
                        n = t.delete(e);
                    return this.size = t.size, n
                }, se.prototype.get = function(e) { return this.__data__.get(e) }, se.prototype.has = function(e) { return this.__data__.has(e) }, se.prototype.set = function(e, t) {
                    var n = this.__data__;
                    if (n instanceof oe) {
                        var i = n.__data__;
                        if (!te || i.length < r - 1) return i.push([e, t]), this.size = ++n.size, this;
                        n = this.__data__ = new ae(i)
                    }
                    return n.set(e, t), this.size = n.size, this
                };
                var de, fe = function(e, t, n) { for (var r = -1, i = Object(e), o = n(e), a = o.length; a--;) { var s = o[de ? a : ++r]; if (!1 === t(i[s], s, i)) break } return e };

                function me(e) {
                    return null == e ? void 0 === e ? m : p : J && J in Object(e) ? function(e) {
                        var t = N.call(e, J),
                            n = e[J];
                        try { e[J] = void 0; var r = !0 } catch (e) {}
                        var i = z.call(e);
                        r && (t ? e[J] = n : delete e[J]);
                        return i
                    }(e) : function(e) { return z.call(e) }(e)
                }

                function ve(e) { return De(e) && me(e) == u }

                function ge(e) { return !(!Ie(e) || B && B in e) && (Ce(e) ? G : v).test(function(e) { if (null != e) { try { return F.call(e) } catch (e) {} try { return e + "" } catch (e) {} } return "" }(e)) }

                function ye(e) {
                    if (!Ie(e)) return function(e) {
                        var t = [];
                        if (null != e)
                            for (var n in Object(e)) t.push(n);
                        return t
                    }(e);
                    var t = Ee(e),
                        n = [];
                    for (var r in e)("constructor" != r || !t && N.call(e, r)) && n.push(r);
                    return n
                }

                function _e(e, t, n, r, i) {
                    e !== t && fe(t, function(o, a) {
                        if (Ie(o)) i || (i = new se),
                            function(e, t, n, r, i, o, a) {
                                var s = P(e, n),
                                    u = P(t, n),
                                    c = a.get(u);
                                if (c) return void ce(e, n, c);
                                var l = o ? o(s, u, n + "", e, t, a) : void 0,
                                    h = void 0 === l;
                                if (h) {
                                    var p = Pe(u),
                                        f = !p && Le(u),
                                        m = !p && !f && Ue(u);
                                    l = u, p || f || m ? Pe(s) ? l = s : De(x = s) && Re(x) ? l = function(e, t) {
                                        var n = -1,
                                            r = e.length;
                                        t || (t = Array(r));
                                        for (; ++n < r;) t[n] = e[n];
                                        return t
                                    }(s) : f ? (h = !1, l = function(e, t) {
                                        if (t) return e.slice();
                                        var n = e.length,
                                            r = W ? W(n) : new e.constructor(n);
                                        return e.copy(r), r
                                    }(u, !0)) : m ? (h = !1, v = u, g = !0 ? (y = v.buffer, _ = new y.constructor(y.byteLength), new V(_).set(new V(y)), _) : v.buffer, l = new v.constructor(g, v.byteOffset, v.length)) : l = [] : function(e) { if (!De(e) || me(e) != d) return !1; var t = X(e); if (null === t) return !0; var n = N.call(t, "constructor") && t.constructor; return "function" == typeof n && n instanceof n && F.call(n) == k }(u) || Ae(u) ? (l = s, Ae(s) ? l = function(e) {
                                        return function(e, t, n, r) {
                                            var i = !n;
                                            n || (n = {});
                                            var o = -1,
                                                a = t.length;
                                            for (; ++o < a;) {
                                                var s = t[o],
                                                    u = r ? r(n[s], e[s], s, n, e) : void 0;
                                                void 0 === u && (u = e[s]), i ? pe(n, s, u) : le(n, s, u)
                                            }
                                            return n
                                        }(e, Fe(e))
                                    }(s) : (!Ie(s) || r && Ce(s)) && (l = function(e) { return "function" != typeof e.constructor || Ee(e) ? {} : re(X(e)) }(u))) : h = !1
                                }
                                var v, g, y, _;
                                var x;
                                h && (a.set(u, l), i(l, u, r, o, a), a.delete(u));
                                ce(e, n, l)
                            }(e, t, a, n, _e, r, i);
                        else {
                            var s = r ? r(P(e, a), o, a + "", e, t, i) : void 0;
                            void 0 === s && (s = o), ce(e, a, s)
                        }
                    }, Fe)
                }

                function xe(e, t) {
                    return Se(function(e, t, n) {
                        return t = Q(void 0 === t ? e.length - 1 : t, 0),
                            function() {
                                for (var r = arguments, i = -1, o = Q(r.length - t, 0), a = Array(o); ++i < o;) a[i] = r[t + i];
                                i = -1;
                                for (var s = Array(t + 1); ++i < t;) s[i] = r[i];
                                return s[t] = n(a),
                                    function(e, t, n) {
                                        switch (n.length) {
                                            case 0:
                                                return e.call(t);
                                            case 1:
                                                return e.call(t, n[0]);
                                            case 2:
                                                return e.call(t, n[0], n[1]);
                                            case 3:
                                                return e.call(t, n[0], n[1], n[2])
                                        }
                                        return e.apply(t, n)
                                    }(e, this, s)
                            }
                    }(e, t, ze), e + "")
                }

                function be(e, t) { var n, r, i = e.__data__; return ("string" == (r = typeof(n = t)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof t ? "string" : "hash"] : i.map }

                function we(e, t) { var n = function(e, t) { return null == e ? void 0 : e[t] }(e, t); return ge(n) ? n : void 0 }

                function Me(e, t) { var n = typeof e; return !!(t = null == t ? s : t) && ("number" == n || "symbol" != n && g.test(e)) && e > -1 && e % 1 == 0 && e < t }

                function Ee(e) { var t = e && e.constructor; return e === ("function" == typeof t && t.prototype || D) }
                var Se = function(e) {
                    var t = 0,
                        n = 0;
                    return function() {
                        var r = ee(),
                            i = a - (r - n);
                        if (n = r, i > 0) { if (++t >= o) return arguments[0] } else t = 0;
                        return e.apply(void 0, arguments)
                    }
                }(K ? function(e, t) { return K(e, "toString", { configurable: !0, enumerable: !1, value: (n = t, function() { return n }), writable: !0 }); var n } : ze);

                function Te(e, t) { return e === t || e != e && t != t }
                var Ae = ve(function() { return arguments }()) ? ve : function(e) { return De(e) && N.call(e, "callee") && !Y.call(e, "callee") },
                    Pe = Array.isArray;

                function Re(e) { return null != e && Oe(e.length) && !Ce(e) }
                var Le = $ || function() { return !1 };

                function Ce(e) { if (!Ie(e)) return !1; var t = me(e); return t == l || t == h || t == c || t == f }

                function Oe(e) { return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s }

                function Ie(e) { var t = typeof e; return null != e && ("object" == t || "function" == t) }

                function De(e) { return null != e && "object" == typeof e }
                var Ue = A ? function(e) { return function(t) { return e(t) } }(A) : function(e) { return De(e) && Oe(e.length) && !!y[me(e)] };

                function Fe(e) { return Re(e) ? ue(e, !0) : ye(e) }
                var Ne, Be = (Ne = function(e, t, n) { _e(e, t, n) }, xe(function(e, t) {
                    var n = -1,
                        r = t.length,
                        i = r > 1 ? t[r - 1] : void 0,
                        o = r > 2 ? t[2] : void 0;
                    for (i = Ne.length > 3 && "function" == typeof i ? (r--, i) : void 0, o && function(e, t, n) { if (!Ie(n)) return !1; var r = typeof t; return !!("number" == r ? Re(n) && Me(t, n.length) : "string" == r && t in n) && Te(n[t], e) }(t[0], t[1], o) && (i = r < 3 ? void 0 : i, r = 1), e = Object(e); ++n < r;) {
                        var a = t[n];
                        a && Ne(e, a, n, i)
                    }
                    return e
                }));

                function ze(e) { return e }
                n.exports = Be
            }).call(t, n(49), n(48)(e))
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = s(n(248));

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { invalid: !1, value: n.props.value }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement("input", { style: { width: this.props.width, color: this.context.style.highlight, font: this.context.style.font, padding: this.context.style.paddingY + "px " + this.context.style.paddingX + "px", backgroundColor: this.state.invalid ? this.context.style.lowlighterr : this.context.style.lowlight, border: "none", outline: "none" }, type: "text", value: this.state.value, onChange: this.onChange.bind(this), onKeyDown: this.onKeyDown.bind(this), onBlur: this.onBlur.bind(this) }) } }, { key: "componentWillReceiveProps", value: function(e) { this.setState({ invalid: !this.isNumber(e.value), value: this.truncate(e.value) }) } }, { key: "truncate", value: function(e) { return void 0 !== this.props.decimals ? (0, a.default)("%." + this.props.decimals + "f", parseFloat(e)) : e } }, { key: "onKeyDown", value: function(e) { 13 === e.which && this.handleChange(this.truncate(e.target.value)) } }, { key: "onBlur", value: function(e) { this.handleChange(this.truncate(e.target.value)) } }, { key: "isNumber", value: function(e) { return !isNaN(e) && "" !== e } }, { key: "onChange", value: function(e) { this.isNumber(e.target.value) ? this.setState({ invalid: !1, value: e.target.value }) : this.setState({ invalid: !0, value: e.target.value }) } }, { key: "handleChange", value: function(e) {!this.state.invalid && this.props.onChange && this.props.onChange(parseFloat(e)), !this.state.invalid && this.props.onFinishChange && this.props.onFinishChange(parseFloat(e)) } }]), t
            }();
            t.default = u, u.propTypes = { value: i.default.number.isRequired, width: i.default.string, onChange: i.default.func, OnFinishChange: i.default.func }, u.defaultProps = { width: "100%" }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = a(n(2)),
                o = a(n(0));

            function a(e) { return e && e.__esModule ? e : { default: e } }
            var s = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { value: n.props.value }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement("div", { ref: "container", onMouseDown: this.onMouseDown.bind(this), style: { width: this.props.width, height: this.context.style.computed.itemHeight + "px", position: "relative" } }, o.default.createElement("div", { ref: "track", style: { position: "absolute", width: "100%", height: "1px", left: "0px", backgroundColor: this.context.style.lowlight } }), o.default.createElement("div", { ref: "thumb", style: { position: "absolute", backgroundColor: this.context.style.lowlight, border: "1px solid " + this.context.style.highlight, boxSizing: "border-box", borderRadius: "0px", cursor: "pointer" } })) } }, { key: "componentWillReceiveProps", value: function(e) { "value" in e && this.setState({ value: e.value }) } }, { key: "componentDidUpdate", value: function() { this.updateLayout() } }, {
                    key: "componentDidMount",
                    value: function() {
                        var e = this;
                        this.updateLayout(), this.context.folder && (this.unsubscribeFolder = this.context.folder.subscribe(function(t) { t && e.forceUpdate() }))
                    }
                }, { key: "componentWillUnmount", value: function() { this.unsubscribeFolder && this.unsubscribeFolder() } }, {
                    key: "updateLayout",
                    value: function() {
                        var e = this.refs.container,
                            t = e.clientHeight,
                            n = e.clientWidth;
                        this.refs.track.style.top = t / 2 - .5 + "px";
                        var r = this.refs.thumb,
                            i = .9 * this.context.style.computed.fontHeight;
                        r.style.top = this.context.style.computed.itemHeight / 2 - i / 2 + "px";
                        var o = (this.state.value - this.props.min) / (this.props.max - this.props.min) * n - i / 2;
                        o = Math.max(o, 0), o = Math.min(o, n - i), r.style.left = o + "px", r.style.width = i + "px", r.style.height = i + "px"
                    }
                }, {
                    key: "moveThumb",
                    value: function(e) {
                        var t = this.refs.container,
                            n = t.clientWidth,
                            r = .9 * this.context.style.computed.fontHeight,
                            i = e - t.getBoundingClientRect().left,
                            o = (i < r / 2 ? 0 : i > n - r / 2 ? 1 : (i - r / 2) / (n - r)) * (this.props.max - this.props.min) + this.props.min;
                        if (void 0 !== this.props.step) {
                            for (var a = [], s = this.props.min; s < this.props.max;) a.push(s), s += this.props.step;
                            a.push(this.props.max);
                            for (var u = a[0], c = 0; c < a.length; c++) {
                                var l = a[c],
                                    h = Math.abs(u - o);
                                Math.abs(l - o) < h && (u = l)
                            }
                            o = u
                        }
                        this.setState({ value: o }), this.props.onChange && this.props.onChange(o)
                    }
                }, {
                    key: "onMouseDown",
                    value: function(e) {
                        e.preventDefault(), this.moveThumb(e.pageX);
                        var t = function(e) { this.moveThumb(e.pageX) }.bind(this),
                            n = function() { window.removeEventListener("mouseup", n), window.removeEventListener("mousemove", t), this.props.onFinishChange && this.props.onFinishChange(this.state.value) }.bind(this);
                        window.addEventListener("mousemove", t), window.addEventListener("mouseup", n)
                    }
                }]), t
            }();
            t.default = s, s.propTypes = { value: i.default.number.isRequired, min: i.default.number.isRequired, max: i.default.number.isRequired, step: i.default.number, width: i.default.string, onChange: i.default.func, OnFinishChange: i.default.func }, s.defaultProps = { width: "100%" }, s.contextTypes = { style: i.default.object, folder: i.default.shape({ subscribe: i.default.func }) }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = u(n(2)),
                o = u(n(0)),
                a = u(n(123)),
                s = u(n(124));

            function u(e) { return e && e.__esModule ? e : { default: e } }
            var c = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { value: n.props.value }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement("div", { style: { width: this.props.width, display: "flex", flexFlow: "row wrap", alignItems: "center", justifyContent: "space-between" } }, o.default.createElement(s.default, { value: this.state.value, min: this.props.min, max: this.props.max, step: this.props.step, width: this.props.rangeWidth, onChange: this.handleChange.bind(this), onFinishChange: this.handleFinishChange.bind(this) }), o.default.createElement(a.default, { decimals: this.props.decimals, value: this.state.value, width: this.props.numberWidth, onChange: this.handleChange.bind(this), onFinishChange: this.handleFinishChange.bind(this) })) } }, { key: "componentWillReceiveProps", value: function(e) { this.setState({ value: e.value }) } }, { key: "handleChange", value: function(e) { e = Math.min(this.props.max, Math.max(this.props.min, e)), this.setState({ value: e }, function() { this.props.onChange && this.props.onChange(this.state.value) }) } }, { key: "handleFinishChange", value: function(e) { e = Math.min(this.props.max, Math.max(this.props.min, e)), this.setState({ value: e }, function() { this.props.onFinishChange && this.props.onFinishChange(this.state.value) }) } }]), t
            }();
            t.default = c, c.propTypes = { value: i.default.number.isRequired, min: i.default.number.isRequired, max: i.default.number.isRequired, step: i.default.number, width: i.default.string, rangeWidth: i.default.string, numberWidth: i.default.string, onChange: i.default.func, OnFinishChange: i.default.func }, c.defaultProps = { rangeWidth: "65%", numberWidth: "30%", width: "100%" }
        }, function(e, t, n) {
            "use strict";
            e.exports = ((e, t, n) => { if ("string" != typeof e) throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``); return -1 !== e.indexOf(t, "number" == typeof n ? n : 0) })
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r = n(52);

            function i(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var o = function() {
                function e() {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e) }
                var t, n, o;
                return t = e, (n = [{ key: "setup", value: function(e, t, n, i, o, a, s, u, c, l) { this.renderer = e, this.camera = t, this.renderTarget = new r.WebGLRenderTarget(n, i, { minFilter: void 0 !== u ? u : r.NearestFilter, magFilter: void 0 !== u ? u : r.NearestFilter, type: void 0 !== c ? c : r.UnsignedByteType, generateMipmaps: !1, stencilBuffer: !1, depthBuffer: !1, wrapS: r.ClampToEdgeWrapping, wrapT: r.ClampToEdgeWrapping }), this.scene = new r.Scene; var h = new r.Mesh(l || new r.PlaneBufferGeometry(2, 2, 1, 1), new r.RawShaderMaterial({ uniforms: s, vertexShader: o, fragmentShader: a, side: r.DoubleSide, depthTest: !1, depthWrite: !1 })); return this.scene.add(h), this.renderTarget.texture } }, { key: "setSize", value: function(e, t) { this.renderTarget.setSize(e, t) } }, { key: "dispose", value: function() { this.renderTarget.dispose(), this.scene.children[0].geometry.dispose(), this.scene.children[0].material.dispose() } }, { key: "render", value: function() { this.renderer.render(this.scene, this.camera, this.renderTarget, !1) } }]) && i(t.prototype, n), o && i(t, o), e
            }();
            t.default = o
        }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(e, t, n) { e.exports = n(223) }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r = u(n(117)),
                i = u(n(0)),
                o = u(n(114)),
                a = (function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var n in e)
                            if (Object.prototype.hasOwnProperty.call(e, n)) {
                                var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
                                r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n]
                            }
                    t.default = e
                }(n(37)), u(n(263)), u(n(265))),
                s = (u(n(267)), u(n(271)));

            function u(e) { return e && e.__esModule ? e : { default: e } }

            function c(e) { return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) }

            function l(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function h(e, t) { return !t || "object" !== c(t) && "function" != typeof t ? function(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t }
            var p = function(e) {
                function t(e) { var n; return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), (n = h(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e))).uniforms = {}, n }
                var n, u, c;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, i.default.Component), n = t, (u = [{ key: "render", value: function() { var e = this; return i.default.createElement(a.default, null, i.default.createElement(o.default, null, i.default.createElement("title", { className: "jsx-2057306224" }, "Nipple")), i.default.createElement("div", { className: "jsx-2057306224" }, i.default.createElement(s.default, { setUniforms: function(t) { e.uniforms = t } })), i.default.createElement(r.default, { styleId: "2057306224", css: ["div.jsx-2057306224{overflow:hidden;position:absolute;top:0;left:0;width:100vw;height:100vh;}"] })) } }]) && l(n.prototype, u), c && l(n, c), t
            }();
            t.default = p
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = h(n(225)),
                i = h(n(231)),
                o = h(n(118)),
                a = h(n(50)),
                s = h(n(51)),
                u = h(n(119)),
                c = h(n(121));
            t.flush = function() { var e = p.cssRules(); return p.flush(), new r.default(e) };
            var l = n(0);

            function h(e) { return e && e.__esModule ? e : { default: e } }
            var p = new(h(n(239)).default),
                d = function(e) {
                    function t() { return (0, a.default)(this, t), (0, u.default)(this, (t.__proto__ || (0, o.default)(t)).apply(this, arguments)) }
                    return (0, c.default)(t, e), (0, s.default)(t, [{ key: "componentWillMount", value: function() { p.add(this.props) } }, { key: "shouldComponentUpdate", value: function(e) { return this.props.css !== e.css } }, { key: "componentWillUpdate", value: function(e) { p.update(this.props, e) } }, { key: "componentWillUnmount", value: function() { p.remove(this.props) } }, { key: "render", value: function() { return null } }], [{
                        key: "dynamic",
                        value: function(e) {
                            return e.map(function(e) {
                                var t = (0, i.default)(e, 2),
                                    n = t[0],
                                    r = t[1];
                                return p.computeId(n, r)
                            }).join(" ")
                        }
                    }]), t
                }(l.Component);
            t.default = d
        }, function(e, t, n) { e.exports = { default: n(226), __esModule: !0 } }, function(e, t, n) { n(46), n(19), n(22), n(227), n(228), n(229), n(230), e.exports = n(1).Map }, function(e, t, n) {
            "use strict";
            var r = n(103),
                i = n(74);
            e.exports = n(104)("Map", function(e) { return function() { return e(this, arguments.length > 0 ? arguments[0] : void 0) } }, { get: function(e) { var t = r.getEntry(i(this, "Map"), e); return t && t.v }, set: function(e, t) { return r.def(i(this, "Map"), 0 === e ? 0 : e, t) } }, r, !0)
        }, function(e, t, n) {
            var r = n(3);
            r(r.P + r.R, "Map", { toJSON: n(105)("Map") })
        }, function(e, t, n) { n(106)("Map") }, function(e, t, n) { n(107)("Map") }, function(e, t, n) {
            "use strict";
            t.__esModule = !0;
            var r = o(n(232)),
                i = o(n(233));

            function o(e) { return e && e.__esModule ? e : { default: e } }
            t.default = function() {
                return function(e, t) {
                    if (Array.isArray(e)) return e;
                    if ((0, r.default)(Object(e))) return function(e, t) {
                        var n = [],
                            r = !0,
                            o = !1,
                            a = void 0;
                        try { for (var s, u = (0, i.default)(e); !(r = (s = u.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0); } catch (e) { o = !0, a = e } finally { try {!r && u.return && u.return() } finally { if (o) throw a } }
                        return n
                    }(e, t);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                }
            }()
        }, function(e, t, n) { e.exports = { default: n(116), __esModule: !0 } }, function(e, t, n) { e.exports = { default: n(88), __esModule: !0 } }, function(e, t, n) { e.exports = { default: n(79), __esModule: !0 } }, function(e, t, n) { e.exports = { default: n(100), __esModule: !0 } }, function(e, t, n) { e.exports = { default: n(101), __esModule: !0 } }, function(e, t, n) { e.exports = { default: n(112), __esModule: !0 } }, function(e, t, n) { e.exports = { default: n(113), __esModule: !0 } }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = u(n(240)),
                i = u(n(50)),
                o = u(n(51)),
                a = u(n(241)),
                s = u(n(242));

            function u(e) { return e && e.__esModule ? e : { default: e } }
            var c = function() {
                function e() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        n = t.styleSheet,
                        r = void 0 === n ? null : n,
                        o = t.optimizeForSpeed,
                        a = void 0 !== o && o,
                        u = t.isBrowser,
                        c = void 0 === u ? "undefined" != typeof window : u;
                    (0, i.default)(this, e), this._sheet = r || new s.default({ name: "styled-jsx", optimizeForSpeed: a }), this._sheet.inject(), r && "boolean" == typeof a && (this._sheet.setOptimizeForSpeed(a), this._optimizeForSpeed = this._sheet.isOptimizeForSpeed()), this._isBrowser = c, this._fromServer = void 0, this._indices = {}, this._instancesCounts = {}, this.computeId = this.createComputeId(), this.computeSelector = this.createComputeSelector()
                }
                return (0, o.default)(e, [{
                    key: "add",
                    value: function(e) {
                        var t = this;
                        void 0 === this._optimizeForSpeed && (this._optimizeForSpeed = Array.isArray(e.css), this._sheet.setOptimizeForSpeed(this._optimizeForSpeed), this._optimizeForSpeed = this._sheet.isOptimizeForSpeed()), this._isBrowser && !this._fromServer && (this._fromServer = this.selectFromServer(), this._instancesCounts = (0, r.default)(this._fromServer).reduce(function(e, t) { return e[t] = 0, e }, {}));
                        var n = this.getIdAndRules(e),
                            i = n.styleId,
                            o = n.rules;
                        if (i in this._instancesCounts) this._instancesCounts[i] += 1;
                        else {
                            var a = o.map(function(e) { return t._sheet.insertRule(e) }).filter(function(e) { return -1 !== e });
                            a.length > 0 && (this._indices[i] = a, this._instancesCounts[i] = 1)
                        }
                    }
                }, {
                    key: "remove",
                    value: function(e) {
                        var t = this,
                            n = this.getIdAndRules(e).styleId;
                        if (function(e, t) { if (!e) throw new Error("StyleSheetRegistry: " + t + ".") }(n in this._instancesCounts, "styleId: `" + n + "` not found"), this._instancesCounts[n] -= 1, this._instancesCounts[n] < 1) {
                            var r = this._fromServer && this._fromServer[n];
                            r ? (r.parentNode.removeChild(r), delete this._fromServer[n]) : (this._indices[n].forEach(function(e) { return t._sheet.deleteRule(e) }), delete this._indices[n]), delete this._instancesCounts[n]
                        }
                    }
                }, { key: "update", value: function(e, t) { this.add(t), this.remove(e) } }, { key: "flush", value: function() { this._sheet.flush(), this._sheet.inject(), this._fromServer = void 0, this._indices = {}, this._instancesCounts = {}, this.computeId = this.createComputeId(), this.computeSelector = this.createComputeSelector() } }, {
                    key: "cssRules",
                    value: function() {
                        var e = this,
                            t = this._fromServer ? (0, r.default)(this._fromServer).map(function(t) { return [t, e._fromServer[t]] }) : [],
                            n = this._sheet.cssRules();
                        return t.concat((0, r.default)(this._indices).map(function(t) { return [t, e._indices[t].map(function(e) { return n[e].cssText }).join("\n")] }))
                    }
                }, {
                    key: "createComputeId",
                    value: function() {
                        var e = {};
                        return function(t, n) {
                            if (!n) return "jsx-" + t;
                            var r = String(n),
                                i = t + r;
                            return e[i] || (e[i] = "jsx-" + (0, a.default)(t + "-" + r)), e[i]
                        }
                    }
                }, {
                    key: "createComputeSelector",
                    value: function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /__jsx-style-dynamic-selector/g,
                            t = {};
                        return function(n, r) { this._isBrowser || (r = r.replace(/\/style/gi, "\\/style")); var i = n + r; return t[i] || (t[i] = r.replace(e, n)), t[i] }
                    }
                }, { key: "getIdAndRules", value: function(e) { var t = this; if (e.dynamic) { var n = this.computeId(e.styleId, e.dynamic); return { styleId: n, rules: Array.isArray(e.css) ? e.css.map(function(e) { return t.computeSelector(n, e) }) : [this.computeSelector(n, e.css)] } } return { styleId: this.computeId(e.styleId), rules: Array.isArray(e.css) ? e.css : [e.css] } } }, { key: "selectFromServer", value: function() { return Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]')).reduce(function(e, t) { return e[t.id.slice(2)] = t, e }, {}) } }]), e
            }();
            t.default = c
        }, function(e, t, n) { e.exports = { default: n(86), __esModule: !0 } }, function(e, t, n) {
            "use strict";
            e.exports = function(e) { for (var t = 5381, n = e.length; n;) t = 33 * t ^ e.charCodeAt(--n); return t >>> 0 }
        }, function(e, t, n) {
            "use strict";
            (function(e) {
                Object.defineProperty(t, "__esModule", { value: !0 });
                var r = o(n(50)),
                    i = o(n(51));

                function o(e) { return e && e.__esModule ? e : { default: e } }
                var a = e.env && !0,
                    s = function(e) { return "[object String]" === Object.prototype.toString.call(e) },
                    u = function() {
                        function e() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                n = t.name,
                                i = void 0 === n ? "stylesheet" : n,
                                o = t.optimizeForSpeed,
                                u = void 0 === o ? a : o,
                                l = t.isBrowser,
                                h = void 0 === l ? "undefined" != typeof window : l;
                            (0, r.default)(this, e), c(s(i), "`name` must be a string"), this._name = i, this._deletedRulePlaceholder = "#" + i + "-deleted-rule____{}", c("boolean" == typeof u, "`optimizeForSpeed` must be a boolean"), this._optimizeForSpeed = u, this._isBrowser = h, this._serverSheet = void 0, this._tags = [], this._injected = !1, this._rulesCount = 0
                        }
                        return (0, i.default)(e, [{ key: "setOptimizeForSpeed", value: function(e) { c("boolean" == typeof e, "`setOptimizeForSpeed` accepts a boolean"), c(0 === this._rulesCount, "optimizeForSpeed cannot be when rules have already been inserted"), this.flush(), this._optimizeForSpeed = e, this.inject() } }, { key: "isOptimizeForSpeed", value: function() { return this._optimizeForSpeed } }, {
                            key: "inject",
                            value: function() {
                                var e = this;
                                if (c(!this._injected, "sheet already injected"), this._injected = !0, this._isBrowser && this._optimizeForSpeed) return this._tags[0] = this.makeStyleTag(this._name), this._optimizeForSpeed = "insertRule" in this.getSheet(), void(this._optimizeForSpeed || (a || console.warn("StyleSheet: optimizeForSpeed mode not supported falling back to standard mode."), this.flush(), this._injected = !0));
                                this._serverSheet = { cssRules: [], insertRule: function(t, n) { return "number" == typeof n ? e._serverSheet.cssRules[n] = { cssText: t } : e._serverSheet.cssRules.push({ cssText: t }), n }, deleteRule: function(t) { e._serverSheet.cssRules[t] = null } }
                            }
                        }, {
                            key: "getSheetForTag",
                            value: function(e) {
                                if (e.sheet) return e.sheet;
                                for (var t = 0; t < document.styleSheets.length; t++)
                                    if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t]
                            }
                        }, { key: "getSheet", value: function() { return this.getSheetForTag(this._tags[this._tags.length - 1]) } }, {
                            key: "insertRule",
                            value: function(e, t) {
                                if (c(s(e), "`insertRule` accepts only strings"), !this._isBrowser) return "number" != typeof t && (t = this._serverSheet.cssRules.length), this._serverSheet.insertRule(e, t), this._rulesCount++;
                                if (this._optimizeForSpeed) { var n = this.getSheet(); "number" != typeof t && (t = n.cssRules.length); try { n.insertRule(e, t) } catch (t) { return a || console.warn("StyleSheet: illegal rule: \n\n" + e + "\n\nSee https://stackoverflow.com/q/20007992 for more info"), -1 } } else {
                                    var r = this._tags[t];
                                    this._tags.push(this.makeStyleTag(this._name, e, r))
                                }
                                return this._rulesCount++
                            }
                        }, {
                            key: "replaceRule",
                            value: function(e, t) {
                                if (this._optimizeForSpeed || !this._isBrowser) {
                                    var n = this._isBrowser ? this.getSheet() : this._serverSheet;
                                    if (t.trim() || (t = this._deletedRulePlaceholder), !n.cssRules[e]) return e;
                                    n.deleteRule(e);
                                    try { n.insertRule(t, e) } catch (r) { a || console.warn("StyleSheet: illegal rule: \n\n" + t + "\n\nSee https://stackoverflow.com/q/20007992 for more info"), n.insertRule(this._deletedRulePlaceholder, e) }
                                } else {
                                    var r = this._tags[e];
                                    c(r, "old rule at index `" + e + "` not found"), r.textContent = t
                                }
                                return e
                            }
                        }, {
                            key: "deleteRule",
                            value: function(e) {
                                if (this._isBrowser)
                                    if (this._optimizeForSpeed) this.replaceRule(e, "");
                                    else {
                                        var t = this._tags[e];
                                        c(t, "rule at index `" + e + "` not found"), t.parentNode.removeChild(t), this._tags[e] = null
                                    }
                                else this._serverSheet.deleteRule(e)
                            }
                        }, { key: "flush", value: function() { this._injected = !1, this._rulesCount = 0, this._isBrowser ? (this._tags.forEach(function(e) { return e && e.parentNode.removeChild(e) }), this._tags = []) : this._serverSheet.cssRules = [] } }, { key: "cssRules", value: function() { var e = this; return this._isBrowser ? this._tags.reduce(function(t, n) { return n ? t = t.concat(e.getSheetForTag(n).cssRules.map(function(t) { return t.cssText === e._deletedRulePlaceholder ? null : t })) : t.push(null), t }, []) : this._serverSheet.cssRules } }, {
                            key: "makeStyleTag",
                            value: function(e, t, n) {
                                t && c(s(t), "makeStyleTag acceps only strings as second parameter");
                                var r = document.createElement("style");
                                r.type = "text/css", r.setAttribute("data-" + e, ""), t && r.appendChild(document.createTextNode(t));
                                var i = document.head || document.getElementsByTagName("head")[0];
                                return n ? i.insertBefore(r, n) : i.appendChild(r), r
                            }
                        }, { key: "length", get: function() { return this._rulesCount } }]), e
                    }();

                function c(e, t) { if (!e) throw new Error("StyleSheet: " + t + ".") }
                t.default = u
            }).call(t, n(109))
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.Text = t.Select = t.Number = t.Gradient = t.Color = t.Checkbox = t.Button = t.Folder = t.GUI = void 0;
            var r = p(n(244)),
                i = p(n(250)),
                o = p(n(252)),
                a = p(n(253)),
                s = p(n(254)),
                u = p(n(255)),
                c = p(n(256)),
                l = p(n(257)),
                h = n(258);

            function p(e) { return e && e.__esModule ? e : { default: e } }
            t.GUI = r.default, t.Folder = i.default, t.Button = o.default, t.Checkbox = a.default, t.Color = s.default, t.Gradient = h.Gradient, t.Number = u.default, t.Select = c.default, t.Text = l.default
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = u(n(2)),
                o = u(n(0)),
                a = u(n(122)),
                s = n(14);

            function u(e) { return e && e.__esModule ? e : { default: e } }
            var c = { labelWidth: 96, controlWidth: 192, paddingY: 3, paddingX: 3, highlight: "#0FA", lowlight: "#444", lowlighterr: "#822", font: "11px Arial", backgroundColor: "#1A1A1A", separator: "1px solid #333", label: { fontColor: "#FFF", fontWeight: "normal" } },
                l = function(e) {
                    function t(e) {
                        ! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t);
                        var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                        return n.style = (0, a.default)(JSON.parse(JSON.stringify(c)), n.props.style), n.style.computed = {}, n.style.computed.fontHeight = function(e) {
                            var t = document.createElement("div");
                            t.style.font = e, t.style.overflow = "hidden", t.style.whiteSpace = "nowrap", t.innerHTML = "~!@#$%^&*()_+`1234567890-=QWERTYUIOP{}|qwertyuiop[]\\ASDFGHJKL:\"asdfghjkl;'ZXCVBNM<>?zxcvbnm,./", document.body.appendChild(t);
                            var n = t.clientHeight;
                            return document.body.removeChild(t), n
                        }(n.style.font), n.style.computed.itemHeight = n.style.computed.fontHeight + 2 * n.style.paddingY, n.style.computed.minRowHeight = n.style.computed.itemHeight + 2 * n.style.paddingY, n.state = { expanded: n.props.expanded }, n
                    }
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                    }(t, o.default.PureComponent), r(t, [{ key: "componentWillReceiveProps", value: function(e) { e.expanded !== this.props.expanded && e.expanded !== this.state.expanded && this.setState({ expanded: e.expanded || e.alwaysOpen }) } }, {
                        key: "render",
                        value: function() {
                            var e = { position: "fixed" };
                            void 0 !== this.style.right ? e.right = this.style.right : void 0 !== this.style.left ? e.left = this.style.left : e.right = "8px", void 0 !== this.style.top ? e.top = this.style.top : void 0 !== this.style.bottom ? e.bottom = this.style.bottom : e.top = "0px";
                            var t = this.state.expanded ? "Close Controls" : "Open Controls";
                            return o.default.createElement("div", { style: e, className: this.props.className }, o.default.createElement("div", { style: { display: this.state.expanded ? "block" : "none" } }, this.props.children), !this.props.alwaysOpen && o.default.createElement(s.Row, null, o.default.createElement("div", { onClick: this.handleCloseControls.bind(this), style: { font: this.style.font, color: this.style.label.fontColor, textAlign: "center", width: this.style.labelWidth + this.style.controlWidth + 2 * this.style.paddingX, cursor: "pointer" } }, o.default.createElement("span", { style: { WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none", MozAppearance: "none" } }, t))))
                        }
                    }, { key: "getChildContext", value: function() { return { style: this.style } } }, { key: "handleCloseControls", value: function() { this.setState({ expanded: !this.state.expanded }) } }]), t
                }();
            t.default = l, l.propTypes = { style: i.default.object, expanded: i.default.bool, alwaysOpen: i.default.bool, className: i.default.string }, l.defaultProps = { expanded: !0, alwaysOpen: !1 }, l.childContextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = a(n(2)),
                o = a(n(0));

            function a(e) { return e && e.__esModule ? e : { default: e } }
            var s = function(e) {
                function t() {
                    return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t),
                        function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement("div", { style: { borderBottom: this.context.style.separator, backgroundColor: this.context.style.backgroundColor, minHeight: this.context.style.computed.minRowHeight, padding: this.context.style.paddingY + "px " + this.context.style.paddingX + "px", boxSizing: "border-box", display: "flex", flexFlow: "row wrap", alignItems: "center" } }, this.props.children) } }]), t
            }();
            t.default = s, s.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = a(n(2)),
                o = a(n(0));

            function a(e) { return e && e.__esModule ? e : { default: e } }
            var s = function(e) {
                function t() {
                    return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t),
                        function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement("div", { style: { width: this.context.style.labelWidth, font: this.context.style.font, fontWeight: this.context.style.label.fontWeight, padding: this.context.style.paddingY + "px " + this.context.style.paddingX + "px", color: this.context.style.label.fontColor, cursor: "default", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" } }, this.props.children) } }]), t
            }();
            t.default = s, s.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = a(n(2)),
                o = a(n(0));

            function a(e) { return e && e.__esModule ? e : { default: e } }
            var s = function(e) {
                function t() {
                    return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t),
                        function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement("div", { style: { width: this.context.style.controlWidth + "px" } }, this.props.children) } }]), t
            }();
            t.default = s, s.contextTypes = { style: i.default.object }
        }, function(e, t) {
            var n = function() {
                function e(e) { return Object.prototype.toString.call(e).slice(8, -1).toLowerCase() }

                function t(e, t) { for (var n = []; t > 0; n[--t] = e); return n.join("") }
                var r = function() { return r.cache.hasOwnProperty(arguments[0]) || (r.cache[arguments[0]] = r.parse(arguments[0])), r.format.call(null, r.cache[arguments[0]], arguments) };
                return r.object_stringify = function(e, t, n, i) {
                    var o = "";
                    if (null != e) switch (typeof e) {
                        case "function":
                            return "[Function" + (e.name ? ": " + e.name : "") + "]";
                        case "object":
                            if (e instanceof Error) return "[" + e.toString() + "]";
                            if (t >= n) return "[Object]";
                            if (i && (i = i.slice(0)).push(e), null != e.length) {
                                o += "[";
                                var a = [];
                                for (var s in e) i && i.indexOf(e[s]) >= 0 ? a.push("[Circular]") : a.push(r.object_stringify(e[s], t + 1, n, i));
                                o += a.join(", ") + "]"
                            } else {
                                if ("getMonth" in e) return "Date(" + e + ")";
                                o += "{";
                                a = [];
                                for (var u in e) e.hasOwnProperty(u) && (i && i.indexOf(e[u]) >= 0 ? a.push(u + ": [Circular]") : a.push(u + ": " + r.object_stringify(e[u], t + 1, n, i)));
                                o += a.join(", ") + "}"
                            }
                            return o;
                        case "string":
                            return '"' + e + '"'
                    }
                    return "" + e
                }, r.format = function(i, o) {
                    var a, s, u, c, l, h, p, d = 1,
                        f = i.length,
                        m = "",
                        v = [];
                    for (s = 0; s < f; s++)
                        if ("string" === (m = e(i[s]))) v.push(i[s]);
                        else if ("array" === m) {
                        if ((c = i[s])[2])
                            for (a = o[d], u = 0; u < c[2].length; u++) {
                                if (!a.hasOwnProperty(c[2][u])) throw new Error(n('[sprintf] property "%s" does not exist', c[2][u]));
                                a = a[c[2][u]]
                            } else a = c[1] ? o[c[1]] : o[d++];
                        if (/[^sO]/.test(c[8]) && "number" != e(a)) throw new Error(n('[sprintf] expecting number but found %s "' + a + '"', e(a)));
                        switch (c[8]) {
                            case "b":
                                a = a.toString(2);
                                break;
                            case "c":
                                a = String.fromCharCode(a);
                                break;
                            case "d":
                                a = parseInt(a, 10);
                                break;
                            case "e":
                                a = c[7] ? a.toExponential(c[7]) : a.toExponential();
                                break;
                            case "f":
                                a = c[7] ? parseFloat(a).toFixed(c[7]) : parseFloat(a);
                                break;
                            case "O":
                                a = r.object_stringify(a, 0, parseInt(c[7]) || 5);
                                break;
                            case "o":
                                a = a.toString(8);
                                break;
                            case "s":
                                a = (a = String(a)) && c[7] ? a.substring(0, c[7]) : a;
                                break;
                            case "u":
                                a = Math.abs(a);
                                break;
                            case "x":
                                a = a.toString(16);
                                break;
                            case "X":
                                a = a.toString(16).toUpperCase()
                        }
                        a = /[def]/.test(c[8]) && c[3] && a >= 0 ? "+" + a : a, h = c[4] ? "0" == c[4] ? "0" : c[4].charAt(1) : " ", p = c[6] - String(a).length, l = c[6] ? t(h, p) : "", v.push(c[5] ? a + l : l + a)
                    }
                    return v.join("")
                }, r.cache = {}, r.parse = function(e) {
                    for (var t = e, n = [], r = [], i = 0; t;) {
                        if (null !== (n = /^[^\x25]+/.exec(t))) r.push(n[0]);
                        else if (null !== (n = /^\x25{2}/.exec(t))) r.push("%");
                        else {
                            if (null === (n = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosOuxX])/.exec(t))) throw new Error("[sprintf] " + t);
                            if (n[2]) {
                                i |= 1;
                                var o = [],
                                    a = n[2],
                                    s = [];
                                if (null === (s = /^([a-z_][a-z_\d]*)/i.exec(a))) throw new Error("[sprintf] " + a);
                                for (o.push(s[1]);
                                    "" !== (a = a.substring(s[0].length));)
                                    if (null !== (s = /^\.([a-z_][a-z_\d]*)/i.exec(a))) o.push(s[1]);
                                    else {
                                        if (null === (s = /^\[(\d+)\]/.exec(a))) throw new Error("[sprintf] " + a);
                                        o.push(s[1])
                                    }
                                n[2] = o
                            } else i |= 2;
                            if (3 === i) throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
                            r.push(n)
                        }
                        t = t.substring(n[0].length)
                    }
                    return r
                }, r
            }();
            e.exports = n, n.sprintf = n, n.vsprintf = function(e, t) { var r = t.slice(); return r.unshift(e), n.apply(null, r) }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = s(n(125));

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t() {
                    return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t),
                        function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement("div", { style: { padding: this.context.style.paddingY + "px 0px", paddingBottom: "0px", display: "flex", flexFlow: "row wrap", alignItems: "center", width: "100%" } }, o.default.createElement("span", { style: { font: this.context.style.font, color: this.context.style.highlight, width: "20%", display: "inline-block", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" } }, this.props.label), o.default.createElement(a.default, { width: "80%", min: 0, max: 255, step: 1, value: this.props.value, onChange: this.handleChange.bind(this), onFinishChange: this.handleFinishChange.bind(this) })) } }, { key: "handleFinishChange", value: function(e) { this.props.onFinishChange && this.props.onFinishChange(e) } }, { key: "handleChange", value: function(e) { this.props.onChange && this.props.onChange(e) } }]), t
            }();
            t.default = u, u.propTypes = { label: i.default.string, value: i.default.number.isRequired, onChange: i.default.func, onFinishChange: i.default.func }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = u(n(2)),
                o = u(n(0)),
                a = u(n(122)),
                s = u(n(251));
            u(n(14));

            function u(e) { return e && e.__esModule ? e : { default: e } }
            var c = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.subscriptions = [], n.state = { expanded: n.props.expanded }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "subscribe", value: function(e) { this.subscriptions.push(e) } }, { key: "unsubscribe", value: function(e) { this.subscriptions.splice(this.subscriptions.indexOf(e), 1) } }, { key: "componentWillReceiveProps", value: function(e) { e.expanded !== this.props.expanded && e.expanded !== this.state.expanded && this.setState({ expanded: e.expanded }) } }, {
                    key: "componentDidUpdate",
                    value: function(e, t) {
                        var n = this;
                        t.expanded !== this.state.expanded && this.subscriptions.forEach(function(e) { return e(n.state.expanded) })
                    }
                }, {
                    key: "render",
                    value: function() {
                        var e = this.state.expanded ? "none" : "inline-block",
                            t = this.state.expanded ? "inline-block" : "none";
                        return o.default.createElement("div", { style: { backgroundColor: this.context.style.backgroundColor } }, o.default.createElement("div", { style: { color: this.context.style.label.fontColor, font: this.context.style.font, fontWeight: this.context.style.label.fontWeight, padding: this.context.style.paddingY + "px " + this.context.style.paddingX + "px", borderBottom: this.context.style.separator, cursor: "pointer", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" }, onClick: this.handleClick.bind(this) }, o.default.createElement("div", { style: { padding: this.context.style.paddingY + "px " + this.context.style.paddingX + "px", display: "flex", flexFlow: "row wrap", alignItems: "center" } }, this.props.label, o.default.createElement("svg", { width: "" + .75 * this.context.style.computed.fontHeight, height: "" + .75 * this.context.style.computed.fontHeight, style: { display: e, marginLeft: this.context.style.paddingX } }, o.default.createElement("g", { transform: "scale(" + .75 * this.context.style.computed.fontHeight / 100 + ")" }, o.default.createElement("polygon", { className: "shape", points: "25,0 75,50 25,100", fill: this.context.style.label.fontColor }))), o.default.createElement("svg", { width: "" + .75 * this.context.style.computed.fontHeight, height: "" + .75 * this.context.style.computed.fontHeight, style: { display: t, marginLeft: this.context.style.paddingX } }, o.default.createElement("g", { transform: "scale(" + .75 * this.context.style.computed.fontHeight / 100 + ")" }, o.default.createElement("polygon", { className: "shape", points: "0,25 50,75 100,25", fill: this.context.style.label.fontColor }))))), o.default.createElement("div", { style: { borderLeft: "4px solid " + this.context.style.lowlight, display: this.state.expanded ? "block" : "none" } }, this.props.children))
                    }
                }, {
                    key: "getChildContext",
                    value: function() {
                        var e = this;
                        return (0, a.default)((0, s.default)(this.context), {
                            style: { labelWidth: this.context.style.labelWidth - 4 },
                            folder: {
                                subscribe: function(t) {
                                    return e.subscribe(t),
                                        function() { return e.unsubscribe(t) }
                                }
                            }
                        })
                    }
                }, { key: "handleClick", value: function(e) { this.setState({ expanded: !this.state.expanded }, function() { this.props.onChange && this.props.onChange(this.state.expanded), this.props.onFinishChange && this.props.onFinishChange(this.state.expanded) }) } }]), t
            }();
            t.default = c, c.propTypes = { expanded: i.default.bool, label: i.default.string, onChange: i.default.func, onFinishChange: i.default.func }, c.defaultProps = { expanded: !1 }, c.childContextTypes = { style: i.default.object, folder: i.default.shape({ subscribe: i.default.func }) }, c.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            (function(e, n) {
                var r = 200,
                    i = "__lodash_hash_undefined__",
                    o = 9007199254740991,
                    a = "[object Arguments]",
                    s = "[object Boolean]",
                    u = "[object Date]",
                    c = "[object Function]",
                    l = "[object GeneratorFunction]",
                    h = "[object Map]",
                    p = "[object Number]",
                    d = "[object Object]",
                    f = "[object RegExp]",
                    m = "[object Set]",
                    v = "[object String]",
                    g = "[object Symbol]",
                    y = "[object ArrayBuffer]",
                    _ = "[object DataView]",
                    x = "[object Float32Array]",
                    b = "[object Float64Array]",
                    w = "[object Int8Array]",
                    M = "[object Int16Array]",
                    E = "[object Int32Array]",
                    S = "[object Uint8Array]",
                    T = "[object Uint8ClampedArray]",
                    A = "[object Uint16Array]",
                    P = "[object Uint32Array]",
                    R = /\w*$/,
                    L = /^\[object .+?Constructor\]$/,
                    C = /^(?:0|[1-9]\d*)$/,
                    O = {};
                O[a] = O["[object Array]"] = O[y] = O[_] = O[s] = O[u] = O[x] = O[b] = O[w] = O[M] = O[E] = O[h] = O[p] = O[d] = O[f] = O[m] = O[v] = O[g] = O[S] = O[T] = O[A] = O[P] = !0, O["[object Error]"] = O[c] = O["[object WeakMap]"] = !1;
                var I = "object" == typeof e && e && e.Object === Object && e,
                    D = "object" == typeof self && self && self.Object === Object && self,
                    U = I || D || Function("return this")(),
                    F = "object" == typeof t && t && !t.nodeType && t,
                    N = F && "object" == typeof n && n && !n.nodeType && n,
                    B = N && N.exports === F;

                function z(e, t) { return e.set(t[0], t[1]), e }

                function k(e, t) { return e.add(t), e }

                function G(e, t, n, r) {
                    var i = -1,
                        o = e ? e.length : 0;
                    for (r && o && (n = e[++i]); ++i < o;) n = t(n, e[i], i, e);
                    return n
                }

                function j(e) {
                    var t = !1;
                    if (null != e && "function" != typeof e.toString) try { t = !!(e + "") } catch (e) {}
                    return t
                }

                function H(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach(function(e, r) { n[++t] = [r, e] }), n
                }

                function V(e, t) { return function(n) { return e(t(n)) } }

                function W(e) {
                    var t = -1,
                        n = Array(e.size);
                    return e.forEach(function(e) { n[++t] = e }), n
                }
                var X, q = Array.prototype,
                    Y = Function.prototype,
                    Z = Object.prototype,
                    J = U["__core-js_shared__"],
                    K = (X = /[^.]+$/.exec(J && J.keys && J.keys.IE_PROTO || "")) ? "Symbol(src)_1." + X : "",
                    $ = Y.toString,
                    Q = Z.hasOwnProperty,
                    ee = Z.toString,
                    te = RegExp("^" + $.call(Q).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    ne = B ? U.Buffer : void 0,
                    re = U.Symbol,
                    ie = U.Uint8Array,
                    oe = V(Object.getPrototypeOf, Object),
                    ae = Object.create,
                    se = Z.propertyIsEnumerable,
                    ue = q.splice,
                    ce = Object.getOwnPropertySymbols,
                    le = ne ? ne.isBuffer : void 0,
                    he = V(Object.keys, Object),
                    pe = Ne(U, "DataView"),
                    de = Ne(U, "Map"),
                    fe = Ne(U, "Promise"),
                    me = Ne(U, "Set"),
                    ve = Ne(U, "WeakMap"),
                    ge = Ne(Object, "create"),
                    ye = je(pe),
                    _e = je(de),
                    xe = je(fe),
                    be = je(me),
                    we = je(ve),
                    Me = re ? re.prototype : void 0,
                    Ee = Me ? Me.valueOf : void 0;

                function Se(e) {
                    var t = -1,
                        n = e ? e.length : 0;
                    for (this.clear(); ++t < n;) {
                        var r = e[t];
                        this.set(r[0], r[1])
                    }
                }

                function Te(e) {
                    var t = -1,
                        n = e ? e.length : 0;
                    for (this.clear(); ++t < n;) {
                        var r = e[t];
                        this.set(r[0], r[1])
                    }
                }

                function Ae(e) {
                    var t = -1,
                        n = e ? e.length : 0;
                    for (this.clear(); ++t < n;) {
                        var r = e[t];
                        this.set(r[0], r[1])
                    }
                }

                function Pe(e) { this.__data__ = new Te(e) }

                function Re(e, t) {
                    var n = Ve(e) || function(e) { return function(e) { return function(e) { return !!e && "object" == typeof e }(e) && We(e) }(e) && Q.call(e, "callee") && (!se.call(e, "callee") || ee.call(e) == a) }(e) ? function(e, t) { for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n); return r }(e.length, String) : [],
                        r = n.length,
                        i = !!r;
                    for (var o in e) !t && !Q.call(e, o) || i && ("length" == o || ke(o, r)) || n.push(o);
                    return n
                }

                function Le(e, t, n) {
                    var r = e[t];
                    Q.call(e, t) && He(r, n) && (void 0 !== n || t in e) || (e[t] = n)
                }

                function Ce(e, t) {
                    for (var n = e.length; n--;)
                        if (He(e[n][0], t)) return n;
                    return -1
                }

                function Oe(e, t, n, r, i, o, L) {
                    var C;
                    if (r && (C = o ? r(e, i, o, L) : r(e)), void 0 !== C) return C;
                    if (!Ye(e)) return e;
                    var I = Ve(e);
                    if (I) {
                        if (C = function(e) {
                                var t = e.length,
                                    n = e.constructor(t);
                                t && "string" == typeof e[0] && Q.call(e, "index") && (n.index = e.index, n.input = e.input);
                                return n
                            }(e), !t) return function(e, t) {
                            var n = -1,
                                r = e.length;
                            t || (t = Array(r));
                            for (; ++n < r;) t[n] = e[n];
                            return t
                        }(e, C)
                    } else {
                        var D = ze(e),
                            U = D == c || D == l;
                        if (Xe(e)) return function(e, t) { if (t) return e.slice(); var n = new e.constructor(e.length); return e.copy(n), n }(e, t);
                        if (D == d || D == a || U && !o) { if (j(e)) return o ? e : {}; if (C = function(e) { return "function" != typeof e.constructor || Ge(e) ? {} : (t = oe(e), Ye(t) ? ae(t) : {}); var t }(U ? {} : e), !t) return function(e, t) { return Ue(e, Be(e), t) }(e, function(e, t) { return e && Ue(t, Ze(t), e) }(C, e)) } else {
                            if (!O[D]) return o ? e : {};
                            C = function(e, t, n, r) {
                                var i = e.constructor;
                                switch (t) {
                                    case y:
                                        return De(e);
                                    case s:
                                    case u:
                                        return new i(+e);
                                    case _:
                                        return function(e, t) { var n = t ? De(e.buffer) : e.buffer; return new e.constructor(n, e.byteOffset, e.byteLength) }(e, r);
                                    case x:
                                    case b:
                                    case w:
                                    case M:
                                    case E:
                                    case S:
                                    case T:
                                    case A:
                                    case P:
                                        return function(e, t) { var n = t ? De(e.buffer) : e.buffer; return new e.constructor(n, e.byteOffset, e.length) }(e, r);
                                    case h:
                                        return function(e, t, n) { return G(t ? n(H(e), !0) : H(e), z, new e.constructor) }(e, r, n);
                                    case p:
                                    case v:
                                        return new i(e);
                                    case f:
                                        return (c = new(a = e).constructor(a.source, R.exec(a))).lastIndex = a.lastIndex, c;
                                    case m:
                                        return function(e, t, n) { return G(t ? n(W(e), !0) : W(e), k, new e.constructor) }(e, r, n);
                                    case g:
                                        return o = e, Ee ? Object(Ee.call(o)) : {}
                                }
                                var o;
                                var a, c
                            }(e, D, Oe, t)
                        }
                    }
                    L || (L = new Pe);
                    var F = L.get(e);
                    if (F) return F;
                    if (L.set(e, C), !I) var N = n ? function(e) { return function(e, t, n) { var r = t(e); return Ve(e) ? r : function(e, t) { for (var n = -1, r = t.length, i = e.length; ++n < r;) e[i + n] = t[n]; return e }(r, n(e)) }(e, Ze, Be) }(e) : Ze(e);
                    return function(e, t) { for (var n = -1, r = e ? e.length : 0; ++n < r && !1 !== t(e[n], n, e);); }(N || e, function(i, o) { N && (i = e[o = i]), Le(C, o, Oe(i, t, n, r, o, e, L)) }), C
                }

                function Ie(e) { return !(!Ye(e) || K && K in e) && (qe(e) || j(e) ? te : L).test(je(e)) }

                function De(e) { var t = new e.constructor(e.byteLength); return new ie(t).set(new ie(e)), t }

                function Ue(e, t, n, r) {
                    n || (n = {});
                    for (var i = -1, o = t.length; ++i < o;) {
                        var a = t[i],
                            s = r ? r(n[a], e[a], a, n, e) : void 0;
                        Le(n, a, void 0 === s ? e[a] : s)
                    }
                    return n
                }

                function Fe(e, t) { var n, r, i = e.__data__; return ("string" == (r = typeof(n = t)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof t ? "string" : "hash"] : i.map }

                function Ne(e, t) { var n = function(e, t) { return null == e ? void 0 : e[t] }(e, t); return Ie(n) ? n : void 0 }
                Se.prototype.clear = function() { this.__data__ = ge ? ge(null) : {} }, Se.prototype.delete = function(e) { return this.has(e) && delete this.__data__[e] }, Se.prototype.get = function(e) { var t = this.__data__; if (ge) { var n = t[e]; return n === i ? void 0 : n } return Q.call(t, e) ? t[e] : void 0 }, Se.prototype.has = function(e) { var t = this.__data__; return ge ? void 0 !== t[e] : Q.call(t, e) }, Se.prototype.set = function(e, t) { return this.__data__[e] = ge && void 0 === t ? i : t, this }, Te.prototype.clear = function() { this.__data__ = [] }, Te.prototype.delete = function(e) {
                    var t = this.__data__,
                        n = Ce(t, e);
                    return !(n < 0 || (n == t.length - 1 ? t.pop() : ue.call(t, n, 1), 0))
                }, Te.prototype.get = function(e) {
                    var t = this.__data__,
                        n = Ce(t, e);
                    return n < 0 ? void 0 : t[n][1]
                }, Te.prototype.has = function(e) { return Ce(this.__data__, e) > -1 }, Te.prototype.set = function(e, t) {
                    var n = this.__data__,
                        r = Ce(n, e);
                    return r < 0 ? n.push([e, t]) : n[r][1] = t, this
                }, Ae.prototype.clear = function() { this.__data__ = { hash: new Se, map: new(de || Te), string: new Se } }, Ae.prototype.delete = function(e) { return Fe(this, e).delete(e) }, Ae.prototype.get = function(e) { return Fe(this, e).get(e) }, Ae.prototype.has = function(e) { return Fe(this, e).has(e) }, Ae.prototype.set = function(e, t) { return Fe(this, e).set(e, t), this }, Pe.prototype.clear = function() { this.__data__ = new Te }, Pe.prototype.delete = function(e) { return this.__data__.delete(e) }, Pe.prototype.get = function(e) { return this.__data__.get(e) }, Pe.prototype.has = function(e) { return this.__data__.has(e) }, Pe.prototype.set = function(e, t) {
                    var n = this.__data__;
                    if (n instanceof Te) {
                        var i = n.__data__;
                        if (!de || i.length < r - 1) return i.push([e, t]), this;
                        n = this.__data__ = new Ae(i)
                    }
                    return n.set(e, t), this
                };
                var Be = ce ? V(ce, Object) : function() { return [] },
                    ze = function(e) { return ee.call(e) };

                function ke(e, t) { return !!(t = null == t ? o : t) && ("number" == typeof e || C.test(e)) && e > -1 && e % 1 == 0 && e < t }

                function Ge(e) { var t = e && e.constructor; return e === ("function" == typeof t && t.prototype || Z) }

                function je(e) { if (null != e) { try { return $.call(e) } catch (e) {} try { return e + "" } catch (e) {} } return "" }

                function He(e, t) { return e === t || e != e && t != t }(pe && ze(new pe(new ArrayBuffer(1))) != _ || de && ze(new de) != h || fe && "[object Promise]" != ze(fe.resolve()) || me && ze(new me) != m || ve && "[object WeakMap]" != ze(new ve)) && (ze = function(e) {
                    var t = ee.call(e),
                        n = t == d ? e.constructor : void 0,
                        r = n ? je(n) : void 0;
                    if (r) switch (r) {
                        case ye:
                            return _;
                        case _e:
                            return h;
                        case xe:
                            return "[object Promise]";
                        case be:
                            return m;
                        case we:
                            return "[object WeakMap]"
                    }
                    return t
                });
                var Ve = Array.isArray;

                function We(e) { return null != e && function(e) { return "number" == typeof e && e > -1 && e % 1 == 0 && e <= o }(e.length) && !qe(e) }
                var Xe = le || function() { return !1 };

                function qe(e) { var t = Ye(e) ? ee.call(e) : ""; return t == c || t == l }

                function Ye(e) { var t = typeof e; return !!e && ("object" == t || "function" == t) }

                function Ze(e) { return We(e) ? Re(e) : function(e) { if (!Ge(e)) return he(e); var t = []; for (var n in Object(e)) Q.call(e, n) && "constructor" != n && t.push(n); return t }(e) }
                n.exports = function(e) { return Oe(e, !0, !0) }
            }).call(t, n(49), n(48)(e))
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = n(14);

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t() {
                    return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t),
                        function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement(a.Row, null, o.default.createElement(a.Label, null), o.default.createElement(a.Control, null, o.default.createElement("div", { onClick: this.handleClick.bind(this), style: { backgroundColor: this.context.style.lowlight, color: this.context.style.highlight, font: this.context.style.font, padding: this.context.style.paddingY + "px " + this.context.style.paddingX + "px", textAlign: "center", cursor: "pointer", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" } }, this.props.label))) } }, { key: "handleClick", value: function(e) { this.props.onClick && this.props.onClick() } }]), t
            }();
            t.default = u, u.propTypes = { label: i.default.string.isRequired, onClick: i.default.func }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = n(14);

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { checked: n.props.checked }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "componentWillReceiveProps", value: function(e) { e.checked !== this.props.checked && e.checked !== this.state.checked && this.setState({ checked: e.checked }) } }, { key: "render", value: function() { return o.default.createElement(a.Row, null, o.default.createElement(a.Label, null, this.props.label), o.default.createElement(a.Control, null, o.default.createElement("svg", { width: "" + this.context.style.computed.fontHeight, height: "" + this.context.style.computed.fontHeight, onClick: this.handleClick.bind(this), style: { cursor: "pointer" } }, o.default.createElement("g", { transform: "scale(" + this.context.style.computed.fontHeight / 100 + ")" }, o.default.createElement("rect", { className: "shape", x: "0", y: "0", width: "100", height: "100", fill: this.context.style.lowlight }), this.state.checked && o.default.createElement("path", { transform: "translate(18.75 50)", d: "M0 0 L25 25 L62.5 -32.5", stroke: this.context.style.highlight, strokeWidth: "15", fill: "none" }))))) } }, { key: "handleClick", value: function(e) { this.setState({ checked: !this.state.checked }), this.props.onChange && this.props.onChange(!this.state.checked), this.props.onFinishChange && this.props.onFinishChange(!this.state.checked) } }]), t
            }();
            t.default = u, u.propTypes = { checked: i.default.bool, label: i.default.string, onChange: i.default.func, onFinishChange: i.default.func }, u.defaultProps = { checked: !1 }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = n(14);

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { red: n.props.red, green: n.props.green, blue: n.props.blue, expanded: n.props.expanded }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{
                    key: "componentWillReceiveProps",
                    value: function(e) {
                        var t = {},
                            n = !1;
                        e.red !== this.props.red && e.red !== this.state.red && (t.red = e.red, n = !0), e.green !== this.props.green && e.green !== this.state.green && (t.green = e.green, n = !0), e.blue !== this.props.blue && e.blue !== this.state.blue && (t.blue = e.blue, n = !0), e.expanded !== this.props.expanded && e.expanded !== this.state.expanded && (t.expanded = e.expanded, n = !0), n && this.setState(t)
                    }
                }, { key: "render", value: function() { return o.default.createElement(a.Row, null, o.default.createElement(a.Label, null, this.props.label), o.default.createElement(a.Control, null, o.default.createElement("div", { onClick: this.handleColorClick.bind(this), style: (e = { font: this.context.style.font, backgroundColor: "rgb(" + this.state.red + ", " + this.state.green + ", " + this.state.blue + ")", height: this.context.style.computed.itemHeight + "px", lineHeight: this.context.style.computed.itemHeight + "px", width: "100%", textAlign: "center", color: "white", fontWeight: "bold", textShadow: "black 0 0 4px, black 0 0 4px, black 0 0 4px, black 0 0 4px, black 0 0 4px", cursor: "default", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" }, t = "cursor", n = "pointer", t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e) }, this.state.red, ", ", this.state.green, ", ", this.state.blue), this.state.expanded && o.default.createElement("div", null, o.default.createElement(a.ColorRange, { label: "Red", value: this.state.red, onChange: this.handleChangeRed.bind(this), onFinishChange: this.handleFinishChange.bind(this) }), o.default.createElement(a.ColorRange, { label: "Green", value: this.state.green, onChange: this.handleChangeGreen.bind(this), onFinishChange: this.handleFinishChange.bind(this) }), o.default.createElement(a.ColorRange, { label: "Blue", value: this.state.blue, onChange: this.handleChangeBlue.bind(this), onFinishChange: this.handleFinishChange.bind(this) })))); var e, t, n } }, { key: "handleColorClick", value: function(e) { this.setState({ expanded: !this.state.expanded }) } }, { key: "handleChangeRed", value: function(e) { this.setState({ red: e }, this.handleChange) } }, { key: "handleChangeGreen", value: function(e) { this.setState({ green: e }, this.handleChange) } }, { key: "handleChangeBlue", value: function(e) { this.setState({ blue: e }, this.handleChange) } }, { key: "handleChange", value: function() { this.props.onChange && this.props.onChange({ red: this.state.red, green: this.state.green, blue: this.state.blue }) } }, {
                    key: "handleFinishChange",
                    value: function() {
                        var e = this;
                        this.props.onFinishChange && setTimeout(function() { e.props.onFinishChange({ red: e.state.red, green: e.state.green, blue: e.state.blue }) }, 0)
                    }
                }]), t
            }();
            t.default = u, u.propTypes = { red: i.default.number, green: i.default.number, blue: i.default.number, expanded: i.default.bool, label: i.default.string, onChange: i.default.func, onFinishChange: i.default.func }, u.defaultProps = { red: 0, green: 0, blue: 0, expanded: !1 }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = n(14);

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { value: n.props.value }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "componentWillReceiveProps", value: function(e) { e.value !== this.props.value && e.value !== this.state.value && this.setState({ value: e.value }) } }, { key: "render", value: function() { return void 0 !== this.props.min && void 0 !== this.props.max ? o.default.createElement(a.Row, null, o.default.createElement(a.Label, null, this.props.label), o.default.createElement(a.Control, null, o.default.createElement(a.NumberRange, { decimals: this.props.decimals, value: this.state.value, min: this.props.min, max: this.props.max, step: this.props.step, onChange: this.handleChange.bind(this), onFinishChange: this.handleFinishChange.bind(this) }))) : o.default.createElement(a.Row, null, o.default.createElement(a.Label, null, this.props.label), o.default.createElement(a.Control, null, o.default.createElement(a.Number, { decimals: this.props.decimals, value: this.state.value, onChange: this.handleChange.bind(this), onFinishChange: this.handleFinishChange.bind(this), width: "100%" }))) } }, { key: "handleFinishChange", value: function(e) { this.setState({ value: e }), this.props.onFinishChange && this.props.onFinishChange(e) } }, { key: "handleChange", value: function(e) { this.setState({ value: e }), this.props.onChange && this.props.onChange(e) } }]), t
            }();
            t.default = u, u.propTypes = { value: i.default.number, min: i.default.number, max: i.default.number, step: i.default.number, label: i.default.string, onChange: i.default.func, onFinishChange: i.default.func }, u.defaultProps = { value: 0 }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = n(14);

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.handleChange = function(e) { n.props.onChange && n.props.onChange(e.target.value), n.props.onFinishChange && n.props.onFinishChange(e.target.value) }, n.state = { options: n.props.options }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "componentWillReceiveProps", value: function(e) { e.options !== this.props.options && e.options !== this.state.options && this.setState({ options: e.options }) } }, { key: "render", value: function() { var e = this; return o.default.createElement(a.Row, null, o.default.createElement(a.Label, null, this.props.label), o.default.createElement(a.Control, null, o.default.createElement("select", { onChange: this.handleChange, value: this.props.value, style: { backgroundColor: this.context.style.lowlight, color: this.context.style.highlight, font: this.context.style.font, height: this.context.style.computed.itemHeight, lineHeight: this.context.style.computed.itemHeight, WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none", MozAppearance: "none", border: "none", outline: "none", cursor: "pointer" } }, this.state.options.map(function(t, n) { return o.default.createElement("option", { value: t, key: t + n, style: { backgroundColor: e.context.style.font } }, t) })))) } }]), t
            }();
            t.default = u, u.propTypes = { options: i.default.array.isRequired, label: i.default.string, onChange: i.default.func, onFinishChange: i.default.func }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = s(n(2)),
                o = s(n(0)),
                a = n(14);

            function s(e) { return e && e.__esModule ? e : { default: e } }
            var u = function(e) {
                function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.state = { value: n.props.value }, n }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{ key: "render", value: function() { return o.default.createElement(a.Row, null, o.default.createElement(a.Label, null, this.props.label), o.default.createElement(a.Control, null, o.default.createElement("input", { type: "text", value: this.state.value, onChange: this.handleChange.bind(this), onBlur: this.onBlur.bind(this), onKeyDown: this.onKeyDown.bind(this), style: { color: this.context.style.highlight, font: this.context.style.font, backgroundColor: this.context.style.lowlight, padding: this.context.style.paddingY + "px " + this.context.style.paddingX + "px", width: "100%", border: "none", outline: "none" } }))) } }, { key: "componentWillReceiveProps", value: function(e) { "value" in e && this.setState({ value: e.value }) } }, { key: "onKeyDown", value: function(e) { 13 === e.which && this.props.onFinishChange && this.props.onFinishChange(e.target.value) } }, { key: "onBlur", value: function(e) { this.props.onFinishChange && this.props.onFinishChange(e.target.value) } }, { key: "handleChange", value: function(e) { this.setState({ value: e.target.value }), this.props.onChange && this.props.onChange(e.target.value) } }]), t
            }();
            t.default = u, u.propTypes = { value: i.default.string, label: i.default.string, onChange: i.default.func, onFinishChange: i.default.func }, u.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.Gradient = void 0;
            var r, i = n(259),
                o = (r = i) && r.__esModule ? r : { default: r };
            t.Gradient = o.default
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = c(n(2)),
                o = c(n(0)),
                a = c(n(260)),
                s = n(14),
                u = c(n(262));

            function c(e) { return e && e.__esModule ? e : { default: e } }
            var l = function(e) {
                function t(e) {
                    ! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t);
                    var n = function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return n.handleStopFieldMouseDown = function(e) {
                        if (e.target === n.refs.stopfield) {
                            var t = n.state.stops.slice(),
                                r = e.target.getBoundingClientRect(),
                                i = (e.pageX - r.left) / r.width,
                                o = n.getGradientValue(n.getCleanStops(), i);
                            t.push({ stop: i, red: o.red, green: o.green, blue: o.blue });
                            var s = (0, a.default)(n.state, { $set: { stops: t, selectedStop: t.length - 1 } });
                            n.setState(s, function() { n.handleChange(), n.handleFinishChange() })
                        }
                    }, n.handleRemoveStop = function() {
                        var e = n.state.stops.slice();
                        e.splice(n.state.selectedStop, 1);
                        var t = (0, a.default)(n.state, { $set: { stops: e, selectedStop: 0 } });
                        n.setState(t, function() { n.handleChange(), n.handleFinishChange() })
                    }, n.handleChangeRed = function(e) {
                        var t = n.state.stops.slice();
                        t[n.state.selectedStop].red = parseInt(e);
                        var r = (0, a.default)(n.state, { $set: { stops: t } });
                        n.setState(r, n.handleChange)
                    }, n.handleChangeGreen = function(e) {
                        var t = n.state.stops.slice();
                        t[n.state.selectedStop].green = parseInt(e);
                        var r = (0, a.default)(n.state, { $set: { stops: t } });
                        n.setState(r, n.handleChange)
                    }, n.handleChangeBlue = function(e) {
                        var t = n.state.stops.slice();
                        t[n.state.selectedStop].blue = parseInt(e);
                        var r = (0, a.default)(n.state, { $set: { stops: t } });
                        n.setState(r, n.handleChange)
                    }, n.handleChange = function() { n.props.onChange && n.props.onChange(n.getCleanStops()) }, n.handleFinishChange = function() { n.props.onFinishChange && n.props.onFinishChange(n.getCleanStops()) }, n.handleCanvasClick = function() { n.setState({ expanded: !n.state.expanded }) }, n.handleStopChange = function(e) {
                        var t = n.state.stops.slice();
                        t[e.index].stop = e.stop;
                        var r = (0, a.default)(n.state, { $set: { stops: t } });
                        n.setState(r, n.handleChange)
                    }, n.handleStopClick = function(e) { n.setState({ selectedStop: e.index }) }, n.state = { expanded: n.props.expanded, stops: n.props.stops, selectedStop: 0 }, n
                }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{
                    key: "render",
                    value: function() {
                        var e = this,
                            t = this.context.style.computed.fontHeight;
                        return o.default.createElement(s.Row, null, o.default.createElement(s.Label, null, this.props.label), o.default.createElement(s.Control, null, o.default.createElement("canvas", { ref: "canvas", onClick: this.handleCanvasClick.bind(this), style: { width: this.context.style.controlWidth + "px", position: "relative", height: this.context.style.computed.itemHeight + "px", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none", cursor: "pointer" } }), this.state.expanded && o.default.createElement("div", null, o.default.createElement("div", { ref: "stopfield", onMouseDown: this.handleStopFieldMouseDown, style: { width: this.context.style.controlWidth + "px", height: 1.875 * t + "px", boxSizing: "border-box", position: "relative", overflow: "hidden", cursor: "pointer" } }, this.state.stops.map(function(t, n) { return o.default.createElement(u.default, { key: "stop" + n, index: n, stop: t.stop, red: t.red, green: t.green, blue: t.blue, selected: n === e.state.selectedStop, onClick: e.handleStopClick.bind(e), onChange: e.handleStopChange.bind(e), onFinishChange: e.handleFinishChange.bind(e) }) })), o.default.createElement(s.ColorRange, { label: "Red", value: this.state.stops[this.state.selectedStop].red, onChange: this.handleChangeRed.bind(this), onFinishChange: this.handleFinishChange.bind(this) }), o.default.createElement(s.ColorRange, { label: "Green", value: this.state.stops[this.state.selectedStop].green, onChange: this.handleChangeGreen.bind(this), onFinishChange: this.handleFinishChange.bind(this) }), o.default.createElement(s.ColorRange, { label: "Blue", value: this.state.stops[this.state.selectedStop].blue, onChange: this.handleChangeBlue.bind(this), onFinishChange: this.handleFinishChange.bind(this) }), this.state.stops.length > 1 && o.default.createElement("div", { onClick: this.handleRemoveStop, style: { backgroundColor: this.context.style.lowlight, color: this.context.style.highlight, font: this.context.style.font, padding: this.context.style.paddingY + "px 0px", marginTop: this.context.style.paddingY + "px", textAlign: "center", cursor: "pointer", width: "100%", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" } }, "Remove Stop"))))
                    }
                }, { key: "componentDidMount", value: function() { this.updateCanvas() } }, { key: "componentDidUpdate", value: function() { this.updateCanvas() } }, {
                    key: "componentWillReceiveProps",
                    value: function(e) {
                        var t = this,
                            n = (0, a.default)(this.state, { $set: { stops: e.stops } });
                        this.setState(n, function() { t.handleChange(), t.handleFinishChange() })
                    }
                }, {
                    key: "getCleanStops",
                    value: function() {
                        var e = this.state.stops.slice();
                        e.sort(function(e, t) { return e.stop - t.stop }), e[0].stop > 0 && e.unshift({ stop: 0, red: e[0].red, green: e[0].green, blue: e[0].blue });
                        var t = e[e.length - 1];
                        return t.stop < 1 && e.push({ stop: 1, red: t.red, green: t.green, blue: t.blue }), e
                    }
                }, {
                    key: "getGradientValue",
                    value: function(e, t) {
                        for (var n = 0; n < e.length - 1; n++)
                            if (t >= e[n].stop && t <= e[n + 1].stop) {
                                var r = e[n],
                                    i = e[n + 1],
                                    o = (t - r.stop) / (i.stop - r.stop);
                                return { red: Math.round(r.red + o * (i.red - r.red)), green: Math.round(r.green + o * (i.green - r.green)), blue: Math.round(r.blue + o * (i.blue - r.blue)) }
                            }
                        throw "Error calculating gradient value."
                    }
                }, {
                    key: "updateCanvas",
                    value: function() {
                        var e = this.getCleanStops(),
                            t = this.refs.canvas;
                        t.width = 512, t.height = 1;
                        for (var n = t.getContext("2d"), r = 0; r < t.width; r++) {
                            var i = r / (t.width - 1),
                                o = this.getGradientValue(e, i);
                            n.fillStyle = "rgb(" + o.red + ", " + o.green + ", " + o.blue + ")", n.fillRect(r, 0, 1, 1)
                        }
                    }
                }]), t
            }();
            t.default = l, l.propTypes = { expanded: i.default.bool, stops: i.default.array, label: i.default.string, onChange: i.default.func, onFinishChange: i.default.func }, l.defaultProps = { expanded: !1, stops: [{ red: 255, green: 0, blue: 0, stop: .125 }, { red: 255, green: 255, blue: 0, stop: .5 }, { red: 255, green: 255, blue: 255, stop: .875 }] }, l.contextTypes = { style: i.default.object }
        }, function(e, t, n) {
            var r = n(261),
                i = Object.prototype.hasOwnProperty,
                o = Array.prototype.splice,
                a = Object.prototype.toString,
                s = function(e) { return a.call(e).slice(8, -1) },
                u = Object.assign || function(e, t) { return c(t).forEach(function(n) { i.call(t, n) && (e[n] = t[n]) }), e },
                c = "function" == typeof Object.getOwnPropertySymbols ? function(e) { return Object.keys(e).concat(Object.getOwnPropertySymbols(e)) } : function(e) { return Object.keys(e) };

            function l(e) { if (Array.isArray(e)) return u(e.constructor(e.length), e); if ("Map" === s(e)) return new Map(e); if ("Set" === s(e)) return new Set(e); if (e && "object" == typeof e) { var t = Object.getPrototypeOf(e); return u(Object.create(t), e) } return e }

            function h() {
                var e = u({}, p);
                return t.extend = function(t, n) { e[t] = n }, t.isEquals = function(e, t) { return e === t }, t;

                function t(n, o) {
                    "function" == typeof o && (o = { $apply: o }), Array.isArray(n) && Array.isArray(o) || r(!Array.isArray(o), "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value."), r("object" == typeof o && null !== o, "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the following commands: %s.", Object.keys(e).join(", "));
                    var a = n;
                    return c(o).forEach(function(r) {
                        if (i.call(e, r)) {
                            var u = n === a;
                            a = e[r](o[r], a, o, n), u && t.isEquals(a, n) && (a = n)
                        } else {
                            var c = "Map" === s(n) ? t(n.get(r), o[r]) : t(n[r], o[r]),
                                h = "Map" === s(a) ? a.get(r) : a[r];
                            t.isEquals(c, h) && (void 0 !== c || i.call(n, r)) || (a === n && (a = l(n)), "Map" === s(a) ? a.set(r, c) : a[r] = c)
                        }
                    }), a
                }
            }
            var p = {
                    $push: function(e, t, n) { return f(t, n, "$push"), e.length ? t.concat(e) : t },
                    $unshift: function(e, t, n) { return f(t, n, "$unshift"), e.length ? e.concat(t) : t },
                    $splice: function(e, t, n, i) { return function(e, t) { r(Array.isArray(e), "Expected $splice target to be an array; got %s", e), v(t.$splice) }(t, n), e.forEach(function(e) { v(e), t === i && e.length && (t = l(i)), o.apply(t, e) }), t },
                    $set: function(e, t, n) { return function(e) { r(1 === Object.keys(e).length, "Cannot have more than one key in an object with $set") }(n), e },
                    $toggle: function(e, t) { m(e, "$toggle"); var n = e.length ? l(t) : t; return e.forEach(function(e) { n[e] = !t[e] }), n },
                    $unset: function(e, t, n, r) { return m(e, "$unset"), e.forEach(function(e) { Object.hasOwnProperty.call(t, e) && (t === r && (t = l(r)), delete t[e]) }), t },
                    $add: function(e, t, n, r) {
                        return g(t, "$add"), m(e, "$add"), "Map" === s(t) ? e.forEach(function(e) {
                            var n = e[0],
                                i = e[1];
                            t === r && t.get(n) !== i && (t = l(r)), t.set(n, i)
                        }) : e.forEach(function(e) { t !== r || t.has(e) || (t = l(r)), t.add(e) }), t
                    },
                    $remove: function(e, t, n, r) { return g(t, "$remove"), m(e, "$remove"), e.forEach(function(e) { t === r && t.has(e) && (t = l(r)), t.delete(e) }), t },
                    $merge: function(e, t, n, i) { var o, a; return o = t, r((a = e) && "object" == typeof a, "update(): $merge expects a spec of type 'object'; got %s", a), r(o && "object" == typeof o, "update(): $merge expects a target of type 'object'; got %s", o), c(e).forEach(function(n) { e[n] !== t[n] && (t === i && (t = l(i)), t[n] = e[n]) }), t },
                    $apply: function(e, t) { var n; return r("function" == typeof(n = e), "update(): expected spec of $apply to be a function; got %s.", n), e(t) }
                },
                d = h();

            function f(e, t, n) { r(Array.isArray(e), "update(): expected target of %s to be an array; got %s.", n, e), m(t[n], n) }

            function m(e, t) { r(Array.isArray(e), "update(): expected spec of %s to be an array; got %s. Did you forget to wrap your parameter in an array?", t, e) }

            function v(e) { r(Array.isArray(e), "update(): expected spec of $splice to be an array of arrays; got %s. Did you forget to wrap your parameters in an array?", e) }

            function g(e, t) {
                var n = s(e);
                r("Map" === n || "Set" === n, "update(): %s expects a target of type Set or Map; got %s", t, n)
            }
            e.exports = d, e.exports.default = d, e.exports.newContext = h
        }, function(e, t, n) {
            "use strict";
            e.exports = function(e, t, n, r, i, o, a, s) {
                if (!e) {
                    var u;
                    if (void 0 === t) u = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
                    else {
                        var c = [n, r, i, o, a, s],
                            l = 0;
                        (u = new Error(t.replace(/%s/g, function() { return c[l++] }))).name = "Invariant Violation"
                    }
                    throw u.framesToPop = 1, u
                }
            }
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t }
                }(),
                i = a(n(2)),
                o = a(n(0));

            function a(e) { return e && e.__esModule ? e : { default: e } }
            var s = function(e) {
                function t() {
                    return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t),
                        function(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                }
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, o.default.PureComponent), r(t, [{
                    key: "render",
                    value: function() {
                        var e = this.props.selected ? 1.25 : 1,
                            t = this.context.style.computed.fontHeight / 58 * e,
                            n = this.context.style.label.fontColor;
                        return o.default.createElement("svg", { ref: "stop", width: 58 * t + "px", height: 87 * t + "px", onMouseDown: this.handleMouseDown.bind(this), style: { left: this.props.stop * this.context.style.controlWidth - e * this.context.style.computed.fontHeight / 2 + "px", position: "absolute", cursor: "pointer" } }, o.default.createElement("g", { transform: "scale(" + t + ")" }, o.default.createElement("g", { transform: "translate(4, 9)" }, o.default.createElement("path", { d: "M0 25 L0 75 L50 75 L50 25 L25 0 Z", fill: "rgb(" + this.props.red + ", " + this.props.green + ", " + this.props.blue + ")", stroke: n, strokeWidth: "4" }))))
                    }
                }, {
                    key: "handleMouseDown",
                    value: function(e) {
                        e.preventDefault();
                        var t = this.refs.stop.parentNode.getBoundingClientRect(),
                            n = function(e) {
                                var n = (e.pageX - t.left) / t.width;
                                n = Math.max(0, Math.min(1, n)), this.props.onChange({ index: this.props.index, stop: n })
                            }.bind(this),
                            r = function() { window.removeEventListener("mousemove", n), window.removeEventListener("mouseup", r), this.props.onFinishChange() }.bind(this);
                        window.addEventListener("mousemove", n), window.addEventListener("mouseup", r), this.props.onClick({ index: this.props.index })
                    }
                }]), t
            }();
            t.default = s, s.propTypes = { selected: i.default.bool, stop: i.default.number, red: i.default.number, green: i.default.number, blue: i.default.number, index: i.default.number.isRequired, onChange: i.default.func, OnFinishChange: i.default.func, onClick: i.default.func }, s.defaultProps = { selected: !1, stop: 0, red: 0, green: 0, blue: 0 }, s.contextTypes = { style: i.default.object }
        }, function(e, t, n) { e.exports = n(264) }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            var r = c(n(118)),
                i = c(n(50)),
                o = c(n(51)),
                a = c(n(119)),
                s = c(n(121)),
                u = c(n(0));

            function c(e) { return e && e.__esModule ? e : { default: e } }
            var l = function() { return u.default.createElement("span", null) },
                h = function(e) {
                    function t() {
                        var e;
                        (0, i.default)(this, t);
                        for (var n = arguments.length, o = Array(n), s = 0; s < n; s++) o[s] = arguments[s];
                        var u = (0, a.default)(this, (e = (0, r.default)(t)).call.apply(e, [this].concat(o)));
                        return u.state = { canRender: !1 }, u
                    }
                    return (0, s.default)(t, e), (0, o.default)(t, [{ key: "componentDidMount", value: function() { this.setState({ canRender: !0 }) } }, {
                        key: "render",
                        value: function() {
                            var e = this.props,
                                t = e.children,
                                n = e.onSSR,
                                r = void 0 === n ? u.default.createElement(l, null) : n;
                            return this.state.canRender ? t : r
                        }
                    }]), t
                }(u.default.Component);
            t.default = h
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r = i(n(0));
            i(n(266));

            function i(e) { return e && e.__esModule ? e : { default: e } }
            t.default = function(e) { return r.default.createElement("div", null, e.children) }
        }, , function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r = u(n(0)),
                i = function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var n in e)
                            if (Object.prototype.hasOwnProperty.call(e, n)) {
                                var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
                                r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n]
                            }
                    return t.default = e, t
                }(n(37)),
                o = u(n(268)),
                a = u(n(269)),
                s = u(n(270));

            function u(e) { return e && e.__esModule ? e : { default: e } }

            function c(e) { return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) }

            function l(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function h(e, t) { return !t || "object" !== c(t) && "function" != typeof t ? p(e) : t }

            function p(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }
            var d = n(126),
                f = function(e) {
                    function t() { var e, n, i;! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t); for (var u = arguments.length, c = new Array(u), l = 0; l < u; l++) c[l] = arguments[l]; return h(i, (n = i = h(this, (e = t.__proto__ || Object.getPrototypeOf(t)).call.apply(e, [this].concat(c))), Object.defineProperty(p(i), "getSlider", { configurable: !0, enumerable: !0, writable: !0, value: function(e, t) { return "f" === e.type ? r.default.createElement(o.default, { name: t, uniform: e, key: t + e.value }) : d(e.type, "fv") && !0 === e.vector ? r.default.createElement(s.default, { uniform: e, label: t, key: t + e.value }) : d(e.type, "fv") ? r.default.createElement(a.default, { uniform: e, label: t, key: t + e.value }) : null } }), n)) }
                    var n, u, c;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                    }(t, r.default.Component), n = t, (u = [{
                        key: "render",
                        value: function() {
                            for (var e = [], t = Object.keys(this.props.uniforms), n = {}, o = [], a = {}, s = 0, u = t.length; s < u; s += 1) {
                                var c = this.props.uniforms[t[s]];
                                void 0 !== c.folder ? (void 0 === n[c.folder] && (o.push(c.folder), n[c.folder] = [], a[c.folder] = e.length), n[c.folder].push(this.getSlider(c, t[s]))) : !0 !== c.hideInGui && e.push(this.getSlider(c, t[s]))
                            }
                            return o.reverse(), o.forEach(function(t) { e.splice(a[t], 0, r.default.createElement(i.Folder, { label: t, key: "folder_".concat(t) }, n[t])) }), r.default.createElement(i.Folder, { label: this.props.label, expanded: !0 }, e)
                        }
                    }]) && l(n.prototype, u), c && l(n, c), t
                }();
            t.default = f
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r, i = (r = n(0)) && r.__esModule ? r : { default: r },
                o = function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var n in e)
                            if (Object.prototype.hasOwnProperty.call(e, n)) {
                                var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
                                r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n]
                            }
                    return t.default = e, t
                }(n(37));

            function a(e) { return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) }

            function s(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function u(e, t) { return !t || "object" !== a(t) && "function" != typeof t ? function(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t }
            var c = function(e) {
                function t() { return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), u(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments)) }
                var n, r, a;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, i.default.Component), n = t, (r = [{ key: "render", value: function() { var e = this; return i.default.createElement(o.Number, { label: this.props.name, value: this.props.uniform.value, min: this.props.uniform.min, max: this.props.uniform.max, step: this.props.uniform.step, onChange: function(t) { void 0 !== e.props.uniform.callback && e.props.uniform.value !== t && e.props.uniform.callback(t), e.props.uniform.value = t } }) } }]) && s(n.prototype, r), a && s(n, a), t
            }();
            t.default = c
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r, i = (r = n(0)) && r.__esModule ? r : { default: r },
                o = function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var n in e)
                            if (Object.prototype.hasOwnProperty.call(e, n)) {
                                var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
                                r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n]
                            }
                    return t.default = e, t
                }(n(37));

            function a(e) { return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) }

            function s(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function u(e, t) { return !t || "object" !== a(t) && "function" != typeof t ? function(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) : t }
            var c = function(e) {
                function t() { return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), u(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments)) }
                var n, r, a;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, i.default.Component), n = t, (r = [{
                    key: "render",
                    value: function() {
                        var e = this;
                        if (!0 === this.props.uniform.color) return i.default.createElement(o.Color, { label: this.props.label, red: Math.round(255 * this.props.uniform.value[0]), green: Math.round(255 * this.props.uniform.value[1]), blue: Math.round(255 * this.props.uniform.value[2]), onChange: function(t) { e.props.uniform.value[0] = t.red / 255, e.props.uniform.value[1] = t.green / 255, e.props.uniform.value[2] = t.blue / 255 } });
                        for (var t = [], n = function(n, r) {
                                var a = n;
                                if (void 0 !== e.props.uniform.gui) {
                                    var s = e.props.uniform.gui[a % e.props.uniform.gui.length];
                                    t.push(i.default.createElement(o.Number, { label: s.name || a.toString(), value: e.props.uniform.value[a], min: s.min, max: s.max, step: s.step, onChange: function(t) { e.props.uniform.value[a] = t }, key: e.props.label + a }))
                                } else t.push(i.default.createElement(o.Number, { label: a.toString(), value: e.props.uniform.value[a], min: e.props.uniform.min, max: e.props.uniform.max, step: e.props.uniform.step, onChange: function(t) { e.props.uniform.value[a] = t, void 0 !== e.props.uniform.callback && e.props.uniform.callback(e.props.uniform.value) }, key: e.props.label + a }))
                            }, r = 0, a = this.props.uniform.value.length; r < a; r += 1) n(r);
                        return i.default.createElement(o.Folder, { label: this.props.label }, t)
                    }
                }]) && s(n.prototype, r), a && s(n, a), t
            }();
            t.default = c
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r, i = (r = n(0)) && r.__esModule ? r : { default: r },
                o = function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var n in e)
                            if (Object.prototype.hasOwnProperty.call(e, n)) {
                                var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
                                r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n]
                            }
                    return t.default = e, t
                }(n(37));

            function a(e) { return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) }

            function s(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function u(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }
            var c = function(e) {
                function t(e) { var n, r, i; return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), r = this, i = (t.__proto__ || Object.getPrototypeOf(t)).call(this, e), n = !i || "object" !== a(i) && "function" != typeof i ? u(r) : i, Object.defineProperty(u(n), "updateVector", { configurable: !0, enumerable: !0, writable: !0, value: function() { n.props.uniform.value[0] = Math.cos(n.sideAngle) * Math.sin(n.upAngle) * n.length, n.props.uniform.value[1] = Math.cos(n.upAngle) * n.length, n.props.uniform.value[2] = Math.sin(n.sideAngle) * Math.sin(n.upAngle) * n.length, console.log(n.props.uniform.value) } }), n.sideAngle = Math.atan2(e.uniform.value[2], e.uniform.value[0]), n.upAngle = Math.atan2(1, e.uniform.value[1]), n.length = Math.sqrt(e.uniform.value[0] * e.uniform.value[0] + e.uniform.value[1] * e.uniform.value[1] + e.uniform.value[2] * e.uniform.value[2]), n }
                var n, r, c;
                return function(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }(t, i.default.Component), n = t, (r = [{ key: "render", value: function() { var e = this; return i.default.createElement(o.Folder, { label: this.props.label }, i.default.createElement(o.Number, { label: "side", value: this.sideAngle, min: -Math.PI, max: Math.PI, step: 1e-4, onChange: function(t) { e.sideAngle = t, e.updateVector() } }), i.default.createElement(o.Number, { label: "up", value: this.upAngle, min: -Math.PI, max: Math.PI, step: 1e-4, onChange: function(t) { e.upAngle = t, e.updateVector() } }), i.default.createElement(o.Number, { label: "length", value: this.length, onChange: function(t) { e.length = t, e.updateVector() } })) } }]) && s(n.prototype, r), c && s(n, c), t
            }();
            t.default = c
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r = x(n(117)),
                i = x(n(0)),
                o = n(52),
                a = x(n(272)),
                s = x(n(273)),
                u = x(n(274)),
                c = x(n(275)),
                l = x(n(278)),
                h = x(n(279)),
                p = x(n(280)),
                d = x(n(281)),
                f = x(n(282)),
                m = x(n(283)),
                v = x(n(284)),
                g = x(n(127)),
                y = x(n(285)),
                _ = n(287);

            function x(e) { return e && e.__esModule ? e : { default: e } }

            function b(e) { return (b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) }

            function w(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }

            function M(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }
            var E = 60,
                S = .04,
                T = function(e) {
                    function t(e) {
                        var n, r, i;
                        return function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), r = this, i = (t.__proto__ || Object.getPrototypeOf(t)).call(this, e), n = !i || "object" !== b(i) && "function" != typeof i ? M(r) : i, Object.defineProperty(M(n), "onPointerStart", {
                            configurable: !0,
                            enumerable: !0,
                            writable: !0,
                            value: function(e) {
                                n.cacheMousePositionFromEvent(e), n.raycaster.setFromCamera(n.glMouse, n.camera), n.startCollider.visible = !0;
                                var t = n.raycaster.intersectObject(n.startCollider);
                                if (n.startCollider.visible = !1, t.length > 0) {
                                    var r = n.raycaster.intersectObject(n.nipMesh);
                                    r.length > 0 && (n.uniforms.mousePressed.value = 1, n.uniforms.mousePositionStart.value[0] = n.glMouse.x, n.uniforms.mousePositionStart.value[1] = n.glMouse.y, n.mouseStartWorldPosition = r[0].point, n.intersectTangent.set(0, -1, 0), n.intersectTangent.cross(r[0].face.normal), n.uniforms.intersectBiTangent.value[0] = n.intersectTangent.x, n.uniforms.intersectBiTangent.value[1] = n.intersectTangent.y, n.uniforms.intersectBiTangent.value[2] = n.intersectTangent.z, n.intersectTangent.cross(r[0].face.normal), n.uniforms.intersectTangent.value[0] = n.intersectTangent.x, n.uniforms.intersectTangent.value[1] = n.intersectTangent.y, n.uniforms.intersectTangent.value[2] = n.intersectTangent.z, n.intersectMesh.position.x = n.mouseStartWorldPosition.x, n.intersectMesh.position.y = n.mouseStartWorldPosition.y, n.intersectMesh.position.z = n.mouseStartWorldPosition.z, n.uniforms.worldPositionStart.value[0] = n.mouseStartWorldPosition.x, n.uniforms.worldPositionStart.value[1] = n.mouseStartWorldPosition.y, n.uniforms.worldPositionStart.value[2] = n.mouseStartWorldPosition.z, n.setDragOffset(n.mouseStartWorldPosition), n.intersectMesh.lookAt(n.camera.position), n.isDragging = !0, n.onPointerMove())
                                }
                            }
                        }), Object.defineProperty(M(n), "onPointerMove", {
                            configurable: !0,
                            enumerable: !0,
                            writable: !0,
                            value: function(e) {
                                if (n.isDragging) {
                                    void 0 !== e && n.cacheMousePositionFromEvent(e), n.raycaster.setFromCamera(n.glMouse, n.camera), n.intersectMesh.visible = !0, n.staticIntersectMesh.visible = !0;
                                    var t = n.raycaster.intersectObject(n.staticIntersectMesh),
                                        r = n.raycaster.intersectObject(n.intersectMesh);
                                    n.intersectMesh.visible = !1, n.staticIntersectMesh.visible = !1, t.length > 0 && r.length > 0 ? t[0].distance < r[0].distance ? n.setDragOffset(t[0].point) : n.setDragOffset(r[0].point) : t.length > 0 ? n.setDragOffset(t[0].point) : r.length > 0 && n.setDragOffset(r[0].point), void 0 !== e && e.preventDefault()
                                }
                            }
                        }), Object.defineProperty(M(n), "setDragOffset", {
                            configurable: !0,
                            enumerable: !0,
                            writable: !0,
                            value: function(e, t) {
                                n.uniforms.mousePositionDelta.value[0] = e.x - n.mouseStartWorldPosition.x, n.uniforms.mousePositionDelta.value[1] = e.y - n.mouseStartWorldPosition.y, n.uniforms.mousePositionDelta.value[2] = e.z - n.mouseStartWorldPosition.z;
                                var r = Math.sqrt(Math.pow(n.uniforms.mousePositionDelta.value[0], 2) + Math.pow(n.uniforms.mousePositionDelta.value[1], 2) + Math.pow(n.uniforms.mousePositionDelta.value[2], 2));
                                if (n.uniforms.mousePositionDeltaLength.value = r, n.uniforms.mousePositionDeltaRelLength.value = r / n.uniforms.maxDragDistance.value, r > n.uniforms.maxDragDistance.value) {
                                    n.uniforms.mousePositionDelta.value[0] /= r, n.uniforms.mousePositionDelta.value[1] /= r, n.uniforms.mousePositionDelta.value[2] /= r;
                                    var i = Math.min(r, n.uniforms.maxDragDistance.value);
                                    n.uniforms.mousePositionDelta.value[0] *= i, n.uniforms.mousePositionDelta.value[1] *= i, n.uniforms.mousePositionDelta.value[2] *= i, n.uniforms.mousePositionDeltaLength.value = i, n.uniforms.mousePositionDeltaRelLength.value = i / n.uniforms.maxDragDistance.value
                                }
                            }
                        }), Object.defineProperty(M(n), "onPointerExit", {
                            configurable: !0,
                            enumerable: !0,
                            writable: !0,
                            value: function(e) {
                                if (n.isDragging) {
                                    var t = Math.sqrt(Math.pow(n.uniforms.mousePositionDelta.value[0], 2) + Math.pow(n.uniforms.mousePositionDelta.value[1], 2) + Math.pow(n.uniforms.mousePositionDelta.value[2], 2));
                                    n.uniforms.mousePositionDeltaRelLength.value = 0;
                                    var r = t / n.uniforms.meshBounds.value[0],
                                        i = (0, _.clamp)(Math.pow(4 * r, 2), .3, 1.2);
                                    n.audioPlayer.playRelease(i), n.isDragging = !1
                                }
                                n.uniforms.mousePressed.value = 0, n.uniforms.mousePositionDelta.value[0] = 0, n.uniforms.mousePositionDelta.value[1] = 0, n.uniforms.mousePositionDelta.value[2] = 0, n.uniforms.worldPositionStart.value[0] = -9999.9, n.uniforms.worldPositionStart.value[1] = -9999.9, n.uniforms.worldPositionStart.value[2] = -9999.9, n.uniforms.mousePositionStart.value[0] = -9999.9, n.uniforms.mousePositionStart.value[1] = -9999.9, void 0 !== n.intersectMesh && (n.intersectMesh.visible = !1, n.staticIntersectMesh.visible = !1)
                            }
                        }), Object.defineProperty(M(n), "onResize", {
                            configurable: !0,
                            enumerable: !0,
                            writable: !0,
                            value: function() {
                                var e = n.containerRef.getBoundingClientRect(),
                                    t = e.height / e.height;
                                n.uniforms.aspectRatio.value = t, n.renderer.setSize(e.height, e.height), n.uniforms.screenSize.value = [e.height, e.height, 1 / e.height, 1 / e.height], n.camera.aspect = t, n.camera.updateProjectionMatrix()
                            }
                        }), Object.defineProperty(M(n), "renderLoop", {
                            configurable: !0,
                            enumerable: !0,
                            writable: !0,
                            value: function() {
                                var e = Math.min(n.clock.getDelta(), .05);
                                n.deltaCounter += e, n.uniforms.time.value += e, n.deltaCounter > S && (n.uniforms.offsetsMap.value = n.offsetPingPongRunner.render(n.uniforms.prevOffsetsMap), n.worldPositionCompute.render(), n.normalsCompute.render(), n.deltaCounter %= S), n.uniforms.relOffsetProgress.value = n.deltaCounter / S, n.renderer.render(n.scene, n.camera), n.frameRequest = requestAnimationFrame(n.renderLoop)
                            }
                        }), n.normalizedMousePosition = { x: 0, y: 0 }, n.glMouse = { x: 0, y: 0 }, n.glMouseStart = { x: 0, y: 0 }, n.cameraBasePosition = [0, 0, 0], n.cameraOffsetPosition = [0, 0, 0], n.cameraOffsetTargetPosition = [0, 0, 0], n.cameraPositions = [], n.cameraRotations = [], n.cameraProgressTarget = 0, n.cameraProgress = 0, n.currentCameraIndex = 0, n.cameraRotation = [0, 0, 0], n.wheelDeltaCounter = 0, n.runWheelDeltaCounter = !0, n.deltaCounter = S, n.intersectTangent = new o.Vector3, n.isDragging = !1, n
                    }
                    var n, x, T;
                    return function(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                    }(t, i.default.Component), n = t, (x = [{
                        key: "componentDidMount",
                        value: function() {
                            var e = this;
                            o.Cache.enabled = !0;
                            var t = this.containerRef.getBoundingClientRect();
                            this.clock = new o.Clock, this.renderer = new o.WebGLRenderer({ canvas: this.canvasRef, alpha: !0 }), this.renderer.setClearColor(16777215, 0), this.renderer.setPixelRatio(window.devicePixelRatio || 1), this.renderer.setSize(t.width, t.height), this.renderer.sortObjects = !1;
                            (0, a.default)(this.renderer.context);
                            this.audioPlayer = new y.default, this.audioPlayer.setup(), this.raycaster = new o.Raycaster, this.scene = new o.Scene, this.camera = new o.PerspectiveCamera(17.5, t.width / t.height, .1, 1e4), this.camera.position.z = -.3, this.camera.lookAt(new o.Vector3(0, 0, 0)), this.uniforms = { map: { type: "t", value: null }, wrinklesMap: { type: "t", value: null }, normalMap: { type: "t", value: null }, stretchMap: { type: "t", value: null }, prevOffsetsMap: { type: "t", value: null }, offsetsMap: { type: "t", value: null }, relOffsetProgress: { type: "f", value: 1, hideInGui: !0 }, positionsMap: { type: "t", value: null }, normalsMap: { type: "t", value: null }, time: { type: "f", value: 0, hideInGui: !0 }, aspectRatio: { type: "f", value: 1, hideInGui: !0 }, meshBounds: { type: "2fv", value: [1, 1], hideInGui: !0 }, mousePosition: { type: "4fv", value: [0, 0, 0, 0], hideInGui: !0 }, mousePressed: { type: "f", value: 0, hideInGui: !0 }, mousePositionStart: { type: "2fv", value: [-999.9, -999.9], hideInGui: !0 }, worldPositionStart: { type: "3fv", value: [0, 0, 0], hideInGui: !0 }, mousePositionDelta: { type: "3fv", value: [0, 0, 0], hideInGui: !0 }, mousePositionDeltaRelLength: { type: "f", value: 0, hideInGui: !0 }, mousePositionDeltaLength: { type: "f", value: 0, hideInGui: !0 }, intersectTangent: { type: "3fv", value: [0, 0, 0], hideInGui: !0 }, intersectBiTangent: { type: "3fv", value: [0, 0, 0], hideInGui: !0 }, positionUVOffsets: { type: "3fv", value: [0, 0, 0], hideInGui: !0 }, lightDir: { type: "3fv", value: [-.24990158808505084, .5864018156692344, -.2892785972940181], vector: !0 }, screenSize: { type: "4fv", value: [t.width, t.height, 1 / t.width, 1 / t.height], hideInGui: !0 }, smoothedGlMouse: { type: "2fv", value: [0, 0], hideInGui: !0 }, fadeEdge: { type: "2fv", value: [.67, .38], gui: [{ min: 0, max: 1, step: 1e-4, name: "edge" }, { min: 0, max: .5, step: 1e-4, name: "width" }] }, pullArea: { type: "2fv", value: [.1, .2], gui: [{ min: 0, max: 1, step: 1e-4, name: "edge" }, { min: 0, max: 1, step: 1e-4, name: "width" }] }, shiftArea: { type: "2fv", value: [.5, .9], gui: [{ min: 0, max: 1, step: 1e-4, name: "edge" }, { min: 0, max: 1, step: 1e-4, name: "width" }] }, stretch: { type: "4fv", value: [0, .17, .56, 1.5], gui: [{ min: 0, max: 1, step: 1e-4, name: "min" }, { min: 0, max: 1, step: 1e-4, name: "max" }, { min: 0, max: .99, step: 1e-4, name: "topEdge" }, { min: 0, max: 100, step: .1, name: "numRepeats" }] }, stretchStrength: { type: "2fv", value: [.16, .05], gui: [{ min: 0, max: 1, step: 1e-4, name: "mult" }, { min: 0, max: 1, step: 1e-4, name: "clamp" }] }, mouseSettings: { type: "3fv", value: [.008, .015, 1], gui: [{ min: 0, max: .3, step: 1e-4, name: "minDistance" }, { min: 0, max: .3, step: 1e-4, name: "maxDistance" }, { min: 0, max: 1, step: .01, name: "strength" }] }, pullAttract: { type: "3fv", value: [.008, .04, .1], gui: [{ min: -1, max: 1, step: 1e-4, name: "minDistance" }, { min: -1, max: 1, step: 1e-4, name: "maxDistance" }, { min: 0, max: 1, step: .01, name: "strength" }] }, mouseSettingsShift: { type: "3fv", value: [.001, .038, .2], gui: [{ min: 0, max: .3, step: 1e-4, name: "minDistance" }, { min: 0, max: .3, step: 1e-4, name: "maxDistance" }, { min: 0, max: 1, step: .01, name: "strength" }] }, rimLightColor: { type: "3fv", value: [.999, .795, .501], color: !0 }, rimLightStrength: { type: "f", value: .1, min: 0, max: 1, step: 1e-4 }, maxDragDistance: { type: "f", value: .009, min: 0, max: .09, step: 1e-6 }, attack: { type: "f", value: .1, min: 0, max: 2, step: 1e-5 }, decay: { type: "f", value: .95, min: 0, max: 2, step: 1e-5 }, velOvershoot: { type: "f", value: 1.7, min: 0, max: 2, step: 1e-5 }, texelStep: { type: "2fv", value: [1 / 49, 1 / 49], hideInGui: !0 }, debug: { type: "f", value: 1, min: 0, max: 1, step: 1e-5 } }, window.addEventListener("resize", this.onResize), this.onResize();
                            var n = new v.default,
                                r = new o.TextureLoader;
                            n.load("/iframes/nipple/static/nip.glb", function(t) {
                                var n = t.scene.children[0].children[0];
                                n.geometry.computeBoundingBox(), e.uniforms.meshBounds.value[0] = 2 * n.geometry.boundingBox.max.x, e.uniforms.meshBounds.value[1] = 2 * n.geometry.boundingBox.max.y, delete n.geometry.attributes.uv, n.geometry.attributes.uv = n.geometry.attributes.uv2, delete n.geometry.attributes.uv2, E = Math.floor(Math.sqrt(n.geometry.attributes.position.count)), e.uniforms.positionUVOffsets.value[0] = 1 / E, e.uniforms.positionUVOffsets.value[1] = 1 / E, e.uniforms.positionUVOffsets.value[2] = 0, e.offsetPingPongRunner = new c.default, e.offsetPingPongRunner.setup(e.renderer, e.camera, 50, 50, l.default, h.default, e.uniforms, n.geometry), e.worldPositionCompute = new g.default, e.uniforms.positionsMap.value = e.worldPositionCompute.setup(e.renderer, e.camera, E, E, p.default, d.default, e.uniforms, o.NearestFilter, o.HalfFloatType, n.geometry), e.normalsCompute = new g.default, e.uniforms.normalsMap.value = e.normalsCompute.setup(e.renderer, e.camera, E, E, f.default, m.default, e.uniforms, o.NearestFilter, o.HalfFloatType), e.nipMesh = new o.Mesh(n.geometry, new o.RawShaderMaterial({ vertexShader: s.default, fragmentShader: u.default, uniforms: e.uniforms, side: o.FrontSide, transparent: !0 })), e.nipMesh.frustumCulled = !1, e.scene.add(e.nipMesh);
                                var r = new o.PlaneBufferGeometry(1, 1, 1, 1),
                                    i = new o.MeshBasicMaterial({ color: 16711680 });
                                e.staticIntersectMesh = new o.Mesh(r, i), e.staticIntersectMesh.rotation.y = Math.PI, e.staticIntersectMesh.position.z = -.015, e.staticIntersectMesh.frustumCulled = !1, e.staticIntersectMesh.visible = !1, e.scene.add(e.staticIntersectMesh), e.intersectMesh = new o.Mesh(r, i), e.intersectMesh.frustumCulled = !1, e.intersectMesh.visible = !1, e.scene.add(e.intersectMesh), e.startCollider = new o.Mesh(t.scene.children[0].children[1].geometry, i), e.startCollider.frustumCulled = !1, e.startCollider.position.x = t.scene.children[0].children[1].position.x, e.startCollider.position.y = t.scene.children[0].children[1].position.y, e.startCollider.position.z = t.scene.children[0].children[1].position.z, e.startCollider.visible = !1, e.scene.add(e.startCollider), e.renderLoop()
                            }), r.load("/iframes/nipple/static/map.jpg", function(t) { e.uniforms.map.value = t }), r.load("/iframes/nipple/static/stretch.png", function(t) { t.wrapS = o.RepeatWrapping, t.wrapT = o.RepeatWrapping, e.uniforms.stretchMap.value = t }), r.load("/iframes/nipple/static/wrinkles.jpg", function(t) { t.wrapS = o.RepeatWrapping, t.wrapT = o.RepeatWrapping, e.uniforms.wrinklesMap.value = t }), r.load("/iframes/nipple/static/normal.jpg", function(t) { t.wrapS = o.RepeatWrapping, t.wrapT = o.RepeatWrapping, e.uniforms.normalMap.value = t }), this.props.setUniforms(this.uniforms), this.containerRef.addEventListener("touchmove", this.onPointerMove, { passive: !1 })
                        }
                    }, { key: "shouldComponentUpdate", value: function(e, t) { return !1 } }, { key: "componentWillUnmount", value: function() { void 0 !== this.geometry && (this.geometry.dispose(), this.material.dispose()), window.removeEventListener("resize", this.onResize), cancelAnimationFrame(this.frameRequest), this.containerRef.removeEventListener("touchmove", this.onPointerMove) } }, {
                        key: "cacheMousePositionFromEvent",
                        value: function(e) {
                            var t = this.containerRef.getBoundingClientRect();
                            void 0 !== e.changedTouches && e.changedTouches.length > 0 ? (this.normalizedMousePosition.x = (e.changedTouches[0].clientX - t.left) / t.width, this.normalizedMousePosition.y = (e.changedTouches[0].clientY - t.top) / t.height) : (this.normalizedMousePosition.x = (e.clientX - t.left) / t.width, this.normalizedMousePosition.y = (e.clientY - t.top) / t.height), this.glMouse.x = 2 * (this.normalizedMousePosition.x - .5), this.glMouse.y = -2 * (this.normalizedMousePosition.y - .5), this.uniforms.mousePosition.value[2] = this.glMouse.x - this.uniforms.mousePosition.value[0], this.uniforms.mousePosition.value[3] = this.glMouse.y - this.uniforms.mousePosition.value[1], this.uniforms.mousePosition.value[0] = this.glMouse.x, this.uniforms.mousePosition.value[1] = this.glMouse.y
                        }
                    }, { key: "render", value: function() { var e = this; return i.default.createElement("div", { ref: function(t) { e.containerRef = t }, className: "jsx-3804711334" }, i.default.createElement("canvas", { ref: function(t) { e.canvasRef = t }, onMouseDown: function(t) { return e.onPointerStart(t) }, onMouseMove: function(t) { return e.onPointerMove(t) }, onMouseLeave: function(t) { return e.onPointerExit(t) }, onMouseUp: function(t) { return e.onPointerExit(t) }, onTouchStart: function(t) { return e.onPointerStart(t) }, onTouchEnd: function(t) { return e.onPointerExit(t) }, onTouchCancel: function(t) { return e.onPointerExit(t) }, style: { marginLeft: "50vw", transform: "translateX(-50%)" }, className: "jsx-3804711334" }), i.default.createElement(r.default, { styleId: "3804711334", css: ["div.jsx-3804711334{width:100%;height:100%;-webkit-transform:translateX(calc(50vw - 50%)) translateY(calc(50vh - 50%));-ms-transform:translateX(calc(50vw - 50%)) translateY(calc(50vh - 50%));transform:translateX(calc(50vw - 50%)) translateY(calc(50vh - 50%));}"] })) } }]) && w(n.prototype, x), T && w(n, T), t
                }();
            t.default = T
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(e) {
                var t = { lowPerformance: !1 },
                    n = e,
                    i = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT);
                t.supportsHighp = 0 !== i.precision;
                var o = n.getExtension("ANGLE_instanced_arrays");
                t.supportsInstancedArrays = null !== o, t.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), t.supportsHalfFloatLinear = null !== n.getExtension("OES_texture_half_float_linear"), t.supportsFloatTexture = null !== n.getExtension("OES_texture_float"), t.supportsFloatLinearTexture = null !== n.getExtension("OES_texture_float_linear"), t.supportsFloatTextureRendering = null !== n.getExtension("WEBGL_color_buffer_float"), (!t.supportsHighp || !t.supportsInstancedArrays || t.maxTextureSize < 4e3 || !t.supportsHalfFloatLinear) && (t.lowPerformance = !0);
                var a = n.getExtension("WEBGL_debug_renderer_info");
                if (null !== a) {
                    var s = n.getParameter(a.UNMASKED_VENDOR_WEBGL),
                        u = n.getParameter(a.UNMASKED_RENDERER_WEBGL);
                    "Google Inc." === s && ("Google SwiftShader" === u || r(u, "Software Adapter")) && (t.lowPerformance = !0)
                }
                return t.precisionString = t.supportsHighp ? "precision highp float;\n" : "precision mediump float; \n", t
            };
            var r = n(126)
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\n#define PI 3.14159265359\n\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\n\nuniform mat3 normalMatrix;\n\nuniform float maxDragDistance;\n\nuniform vec2 meshBounds;\n\nuniform float debug;\n\nuniform sampler2D positionsMap;\nuniform sampler2D normalsMap;\n\nuniform vec3 worldPositionStart;\nuniform vec3 intersectTangent;\nuniform vec3 intersectBiTangent;\n// uniform vec4 mouseSettings;\n\nuniform vec4 stretch;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nvarying vec2 vUV;\nvarying float centerDistance;\nvarying vec2 vUVMap;\nvarying vec3 vWorldNormal;\n\nvarying vec2 vWrinklesUV;\nvarying vec2 vStretchUV;\n\nvarying float vDistortionAmount;\n\nvarying vec3 vViewPosition;\nvarying float vRimValue;\nvarying float vStretchAMount;\n\n// uniform vec4 mousePosition;\n// uniform vec4 mouseSettings;\n\nfloat smin( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 );\n  return min( a, b ) - h*h*0.25/k;\n}\n\nfloat when_lt(float x, float y) {\n  return max(sign(y - x), 0.0);\n}\n\nfloat when_gt(float x, float y) {\n  return max(sign(x - y), 0.0);\n}\n\nfloat when_ge(float x, float y) {\n  return 1.0 - when_lt(x, y);\n}\n\nvoid main() {\n  vUV = uv;\n  vec4 positionMapData = texture2D(positionsMap, uv);\n  vec4 normalMapData = texture2D(normalsMap, vUV);\n\n  vec4 transform = vec4(positionMapData.xyz, 1.0);\n\n  vDistortionAmount = normalMapData.w;\n  // vDistortionAmount = positionMapData.w;\n\n  vec3 worldPosBase = (modelMatrix * vec4(position, 1.0)).xyz;\n  vec3 fromPullStartToPos = worldPositionStart - worldPosBase;\n  float distToPullCenter = length(fromPullStartToPos);\n  fromPullStartToPos = normalize(fromPullStartToPos);\n\n  float sideToSideDot = dot(intersectBiTangent, fromPullStartToPos.xyz);\n  float upDot = dot(intersectTangent, fromPullStartToPos.xyz);\n  // vWrinklesUV.x = dot(intersectTangent, fromPullStartToPos.xyz);\n  // vWrinklesUV.x = 0.5 + vWrinklesUV.x * 0.5;\n  // vWrinklesUV.x = vWrinklesUV.x + when_ge(sideToSideDot, 0.0);\n  vWrinklesUV.x = atan(upDot, sideToSideDot);\n  vWrinklesUV.x *= stretch.w;\n\n  // vWrinklesUV.y = positionMapData.w; // .w has relative distortion amount\n  vWrinklesUV.y = distToPullCenter / maxDragDistance; // .w has relative distortion amount\n\n  vStretchUV.x = vWrinklesUV.x / PI;\n  vStretchUV.x *= 0.5;\n  // vStretchUV.y = positionMapData.w * 0.5;\n  vStretchUV.y = distToPullCenter / maxDragDistance;\n  vStretchUV.y *= 2.0;\n\n\n  vUVMap = position.xy;\n  vUVMap /= meshBounds;\n  vUVMap += 0.5;\n\n  // vUV.x = distance(transform.xyz, worldPositionStart);\n  // vUV.x = smoothstep(mouseSettings.y, mouseSettings.x, vUV.x);\n\n  vWorldNormal = normal;\n  vWorldNormal = mix(\n    vWorldNormal,\n    normalMapData.xyz,\n    debug\n  );\n\n  vec4 mvPosition = modelViewMatrix * transform;\n  gl_Position = projectionMatrix * mvPosition;\n\n  vViewPosition = -mvPosition.xyz;\n\n  vec2 screenPosForCenterDistance = position.xy;\n  screenPosForCenterDistance /= meshBounds * 0.5;\n  centerDistance = length(screenPosForCenterDistance);\n\n  vRimValue = dot(vWorldNormal, mvPosition.xyz);\n  vStretchAMount = smoothstep(\n    0.8,\n    1.0,\n    (length(positionMapData.xyz - worldPosBase) / maxDragDistance)\n  );\n}\n"
        }, function(e, t, n) {
            "use strict";
            e.exports = "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\nuniform sampler2D map;\nuniform sampler2D wrinklesMap;\nuniform sampler2D normalMap;\nuniform sampler2D stretchMap;\n// uniform sampler2D offsetsMap;\n\nuniform vec3 lightDir;\n\nuniform vec2 fadeEdge;\n// uniform vec2 pullArea;\n\nuniform vec4 stretch;\nuniform vec2 stretchStrength;\nuniform float mousePositionDeltaRelLength;\n\nuniform vec3 rimLightColor;\nuniform float rimLightStrength;\n\nvarying vec3 vViewPosition;\n\nvarying vec3 vWorldNormal;\n\nvarying vec2 vUV;\nvarying vec2 vUVMap;\nvarying float centerDistance;\nvarying vec2 vWrinklesUV;\nvarying vec2 vStretchUV;\n\nvarying float vDistortionAmount;\nvarying float vStretchAMount;\n\nvarying float vRimValue;\n\n// https://github.com/glslify/glsl-perturb-normal\n\n// http://www.thetenthplanet.de/archives/1180\nmat3 cotangent(vec3 N, vec3 p, vec2 uv) {\n  // get edge vectors of the pixel triangle\n  vec3 dp1 = dFdx(p);\n  vec3 dp2 = dFdy(p);\n  vec2 duv1 = dFdx(uv);\n  vec2 duv2 = dFdy(uv);\n\n  // solve the linear system\n  vec3 dp2perp = cross(dp2, N);\n  vec3 dp1perp = cross(N, dp1);\n  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n  // construct a scale-invariant frame\n  float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n  return mat3(normalize(T * invmax), normalize(B * invmax), N);\n}\n\nvec3 perturb(vec3 map, vec3 N, vec3 V, vec2 texcoord) {\n  mat3 TBN = cotangent(N, -V, texcoord);\n  return normalize(TBN * map);\n}\n\nvoid main() {\n  vec4 color = texture2D(map, vUVMap);\n\n  color.a = smoothstep(\n    fadeEdge.x + fadeEdge.y,\n    fadeEdge.x,\n    centerDistance\n  );\n  // color.r = centerDistance;\n  // color.r = smoothstep(\n  //   pullArea.y,\n  //   pullArea.x,\n  //   centerDistance\n  // );\n\n  float stretchAmount = smoothstep(\n    stretch.x,\n    stretch.y,\n    vDistortionAmount\n  );\n  stretchAmount *= stretchStrength.x;\n  stretchAmount *= smoothstep(0.1, 0.9, mousePositionDeltaRelLength);\n  stretchAmount = min(stretchAmount, stretchStrength.y);\n\n  // color.rgb = vWrinklesUV.xxx;\n  // color.g = 0.0;\n  // color.b = 0.0;\n\n  vec3 stretchColor = texture2D(wrinklesMap, vWrinklesUV).rgb;\n\n  color.rgb = mix(\n    color.rgb,\n    stretchColor,\n    stretchAmount\n  );\n\n  color.rgb *= mix(\n    1.0,\n    0.6 + (texture2D(stretchMap, vStretchUV).r - 0.5) * 1.2,\n    stretchAmount * 1.5\n  );\n\n\n  vec2 normalUV = vUVMap * 4.0;\n\n  normalUV = mix(\n    normalUV,\n    vStretchUV,\n    stretchAmount\n  );\n\n  vec3 normalMapData = texture2D(normalMap, normalUV).xyz;\n  normalMapData *= 2.0;\n  normalMapData -= 1.0;\n\n  vec3 normal = perturb(\n    normalMapData,\n    normalize(vWorldNormal),\n    vViewPosition,\n    normalUV\n  );\n\n  vec3 normNormal = normalize(normal);\n\n  float light = dot(\n    lightDir,\n    normNormal\n  );\n\n  float hDiffuse = light * 0.5 + 0.5;\n  hDiffuse *= hDiffuse;\n\n  hDiffuse = pow(max(hDiffuse - 0.1, 0.0), 2.0) * 0.25;\n\n  color.rgb += hDiffuse;\n\n  float rimLight = smoothstep(\n      0.2,\n      0.05,\n      vRimValue\n    ) * vStretchAMount;\n\n  color.rgb = mix(\n    color.rgb,\n    rimLightColor,\n    rimLight * rimLightStrength\n  );\n\n\n  gl_FragColor = vec4(color);\n  // gl_FragColor = vec4(texture2D(offsetsMap, vUV).aaa, 1.0);\n\n  // gl_FragColor = vec4(vec3(stretchAmount), 1.0);\n\n\n\n  // gl_FragColor = vec4(vUVMap, 0.0, 1.0);\n  // gl_FragColor = vec4(vUV.r, 0.0, 0.0, 1.0);\n}\n"
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r = n(52),
                i = s(n(127)),
                o = s(n(276)),
                a = s(n(277));

            function s(e) { return e && e.__esModule ? e : { default: e } }

            function u(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var c = function() {
                function e() {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e) }
                var t, n, s;
                return t = e, (n = [{
                    key: "setup",
                    value: function(e, t, n, s, u, c, l, h) {
                        this.renderer = e, this.camera = t, this.uniforms = Object.assign({ pingPongSourceMap: { type: "t", value: null }, pingPongOldSourceMap: { type: "t", value: null }, pingPongVelocityMap: { type: "t", value: null } }, l), this.currentTarget = 1, this.velocityRunner = new i.default, this.uniforms.pingPongVelocityMap.value = this.velocityRunner.setup(e, t, n, s, o.default, a.default, this.uniforms, r.NearestFilter, r.HalfFloatType), this.renderTargets = [];
                        for (var p = 0; p < 2; p++) this.renderTargets.push(new r.WebGLRenderTarget(n, s, { minFilter: r.LinearFilter, magFilter: r.LinearFilter, generateMipmaps: !1, stencilBuffer: !1, depthBuffer: !1, type: r.HalfFloatType }));
                        this.scene = new r.Scene;
                        var d = new r.Mesh(h || new r.PlaneBufferGeometry(2, 2, 1, 1), new r.RawShaderMaterial({ uniforms: this.uniforms, vertexShader: u, fragmentShader: c, side: r.DoubleSide, depthTest: !1, depthWrite: !1 }));
                        d.frustumCulled = !1, this.scene.add(d)
                    }
                }, { key: "setSize", value: function(e, t) { this.renderTargets[0].setSize(e, t), this.renderTargets[1].setSize(e, t) } }, { key: "render", value: function(e) { return this.uniforms.pingPongSourceMap.value = this.renderTargets[this.currentTarget].texture, this.uniforms.pingPongOldSourceMap = this.renderTargets[1 - this.currentTarget].texture, this.velocityRunner.render(), this.currentTarget = 1 - this.currentTarget, this.renderer.render(this.scene, this.camera, this.renderTargets[this.currentTarget], !1), e.value = this.renderTargets[1 - this.currentTarget].texture, this.renderTargets[this.currentTarget].texture } }]) && u(t.prototype, n), s && u(t, s), e
            }();
            t.default = c
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUV;\n\nvoid main()\t{\n  vUV = uv;\n\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}"
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nuniform sampler2D pingPongSourceMap;\nuniform sampler2D pingPongOldSourceMap;\n\nvarying vec2 vUV;\n\nvoid main() {\n  vec3 velocity =\n    texture2D(pingPongOldSourceMap, vUV).xyz -\n    texture2D(pingPongSourceMap, vUV).xyz;\n\n  gl_FragColor = vec4(velocity, 1.0);\n}"
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\n\nuniform float aspectRatio;\n\nuniform vec2 mousePositionStart;\nuniform vec3 worldPositionStart;\nuniform vec3 mouseSettings;\nuniform vec3 mouseSettingsShift;\nuniform vec3 mousePositionDelta;\nuniform float mousePressed;\nuniform vec3 pullAttract;\n\nuniform vec2 meshBounds;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUV;\nvarying float vMouseStrength;\nvarying float vAttractStrength;\nvarying vec3 vPinchShift;\nvarying float centerDistance;\n\nvarying vec3 vToDragTarget;\n\n\nvoid main() {\n  vUV = uv;\n\n  // get worldspace position\n  vec4 transform = vec4(position, 1.0);\n  vec3 worldPos = (modelMatrix * transform).xyz;\n\n  vMouseStrength = distance(transform.xyz, worldPositionStart);\n  vMouseStrength = smoothstep(mouseSettings.y, mouseSettings.x, vMouseStrength);\n  vMouseStrength *= mouseSettings.z;\n  // vMouseStrength *= 0.0;\n\n  vAttractStrength = distance(transform.xyz, worldPositionStart);\n  vAttractStrength = smoothstep(pullAttract.y, pullAttract.x, vAttractStrength);\n  vAttractStrength *= pullAttract.z;\n\n  vec3 shiftTo = worldPositionStart;\n  shiftTo -= mousePositionDelta * 0.1;\n  shiftTo += mousePositionDelta * 0.3;\n\n  vec3 toPinchCenter = shiftTo - position;\n  float pinchValue = length(toPinchCenter);\n  pinchValue = smoothstep(mouseSettingsShift.y, mouseSettingsShift.x, pinchValue);\n  pinchValue *= mouseSettingsShift.z;\n  pinchValue *= max(length(mousePositionDelta) - 0.006, 0.0) * 80.0;\n  vPinchShift = toPinchCenter * pinchValue;\n\n  vec3 dragTarget = worldPositionStart + mousePositionDelta;\n  vToDragTarget = dragTarget - position;\n\n  // setup to render into texturespace\n  gl_Position.x = 2.0 * uv.x - 1.0;\n  gl_Position.y = 2.0 * uv.y - 1.0;\n  gl_Position.z = 0.0;\n  gl_Position.w = 1.0;\n\n  vec2 screenPosForCenterDistance = position.xy;\n  screenPosForCenterDistance /= meshBounds * 0.5;\n  centerDistance = length(screenPosForCenterDistance);\n}"
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nuniform sampler2D pingPongSourceMap;\nuniform sampler2D pingPongVelocityMap;\n\nuniform vec3 mousePositionDelta;\nuniform float mousePressed;\n\nuniform vec2 texelStep;\n\nuniform float attack;\nuniform float decay;\nuniform float velOvershoot;\n// uniform float energyReduce;\n\nuniform vec2 pullArea;\nuniform vec2 shiftArea;\n\n// uniform float cornerStrength;\n// uniform float totalAveraging;\n\nvarying vec2 vUV;\nvarying float vMouseStrength;\nvarying vec3 vPinchShift;\nvarying float centerDistance;\n\nvarying vec3 vToDragTarget;\nvarying float vAttractStrength;\n\nvoid main() {\n\n  vec2 uv = vUV;\n\n  vec4 col = texture2D(pingPongSourceMap, uv);\n  vec3 oldVel = texture2D(pingPongVelocityMap, uv).xyz * velOvershoot;\n  // vec3 oldVel = vec3(0.0);\n\n  vec3 offset = col.xyz;\n\n  // sample and average surrounding heights\n  vec3 l;\n  vec3 r;\n  vec3 t;\n  vec3 b;\n\n  {\n    vec2 uvXOffset = vec2(texelStep.x, 0.0);\n    vec2 uvYOffset = vec2(0.0, texelStep.y);\n\n    l = texture2D(pingPongSourceMap, uv - uvXOffset).xyz;\n    r = texture2D(pingPongSourceMap, uv + uvXOffset).xyz;\n    t = texture2D(pingPongSourceMap, uv + uvYOffset).xyz;\n    b = texture2D(pingPongSourceMap, uv - uvYOffset).xyz;\n\n    vec3 outerAverage = l + r + t + b;\n\n    // outerAverage += texture2D(pingPongSourceMap, uv + uvYOffset + uvYOffset).xyz; // TT\n    // outerAverage += texture2D(pingPongSourceMap, uv - uvXOffset - uvXOffset).xyz; // LL\n    // outerAverage += texture2D(pingPongSourceMap, uv + uvXOffset + uvXOffset).xyz; // RR\n    // outerAverage += texture2D(pingPongSourceMap, uv - uvYOffset - uvYOffset).xyz; // BB\n\n    outerAverage += (texture2D(pingPongSourceMap, uv + uvYOffset - uvXOffset).xyz); // TL\n    outerAverage += (texture2D(pingPongSourceMap, uv + uvYOffset + uvXOffset).xyz); // TR\n    outerAverage += (texture2D(pingPongSourceMap, uv - uvYOffset - uvXOffset).xyz); // BL\n    outerAverage += (texture2D(pingPongSourceMap, uv - uvYOffset + uvXOffset).xyz); // BR\n\n    outerAverage /= 8.0;\n    // outerAverage /= 12.0;\n\n    // outerAverage *= energyReduce;\n\n    outerAverage = mix(\n      col.xyz,\n      outerAverage,\n      0.01\n    );\n\n    offset += (oldVel + (attack * (outerAverage - col.xyz))) * decay;\n  }\n\n  float inverseIsUnderCursor = smoothstep(0.9, 0.8, vMouseStrength);\n\n  // pinch out\n  offset = mix(\n    offset,\n    mousePositionDelta,\n    vMouseStrength * mousePressed\n  );\n  offset += vToDragTarget * (vAttractStrength * mousePressed) * inverseIsUnderCursor;\n\n  // reduce offset amount towards edges\n  offset *= smoothstep(\n    pullArea.y,\n    pullArea.x,\n    centerDistance\n  );\n\n  // shift towards pinch center\n  offset += vPinchShift * inverseIsUnderCursor * smoothstep(\n    shiftArea.y,\n    shiftArea.x,\n    centerDistance\n  );\n\n  gl_FragColor = vec4(offset, inverseIsUnderCursor);\n}"
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec3 vWorldPosition;\nvarying vec2 vUV;\n\n\nvoid main()\t{\n  vUV = uv;\n\n  // get worldspace position\n  vWorldPosition = position;\n\n  // setup to render into texturespace\n  gl_Position.x = 2.0 * uv.x - 1.0;\n  gl_Position.y = 2.0 * uv.y - 1.0;\n  gl_Position.z = 0.0;\n  gl_Position.w = 1.0;\n}"
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nuniform sampler2D prevOffsetsMap;\nuniform sampler2D offsetsMap;\nuniform float relOffsetProgress;\n\nuniform float mousePositionDeltaLength;\nuniform float maxDragDistance;\n\nuniform vec4 stretch;\n\n\nvarying vec3 vWorldPosition;\nvarying vec2 vUV;\n\nfloat smin( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 );\n  return min( a, b ) - h*h*0.25/k;\n}\n\nvoid main() {\n  vec3 offset = mix(\n    texture2D(prevOffsetsMap, vUV).xyz,\n    texture2D(offsetsMap, vUV).xyz,\n    relOffsetProgress\n  );\n\n  float offsetLength = length(offset);\n  offset.z += 0.0001; // iOS doesn't like normalizing a vector with 0 length\n  offset = normalize(offset) * smin(offsetLength, 0.04, 0.03);\n\n  offset += vWorldPosition;\n\n  float distortionAmount = offsetLength / maxDragDistance;\n\n  // dont show stretch on top\n  distortionAmount *= smoothstep(\n    mousePositionDeltaLength * 0.99,\n    mousePositionDeltaLength * stretch.z,\n    offsetLength\n  );\n\n  gl_FragColor = vec4(offset, distortionAmount);\n}\n"
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUV;\n\nvoid main()\t{\n  vUV = uv;\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}"
        }, function(e, t, n) {
            "use strict";
            e.exports = "precision highp float;\n\nuniform sampler2D positionsMap;\n\nuniform vec3 positionUVOffsets;\n\nvarying vec3 vWorldPosition;\nvarying vec2 vUV;\n\nvoid main() {\n  vec4 bakedPosition = texture2D(positionsMap, vUV);\n\n  vec3 calcNormal;\n\n  float stretchAmount;\n\n  // calculate normal\n  {\n    vec4 upData = texture2D(positionsMap, vUV + positionUVOffsets.zy);\n    vec4 leftData = texture2D(positionsMap, vUV - positionUVOffsets.xz);\n    vec4 downData = texture2D(positionsMap, vUV - positionUVOffsets.zy);\n    vec4 rightData = texture2D(positionsMap, vUV + positionUVOffsets.xz);\n\n    vec3 up = upData.xyz - bakedPosition.xyz;\n    vec3 left = leftData.xyz - bakedPosition.xyz;\n    vec3 down = downData.xyz - bakedPosition.xyz;\n    vec3 right = rightData.xyz - bakedPosition.xyz;\n\n    calcNormal = 0.441 * normalize(cross(up, left)) + normalize(cross(down, right));\n\n    vec3 ul = texture2D(positionsMap, vUV + positionUVOffsets.zy - positionUVOffsets.xz).xyz - bakedPosition.xyz;\n    vec3 ur = texture2D(positionsMap, vUV + positionUVOffsets.xy).xyz - bakedPosition.xyz;\n    vec3 dl = texture2D(positionsMap, vUV - positionUVOffsets.xy).xyz - bakedPosition.xyz;\n    vec3 dr = texture2D(positionsMap, vUV - positionUVOffsets.zy + positionUVOffsets.xz).xyz - bakedPosition.xyz;\n\n    calcNormal += 0.279 * (normalize(cross(ul, ur)) + normalize(cross(dr, dl)));\n\n    calcNormal = normalize(calcNormal);\n\n\n    stretchAmount =\n      abs(bakedPosition.w - upData.w) +\n      abs(bakedPosition.w - leftData.w) +\n      abs(bakedPosition.w - downData.w) +\n      abs(bakedPosition.w - rightData.w);\n  }\n\n  calcNormal *= -1.0;\n\n  gl_FragColor = vec4(\n    calcNormal,\n    stretchAmount\n  );\n}\n"
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r = function(e) {
                if (e && e.__esModule) return e;
                var t = {};
                if (null != e)
                    for (var n in e)
                        if (Object.prototype.hasOwnProperty.call(e, n)) {
                            var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {};
                            r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n]
                        }
                return t.default = e, t
            }(n(52));
            r.GLTFLoader = function() {
                function e(e) { this.manager = void 0 !== e ? e : r.DefaultLoadingManager }
                e.prototype = {
                    constructor: e,
                    crossOrigin: "Anonymous",
                    load: function(e, t, n, i) {
                        var o = this,
                            a = void 0 !== this.path ? this.path : r.Loader.prototype.extractUrlBase(e),
                            s = new r.FileLoader(o.manager);
                        s.setResponseType("arraybuffer"), s.load(e, function(e) { try { o.parse(e, a, t, i) } catch (e) { void 0 !== i && i(e.constructor === Error ? e : new Error("THREE.GLTFLoader: Unable to parse model.")) } }, n, i)
                    },
                    setCrossOrigin: function(e) { this.crossOrigin = e },
                    setPath: function(e) { this.path = e },
                    parse: function(e, s, u, c) {
                        var l, h = {};
                        "string" == typeof e ? l = e : T(new Uint8Array(e, 0, 4)) === i ? (h[t.KHR_BINARY_GLTF] = new function(e) {
                            this.name = t.KHR_BINARY_GLTF, this.content = null, this.body = null;
                            var n = new DataView(e, 0, o);
                            if (this.header = { magic: T(new Uint8Array(e.slice(0, 4))), version: n.getUint32(4, !0), length: n.getUint32(8, !0) }, this.header.magic !== i) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected. Use GLTFLoader instead.");
                            var r = new DataView(e, o),
                                s = 0;
                            for (; s < r.byteLength;) {
                                var u = r.getUint32(s, !0);
                                s += 4;
                                var c = r.getUint32(s, !0);
                                if (s += 4, c === a.JSON) {
                                    var l = new Uint8Array(e, o + s, u);
                                    this.content = T(l)
                                } else if (c === a.BIN) {
                                    var h = o + s;
                                    this.body = e.slice(h, h + u)
                                }
                                s += u
                            }
                            if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                        }(e), l = h[t.KHR_BINARY_GLTF].content) : l = T(new Uint8Array(e));
                        var p = JSON.parse(l);
                        void 0 === p.asset || p.asset.version[0] < 2 ? c(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")) : (p.extensionsUsed && (p.extensionsUsed.indexOf(t.KHR_LIGHTS) >= 0 && (h[t.KHR_LIGHTS] = new function(e) {
                            this.name = t.KHR_LIGHTS, this.lights = {};
                            var n = (e.extensions && e.extensions[t.KHR_LIGHTS] || {}).lights || {};
                            for (var i in n) {
                                var o, a = n[i],
                                    s = (new r.Color).fromArray(a.color);
                                switch (a.type) {
                                    case "directional":
                                        (o = new r.DirectionalLight(s)).position.set(0, 0, 1);
                                        break;
                                    case "point":
                                        o = new r.PointLight(s);
                                        break;
                                    case "spot":
                                        (o = new r.SpotLight(s)).position.set(0, 0, 1);
                                        break;
                                    case "ambient":
                                        o = new r.AmbientLight(s)
                                }
                                o && (void 0 !== a.constantAttenuation && (o.intensity = a.constantAttenuation), void 0 !== a.linearAttenuation && (o.distance = 1 / a.linearAttenuation), void 0 !== a.quadraticAttenuation && (o.decay = a.quadraticAttenuation), void 0 !== a.fallOffAngle && (o.angle = a.fallOffAngle), void 0 !== a.fallOffExponent && console.warn("THREE.GLTFLoader:: light.fallOffExponent not currently supported."), o.name = a.name || "light_" + i, this.lights[i] = o)
                            }
                        }(p)), p.extensionsUsed.indexOf(t.KHR_MATERIALS_COMMON) >= 0 && (h[t.KHR_MATERIALS_COMMON] = new n(p)), p.extensionsUsed.indexOf(t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS) >= 0 && (h[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = new function() {
                            return {
                                name: t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                                specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                                getMaterialType: function() { return r.ShaderMaterial },
                                extendParams: function(e, t, n) {
                                    var i = t.extensions[this.name],
                                        o = r.ShaderLib.standard,
                                        a = r.UniformsUtils.clone(o.uniforms),
                                        s = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                                        u = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                                        c = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                                        l = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                                        h = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"),
                                        p = o.fragmentShader.replace("#include <specularmap_fragment>", "").replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", s).replace("#include <metalnessmap_pars_fragment>", u).replace("#include <roughnessmap_fragment>", c).replace("#include <metalnessmap_fragment>", l).replace("#include <lights_physical_fragment>", h);
                                    delete a.roughness, delete a.metalness, delete a.roughnessMap, delete a.metalnessMap, a.specular = { value: (new r.Color).setHex(1118481) }, a.glossiness = { value: .5 }, a.specularMap = { value: null }, a.glossinessMap = { value: null }, e.vertexShader = o.vertexShader, e.fragmentShader = p, e.uniforms = a, e.defines = { STANDARD: "" }, e.color = new r.Color(1, 1, 1), e.opacity = 1;
                                    var d = [];
                                    if (Array.isArray(i.diffuseFactor)) {
                                        var f = i.diffuseFactor;
                                        e.color.fromArray(f), e.opacity = f[3]
                                    }
                                    if (void 0 !== i.diffuseTexture && d.push(n.assignTexture(e, "map", i.diffuseTexture.index)), e.emissive = new r.Color(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new r.Color(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                                        var m = i.specularGlossinessTexture.index;
                                        d.push(n.assignTexture(e, "glossinessMap", m)), d.push(n.assignTexture(e, "specularMap", m))
                                    }
                                    return Promise.all(d)
                                },
                                createMaterial: function(e) { var t = new r.ShaderMaterial({ defines: e.defines, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, uniforms: e.uniforms, fog: !0, lights: !0, opacity: e.opacity, transparent: e.transparent }); return t.isGLTFSpecularGlossinessMaterial = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t.extensions.derivatives = !0, t },
                                cloneMaterial: function(e) {
                                    var t = e.clone();
                                    t.isGLTFSpecularGlossinessMaterial = !0;
                                    for (var n = this.specularGlossinessParams, r = 0; r < n.length; r++) t[n[r]] = e[n[r]];
                                    return t
                                },
                                refreshUniforms: function(e, t, n, r, i, o) {
                                    var a, s, u, c = i.uniforms,
                                        l = i.defines;
                                    if (c.opacity.value = i.opacity, c.diffuse.value.copy(i.color), c.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), c.map.value = i.map, c.specularMap.value = i.specularMap, c.alphaMap.value = i.alphaMap, c.lightMap.value = i.lightMap, c.lightMapIntensity.value = i.lightMapIntensity, c.aoMap.value = i.aoMap, c.aoMapIntensity.value = i.aoMapIntensity, i.map ? a = i.map : i.specularMap ? a = i.specularMap : i.displacementMap ? a = i.displacementMap : i.normalMap ? a = i.normalMap : i.bumpMap ? a = i.bumpMap : i.glossinessMap ? a = i.glossinessMap : i.alphaMap ? a = i.alphaMap : i.emissiveMap && (a = i.emissiveMap), void 0 !== a)
                                        if (a.isWebGLRenderTarget && (a = a.texture), void 0 !== a.matrix) {
                                            if (!0 === a.matrixAutoUpdate) {
                                                s = a.offset, u = a.repeat;
                                                var h = a.rotation,
                                                    p = a.center;
                                                a.matrix.setUvTransform(s.x, s.y, u.x, u.y, h, p.x, p.y)
                                            }
                                            c.uvTransform.value.copy(a.matrix)
                                        } else s = a.offset, u = a.repeat, c.offsetRepeat.value.set(s.x, s.y, u.x, u.y);
                                    c.envMap.value = i.envMap, c.envMapIntensity.value = i.envMapIntensity, c.flipEnvMap.value = i.envMap && i.envMap.isCubeTexture ? -1 : 1, c.refractionRatio.value = i.refractionRatio, c.specular.value.copy(i.specular), c.glossiness.value = i.glossiness, c.glossinessMap.value = i.glossinessMap, c.emissiveMap.value = i.emissiveMap, c.bumpMap.value = i.bumpMap, c.normalMap.value = i.normalMap, c.displacementMap.value = i.displacementMap, c.displacementScale.value = i.displacementScale, c.displacementBias.value = i.displacementBias, null !== c.glossinessMap.value && void 0 === l.USE_GLOSSINESSMAP && (l.USE_GLOSSINESSMAP = "", l.USE_ROUGHNESSMAP = ""), null === c.glossinessMap.value && void 0 !== l.USE_GLOSSINESSMAP && (delete l.USE_GLOSSINESSMAP, delete l.USE_ROUGHNESSMAP)
                                }
                            }
                        })), new P(p, h, { path: s || this.path || "", crossOrigin: this.crossOrigin, manager: this.manager }).parse(function(e, t, n, r) { u({ scene: e, scenes: t, cameras: n, animations: r }) }, c))
                    }
                };
                var t = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_LIGHTS: "KHR_lights", KHR_MATERIALS_COMMON: "KHR_materials_common", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness" };

                function n(e) { this.name = t.KHR_MATERIALS_COMMON }
                n.prototype.getMaterialType = function(e) {
                    switch (e.extensions[this.name].type) {
                        case "commonBlinn":
                        case "commonPhong":
                            return r.MeshPhongMaterial;
                        case "commonLambert":
                            return r.MeshLambertMaterial;
                        case "commonConstant":
                        default:
                            return r.MeshBasicMaterial
                    }
                }, n.prototype.extendParams = function(e, t, n) {
                    var i = t.extensions[this.name],
                        o = [],
                        a = [];
                    switch (i.type) {
                        case "commonBlinn":
                        case "commonPhong":
                            a.push("diffuseFactor", "diffuseTexture", "specularFactor", "specularTexture", "shininessFactor");
                            break;
                        case "commonLambert":
                            a.push("diffuseFactor", "diffuseTexture")
                    }
                    var s = {};
                    return a.forEach(function(e) { void 0 !== i[e] && (s[e] = i[e]) }), void 0 !== s.diffuseFactor && (e.color = (new r.Color).fromArray(s.diffuseFactor), e.opacity = s.diffuseFactor[3]), void 0 !== s.diffuseTexture && o.push(n.assignTexture(e, "map", s.diffuseTexture.index)), void 0 !== s.specularFactor && (e.specular = (new r.Color).fromArray(s.specularFactor)), void 0 !== s.specularTexture && o.push(n.assignTexture(e, "specularMap", s.specularTexture.index)), void 0 !== s.shininessFactor && (e.shininess = s.shininessFactor), Promise.all(o)
                };
                var i = "glTF",
                    o = 12,
                    a = { JSON: 1313821514, BIN: 5130562 };
                var s = 0,
                    u = 1,
                    c = 2,
                    l = 3,
                    h = 4,
                    p = 5,
                    d = 6,
                    f = (Number, r.Matrix3, r.Matrix4, r.Vector2, r.Vector3, r.Vector4, r.Texture, { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }),
                    m = { 9728: r.NearestFilter, 9729: r.LinearFilter, 9984: r.NearestMipMapNearestFilter, 9985: r.LinearMipMapNearestFilter, 9986: r.NearestMipMapLinearFilter, 9987: r.LinearMipMapLinearFilter },
                    v = { 33071: r.ClampToEdgeWrapping, 33648: r.MirroredRepeatWrapping, 10497: r.RepeatWrapping },
                    g = { 6406: r.AlphaFormat, 6407: r.RGBFormat, 6408: r.RGBAFormat, 6409: r.LuminanceFormat, 6410: r.LuminanceAlphaFormat },
                    y = { 5121: r.UnsignedByteType, 32819: r.UnsignedShort4444Type, 32820: r.UnsignedShort5551Type, 33635: r.UnsignedShort565Type },
                    _ = (r.BackSide, r.FrontSide, r.NeverDepth, r.LessDepth, r.EqualDepth, r.LessEqualDepth, r.GreaterEqualDepth, r.NotEqualDepth, r.GreaterEqualDepth, r.AlwaysDepth, r.AddEquation, r.SubtractEquation, r.ReverseSubtractEquation, r.ZeroFactor, r.OneFactor, r.SrcColorFactor, r.OneMinusSrcColorFactor, r.SrcAlphaFactor, r.OneMinusSrcAlphaFactor, r.DstAlphaFactor, r.OneMinusDstAlphaFactor, r.DstColorFactor, r.OneMinusDstColorFactor, r.SrcAlphaSaturateFactor, { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }),
                    x = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" },
                    b = { CATMULLROMSPLINE: r.InterpolateSmooth, CUBICSPLINE: r.InterpolateSmooth, LINEAR: r.InterpolateLinear, STEP: r.InterpolateDiscrete },
                    w = "OPAQUE",
                    M = "MASK";

                function E(e, t, n) {
                    if (!e) return Promise.resolve();
                    var r, i = [];
                    if ("[object Array]" === Object.prototype.toString.call(e)) {
                        r = [];
                        for (var o = e.length, a = 0; a < o; a++) {
                            (u = t.call(n || this, e[a], a)) && (i.push(u), u instanceof Promise ? u.then(function(e, t) { r[e] = t }.bind(this, a)) : r[a] = u)
                        }
                    } else
                        for (var s in r = {}, e) { var u; if (e.hasOwnProperty(s))(u = t.call(n || this, e[s], s)) && (i.push(u), u instanceof Promise ? u.then(function(e, t) { r[e] = t }.bind(this, s)) : r[s] = u) }
                    return Promise.all(i).then(function() { return r })
                }

                function S(e, t) { return "string" != typeof e || "" === e ? "" : /^(https?:)?\/\//i.test(e) ? e : /^data:.*,.*$/i.test(e) ? e : /^blob:.*$/i.test(e) ? e : t + e }

                function T(e) { if (void 0 !== window.TextDecoder) return (new TextDecoder).decode(e); for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]); return t }

                function A(e, t, n, r) {
                    var i = e.geometry,
                        o = e.material,
                        a = n.targets,
                        s = i.morphAttributes;
                    s.position = [], s.normal = [], o.morphTargets = !0;
                    for (var u = 0, c = a.length; u < c; u++) {
                        var l, h, p = a[u],
                            d = "morphTarget" + u;
                        if (void 0 !== p.POSITION) { l = r.accessors[p.POSITION].clone(); for (var f = i.attributes.position, m = 0, v = l.count; m < v; m++) l.setXYZ(m, l.getX(m) + f.getX(m), l.getY(m) + f.getY(m), l.getZ(m) + f.getZ(m)) } else i.attributes.position && (l = i.attributes.position.clone());
                        if (void 0 !== l && (l.name = d, s.position.push(l)), void 0 !== p.NORMAL) { o.morphNormals = !0, h = r.accessors[p.NORMAL].clone(); var g = i.attributes.normal; for (m = 0, v = h.count; m < v; m++) h.setXYZ(m, h.getX(m) + g.getX(m), h.getY(m) + g.getY(m), h.getZ(m) + g.getZ(m)) } else void 0 !== i.attributes.normal && (h = i.attributes.normal.clone());
                        void 0 !== h && (h.name = d, s.normal.push(h))
                    }
                    if (e.updateMorphTargets(), void 0 !== t.weights)
                        for (u = 0, c = t.weights.length; u < c; u++) e.morphTargetInfluences[u] = t.weights[u]
                }

                function P(e, t, n) { this.json = e || {}, this.extensions = t || {}, this.options = n || {}, this.cache = new function() { var e = {}; return { get: function(t) { return e[t] }, add: function(t, n) { e[t] = n }, remove: function(t) { delete e[t] }, removeAll: function() { e = {} } } }, this.textureLoader = new r.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new r.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer") }
                return P.prototype._withDependencies = function(e) {
                    for (var t = {}, n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = "load" + r.charAt(0).toUpperCase() + r.slice(1),
                            o = this.cache.get(r);
                        if (void 0 !== o) t[r] = o;
                        else if (this[i]) {
                            var a = this[i]();
                            this.cache.add(r, a), t[r] = a
                        }
                    }
                    return E(t, function(e) { return e })
                }, P.prototype.parse = function(e, t) {
                    var n = this.json,
                        r = this;
                    this.cache.removeAll(), this._withDependencies(["scenes", "animations"]).then(function(i) {
                        var o = i.scenes || [],
                            a = o[n.scene || 0],
                            s = i.animations || [];
                        r.getDependencies("camera").then(function(t) { e(a, o, t, s) }).catch(t)
                    }).catch(t)
                }, P.prototype.getDependency = function(e, t) {
                    var n = e + ":" + t,
                        r = this.cache.get(n);
                    r || (r = this["load" + e.charAt(0).toUpperCase() + e.slice(1)](t), this.cache.add(n, r));
                    return r
                }, P.prototype.getDependencies = function(e) {
                    var t = this,
                        n = this.json[e + "s"] || [];
                    return Promise.all(n.map(function(n, r) { return t.getDependency(e, r) }))
                }, P.prototype.loadBuffer = function(e) {
                    var n = this.json.buffers[e],
                        r = this.fileLoader;
                    if (n.type && "arraybuffer" !== n.type) throw new Error("THREE.GLTFLoader: %s buffer type is not supported.", n.type);
                    if (void 0 === n.uri && 0 === e) return Promise.resolve(this.extensions[t.KHR_BINARY_GLTF].body);
                    var i = this.options;
                    return new Promise(function(e, t) { r.load(S(n.uri, i.path), e, void 0, function() { t(new Error('THREE.GLTFLoader: Buffer "' + n.uri + '" not found.')) }) })
                }, P.prototype.loadBufferView = function(e) {
                    var t = this.json.bufferViews[e];
                    return this.getDependency("buffer", t.buffer).then(function(e) {
                        var n = t.byteLength || 0,
                            r = t.byteOffset || 0;
                        return e.slice(r, r + n)
                    })
                }, P.prototype.loadAccessors = function() {
                    var e = this,
                        t = this.json;
                    return E(t.accessors, function(n) {
                        return e.getDependency("bufferView", n.bufferView).then(function(e) {
                            var i, o = _[n.type],
                                a = f[n.componentType],
                                s = a.BYTES_PER_ELEMENT,
                                u = s * o,
                                c = t.bufferViews[n.bufferView].byteStride;
                            if (c && c !== u) { i = new a(e); var l = new r.InterleavedBuffer(i, c / s); return new r.InterleavedBufferAttribute(l, o, n.byteOffset / s) }
                            return i = new a(e, n.byteOffset, n.count * o), new r.BufferAttribute(i, o)
                        })
                    })
                }, P.prototype.loadTexture = function(e) {
                    var t = this.json,
                        n = this.options,
                        i = this.textureLoader,
                        o = window.URL || window.webkitURL,
                        a = t.textures[e],
                        s = t.images[a.source],
                        u = s.uri,
                        c = !1;
                    return void 0 !== s.bufferView && (u = this.getDependency("bufferView", s.bufferView).then(function(e) { c = !0; var t = new Blob([e], { type: s.mimeType }); return u = o.createObjectURL(t) })), Promise.resolve(u).then(function(e) { var t = r.Loader.Handlers.get(e) || i; return new Promise(function(r, i) { t.load(S(e, n.path), r, void 0, i) }) }).then(function(e) {!0 === c && o.revokeObjectURL(u), e.flipY = !1, void 0 !== a.name && (e.name = a.name), e.format = void 0 !== a.format ? g[a.format] : r.RGBAFormat, void 0 !== a.internalFormat && e.format !== g[a.internalFormat] && console.warn("THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. internalFormat will be forced to be the same value as format."), e.type = void 0 !== a.type ? y[a.type] : r.UnsignedByteType; var n = (t.samplers || {})[a.sampler] || {}; return e.magFilter = m[n.magFilter] || r.LinearFilter, e.minFilter = m[n.minFilter] || r.LinearMipMapLinearFilter, e.wrapS = v[n.wrapS] || r.RepeatWrapping, e.wrapT = v[n.wrapT] || r.RepeatWrapping, e })
                }, P.prototype.assignTexture = function(e, t, n) { return this.getDependency("texture", n).then(function(n) { e[t] = n }) }, P.prototype.loadMaterials = function() {
                    var e = this,
                        n = this.json,
                        i = this.extensions;
                    return E(n.materials, function(n) {
                        var o, a = {},
                            s = n.extensions || {},
                            u = [];
                        if (s[t.KHR_MATERIALS_COMMON]) {
                            var c = i[t.KHR_MATERIALS_COMMON];
                            o = c.getMaterialType(n), u.push(c.extendParams(a, n, e))
                        } else if (s[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            var l = i[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            o = l.getMaterialType(n), u.push(l.extendParams(a, n, e))
                        } else if (void 0 !== n.pbrMetallicRoughness) {
                            o = r.MeshStandardMaterial;
                            var h = n.pbrMetallicRoughness;
                            if (a.color = new r.Color(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
                                var p = h.baseColorFactor;
                                a.color.fromArray(p), a.opacity = p[3]
                            }
                            if (void 0 !== h.baseColorTexture && u.push(e.assignTexture(a, "map", h.baseColorTexture.index)), a.metalness = void 0 !== h.metallicFactor ? h.metallicFactor : 1, a.roughness = void 0 !== h.roughnessFactor ? h.roughnessFactor : 1, void 0 !== h.metallicRoughnessTexture) {
                                var d = h.metallicRoughnessTexture.index;
                                u.push(e.assignTexture(a, "metalnessMap", d)), u.push(e.assignTexture(a, "roughnessMap", d))
                            }
                        } else o = r.MeshPhongMaterial;
                        !0 === n.doubleSided && (a.side = r.DoubleSide);
                        var f = n.alphaMode || w;
                        return f !== w ? (a.transparent = !0, f === M && (a.alphaTest = n.alphaCutoff || .5)) : a.transparent = !1, void 0 !== n.normalTexture && (u.push(e.assignTexture(a, "normalMap", n.normalTexture.index)), a.normalScale = new r.Vector2(1, 1), void 0 !== n.normalTexture.scale && a.normalScale.set(n.normalTexture.scale, n.normalTexture.scale)), void 0 !== n.occlusionTexture && (u.push(e.assignTexture(a, "aoMap", n.occlusionTexture.index)), void 0 !== n.occlusionTexture.strength && (a.aoMapIntensity = n.occlusionTexture.strength)), void 0 !== n.emissiveFactor && (o === r.MeshBasicMaterial ? a.color = (new r.Color).fromArray(n.emissiveFactor) : a.emissive = (new r.Color).fromArray(n.emissiveFactor)), void 0 !== n.emissiveTexture && (o === r.MeshBasicMaterial ? u.push(e.assignTexture(a, "map", n.emissiveTexture.index)) : u.push(e.assignTexture(a, "emissiveMap", n.emissiveTexture.index))), Promise.all(u).then(function() { var e; return e = o === r.ShaderMaterial ? i[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new o(a), void 0 !== n.name && (e.name = n.name), e.normalScale && (e.normalScale.x = -e.normalScale.x), e.map && (e.map.encoding = r.sRGBEncoding), e.emissiveMap && (e.emissiveMap.encoding = r.sRGBEncoding), n.extras && (e.userData = n.extras), e })
                    })
                }, P.prototype.loadGeometries = function(e) {
                    return this._withDependencies(["accessors"]).then(function(t) {
                        return E(e, function(e) {
                            var n = new r.BufferGeometry,
                                i = e.attributes;
                            for (var o in i) {
                                var a = i[o];
                                if (void 0 === a) return;
                                var s = t.accessors[a];
                                switch (o) {
                                    case "POSITION":
                                        n.addAttribute("position", s);
                                        break;
                                    case "NORMAL":
                                        n.addAttribute("normal", s);
                                        break;
                                    case "TEXCOORD_0":
                                    case "TEXCOORD0":
                                    case "TEXCOORD":
                                        n.addAttribute("uv", s);
                                        break;
                                    case "TEXCOORD_1":
                                        n.addAttribute("uv2", s);
                                        break;
                                    case "COLOR_0":
                                    case "COLOR0":
                                    case "COLOR":
                                        n.addAttribute("color", s);
                                        break;
                                    case "WEIGHTS_0":
                                    case "WEIGHT":
                                        n.addAttribute("skinWeight", s);
                                        break;
                                    case "JOINTS_0":
                                    case "JOINT":
                                        n.addAttribute("skinIndex", s)
                                }
                            }
                            return void 0 !== e.indices && n.setIndex(t.accessors[e.indices]), n
                        })
                    })
                }, P.prototype.loadMeshes = function() {
                    var e = this,
                        n = this.json,
                        i = this.extensions;
                    return this._withDependencies(["accessors", "materials"]).then(function(o) {
                        return E(n.meshes, function(n, a) {
                            var f = new r.Group,
                                m = n.primitives || [];
                            return e.loadGeometries(m).then(function(e) {
                                for (var v = 0; v < m.length; v++) {
                                    var g = m[v],
                                        y = e[v],
                                        _ = void 0 === g.material ? new r.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: r.FrontSide }) : o.materials[g.material];
                                    _.aoMap && void 0 === y.attributes.uv2 && void 0 !== y.attributes.uv && (console.log("THREE.GLTFLoader: Duplicating UVs to support aoMap."), y.addAttribute("uv2", new r.BufferAttribute(y.attributes.uv.array, 2)));
                                    var x, b = void 0 !== y.attributes.color,
                                        w = void 0 === y.attributes.normal;
                                    if (b || w)
                                        if (_.isGLTFSpecularGlossinessMaterial) _ = i[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(_);
                                        else _ = _.clone();
                                    if (b && (_.vertexColors = r.VertexColors, _.needsUpdate = !0), w && (_.flatShading = !0), g.mode === h || void 0 === g.mode) x = new r.Mesh(y, _);
                                    else if (g.mode === p)(x = new r.Mesh(y, _)).drawMode = r.TriangleStripDrawMode;
                                    else if (g.mode === d)(x = new r.Mesh(y, _)).drawMode = r.TriangleFanDrawMode;
                                    else if (g.mode === u) x = new r.LineSegments(y, _);
                                    else if (g.mode === l) x = new r.Line(y, _);
                                    else if (g.mode === c) x = new r.LineLoop(y, _);
                                    else {
                                        if (g.mode !== s) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: ", g.mode);
                                        x = new r.Points(y, _)
                                    }
                                    if (x.name = n.name || "mesh_" + a, void 0 !== g.targets && A(x, n, g, o), g.extras && (x.userData = g.extras), !(m.length > 1)) return x;
                                    x.name += "_" + v, f.add(x)
                                }
                                return f
                            })
                        })
                    })
                }, P.prototype.loadCamera = function(e) {
                    var t, n = this.json.cameras[e],
                        i = n[n.type];
                    if (i) {
                        if ("perspective" === n.type) {
                            var o = i.aspectRatio || 1,
                                a = i.yfov * o;
                            t = new r.PerspectiveCamera(r.Math.radToDeg(a), o, i.znear || 1, i.zfar || 2e6)
                        } else "orthographic" === n.type && (t = new r.OrthographicCamera(i.xmag / -2, i.xmag / 2, i.ymag / 2, i.ymag / -2, i.znear, i.zfar));
                        return void 0 !== n.name && (t.name = n.name), n.extras && (t.userData = n.extras), Promise.resolve(t)
                    }
                    console.warn("THREE.GLTFLoader: Missing camera parameters.")
                }, P.prototype.loadSkins = function() { var e = this.json; return this._withDependencies(["accessors"]).then(function(t) { return E(e.skins, function(e) { return { joints: e.joints, inverseBindMatrices: t.accessors[e.inverseBindMatrices] } }) }) }, P.prototype.loadAnimations = function() {
                    var e = this.json;
                    return this._withDependencies(["accessors", "nodes"]).then(function(t) {
                        return E(e.animations, function(e, n) {
                            for (var i = [], o = 0; o < e.channels.length; o++) {
                                var a = e.channels[o],
                                    s = e.samplers[a.sampler];
                                if (s) {
                                    var u = a.target,
                                        c = void 0 !== u.node ? u.node : u.id,
                                        l = void 0 !== e.parameters ? e.parameters[s.input] : s.input,
                                        h = void 0 !== e.parameters ? e.parameters[s.output] : s.output,
                                        p = t.accessors[l],
                                        d = t.accessors[h],
                                        f = t.nodes[c];
                                    if (f) {
                                        var m;
                                        switch (f.updateMatrix(), f.matrixAutoUpdate = !0, x[u.path]) {
                                            case x.weights:
                                                m = r.NumberKeyframeTrack;
                                                break;
                                            case x.rotation:
                                                m = r.QuaternionKeyframeTrack;
                                                break;
                                            case x.position:
                                            case x.scale:
                                            default:
                                                m = r.VectorKeyframeTrack
                                        }
                                        var v = f.name ? f.name : f.uuid;
                                        "CATMULLROMSPLINE" === s.interpolation && console.warn("THREE.GLTFLoader: CATMULLROMSPLINE interpolation is not supported. Using CUBICSPLINE instead.");
                                        var g = void 0 !== s.interpolation ? b[s.interpolation] : r.InterpolateLinear,
                                            y = [];
                                        x[u.path] === x.weights ? f.traverse(function(e) {!0 === e.isMesh && !0 === e.material.morphTargets && y.push(e.name ? e.name : e.uuid) }) : y.push(v);
                                        for (var _ = 0, w = y.length; _ < w; _++) i.push(new m(y[_] + "." + x[u.path], r.AnimationUtils.arraySlice(p.array, 0), r.AnimationUtils.arraySlice(d.array, 0), g))
                                    }
                                }
                            }
                            c = void 0 !== e.name ? e.name : "animation_" + n;
                            return new r.AnimationClip(c, void 0, i)
                        })
                    })
                }, P.prototype.loadNodes = function() {
                    var e = this.json,
                        n = this.extensions,
                        i = this,
                        o = e.nodes || [],
                        a = e.skins || [],
                        s = {},
                        u = {};
                    for (var c in a)
                        for (var l = a[c].joints, h = 0; h < l.length; ++h) o[l[h]].isBone = !0;
                    for (var p in o) {
                        var d = o[p];
                        void 0 !== d.mesh && (void 0 === s[d.mesh] && (s[d.mesh] = u[d.mesh] = 0), s[d.mesh]++)
                    }
                    return i._withDependencies(["meshes", "skins", "cameras"]).then(function(o) {
                        return E(e.nodes, function(e) { if (!0 === e.isBone) return new r.Bone; if (void 0 !== e.mesh) { var a = o.meshes[e.mesh].clone(); return s[e.mesh] > 1 && (a.name += "_instance_" + u[e.mesh]++), a } return void 0 !== e.camera ? i.getDependency("camera", e.camera) : e.extensions && e.extensions[t.KHR_LIGHTS] && void 0 !== e.extensions[t.KHR_LIGHTS].light ? n[t.KHR_LIGHTS].lights[e.extensions[t.KHR_LIGHTS].light] : new r.Object3D }).then(function(t) {
                            return E(t, function(n, i) {
                                var a = e.nodes[i];
                                if (void 0 !== a.name && (n.name = r.PropertyBinding.sanitizeNodeName(a.name)), a.extras && (n.userData = a.extras), void 0 !== a.matrix) {
                                    var s = new r.Matrix4;
                                    s.fromArray(a.matrix), n.applyMatrix(s)
                                } else void 0 !== a.translation && n.position.fromArray(a.translation), void 0 !== a.rotation && n.quaternion.fromArray(a.rotation), void 0 !== a.scale && n.scale.fromArray(a.scale);
                                if (void 0 !== a.skin) {
                                    for (var u = [], c = n.children.length > 0 ? n.children : [n], l = 0; l < c.length; l++) {
                                        var h = c[l],
                                            p = o.skins[a.skin],
                                            d = h.geometry,
                                            f = h.material;
                                        f.skinning = !0;
                                        var m = new r.SkinnedMesh(d, f);
                                        m.morphTargetInfluences = h.morphTargetInfluences, m.userData = h.userData, m.name = h.name;
                                        for (var v = [], g = [], y = 0, _ = p.joints.length; y < _; y++) {
                                            var x = p.joints[y],
                                                b = t[x];
                                            if (b) {
                                                v.push(b);
                                                var w = p.inverseBindMatrices.array,
                                                    M = (new r.Matrix4).fromArray(w, 16 * y);
                                                g.push(M)
                                            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', x)
                                        }
                                        m.bind(new r.Skeleton(v, g), m.matrixWorld), u.push(m)
                                    }
                                    n.children.length > 0 ? (n.remove.apply(n, n.children), n.add.apply(n, u)) : n = u[0]
                                }
                                return n
                            })
                        })
                    })
                }, P.prototype.loadScenes = function() {
                    var e = this.json,
                        n = this.extensions;

                    function i(t, n, r) {
                        var o = r[t];
                        n.add(o);
                        var a = e.nodes[t];
                        if (a.children)
                            for (var s = a.children, u = 0, c = s.length; u < c; u++) { i(s[u], o, r) }
                    }
                    return this._withDependencies(["nodes"]).then(function(o) {
                        return E(e.scenes, function(e) {
                            var a = new r.Scene;
                            void 0 !== e.name && (a.name = e.name), e.extras && (a.userData = e.extras);
                            for (var s = e.nodes || [], u = 0, c = s.length; u < c; u++) { i(s[u], a, o.nodes) }
                            if (a.traverse(function(e) { e.material && e.material.isGLTFSpecularGlossinessMaterial && (e.onBeforeRender = n[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms) }), e.extensions && e.extensions[t.KHR_LIGHTS] && void 0 !== e.extensions[t.KHR_LIGHTS].light) {
                                var l = n[t.KHR_LIGHTS].lights;
                                a.add(l[e.extensions[t.KHR_LIGHTS].light])
                            }
                            return a
                        })
                    })
                }, e
            }();
            var i = r.GLTFLoader;
            t.default = i
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0;
            var r, i = n(286);

            function o(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                }
            }
            var a = function() {
                function e() {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e) }
                var t, n, a;
                return t = e, (n = [{ key: "setup", value: function() { r = new i.Howl({ src: ["/iframes/nipple/static/release.mp3"], sprite: { s0: [0, 294], s1: [323, 347], s2: [702, 289], s3: [1018, 315], s4: [1365, 350], s5: [1750, 308] } }), console.log(r) } }, {
                    key: "playRelease",
                    value: function(e) {
                        var t = r.play("s".concat((5 * Math.random()).toFixed()));
                        r.volume(e, t), r.rate(1 + .3 * Math.random(), t)
                    }
                }]) && o(t.prototype, n), a && o(t, a), e
            }();
            t.default = a
        }, function(e, t, n) {
            (function(n) {
                var r;
                ! function() {
                    "use strict";
                    var i = function() { this.init() };
                    i.prototype = {
                        init: function() { var e = this || o; return e._counter = 1e3, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.mobileAutoEnable = !0, e._setup(), e },
                        volume: function(e) {
                            var t = this || o;
                            if (e = parseFloat(e), t.ctx || d(), void 0 !== e && e >= 0 && e <= 1) {
                                if (t._volume = e, t._muted) return t;
                                t.usingWebAudio && t.masterGain.gain.setValueAtTime(e, o.ctx.currentTime);
                                for (var n = 0; n < t._howls.length; n++)
                                    if (!t._howls[n]._webAudio)
                                        for (var r = t._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                            var a = t._howls[n]._soundById(r[i]);
                                            a && a._node && (a._node.volume = a._volume * e)
                                        }
                                return t
                            }
                            return t._volume
                        },
                        mute: function(e) {
                            var t = this || o;
                            t.ctx || d(), t._muted = e, t.usingWebAudio && t.masterGain.gain.setValueAtTime(e ? 0 : t._volume, o.ctx.currentTime);
                            for (var n = 0; n < t._howls.length; n++)
                                if (!t._howls[n]._webAudio)
                                    for (var r = t._howls[n]._getSoundIds(), i = 0; i < r.length; i++) {
                                        var a = t._howls[n]._soundById(r[i]);
                                        a && a._node && (a._node.muted = !!e || a._muted)
                                    }
                            return t
                        },
                        unload: function() { for (var e = this || o, t = e._howls.length - 1; t >= 0; t--) e._howls[t].unload(); return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, d()), e },
                        codecs: function(e) { return (this || o)._codecs[e.replace(/^x-/, "")] },
                        _setup: function() {
                            var e = this || o;
                            if (e.state = e.ctx && e.ctx.state || "running", e._autoSuspend(), !e.usingWebAudio)
                                if ("undefined" != typeof Audio) try { void 0 === (new Audio).oncanplaythrough && (e._canPlayEvent = "canplay") } catch (t) { e.noAudio = !0 } else e.noAudio = !0;
                            try {
                                (new Audio).muted && (e.noAudio = !0)
                            } catch (e) {}
                            return e.noAudio || e._setupCodecs(), e
                        },
                        _setupCodecs: function() {
                            var e = this || o,
                                t = null;
                            try { t = "undefined" != typeof Audio ? new Audio : null } catch (t) { return e }
                            if (!t || "function" != typeof t.canPlayType) return e;
                            var n = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                                r = e._navigator && e._navigator.userAgent.match(/OPR\/([0-6].)/g),
                                i = r && parseInt(r[0].split("/")[1], 10) < 33;
                            return e._codecs = { mp3: !(i || !n && !t.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!n, opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""), webm: !!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""), dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "") }, e
                        },
                        _enableMobileAudio: function() {
                            var e = this || o,
                                t = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi|Chrome/i.test(e._navigator && e._navigator.userAgent);
                            if (!e._mobileEnabled && e.ctx && t) {
                                e._mobileEnabled = !1, e.mobileAutoEnable = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);
                                var n = function(t) {
                                    o._autoResume();
                                    var r = e.ctx.createBufferSource();
                                    r.buffer = e._scratchBuffer, r.connect(e.ctx.destination), void 0 === r.start ? r.noteOn(0) : r.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), r.onended = function() { r.disconnect(0), e._mobileEnabled = !0, document.removeEventListener("touchstart", n, !0), document.removeEventListener("touchend", n, !0), document.removeEventListener("click", n, !0); for (var t = 0; t < e._howls.length; t++) e._howls[t]._emit("unlock") }
                                };
                                return document.addEventListener("touchstart", n, !0), document.addEventListener("touchend", n, !0), document.addEventListener("click", n, !0), e
                            }
                        },
                        _autoSuspend: function() {
                            var e = this;
                            if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && o.usingWebAudio) {
                                for (var t = 0; t < e._howls.length; t++)
                                    if (e._howls[t]._webAudio)
                                        for (var n = 0; n < e._howls[t]._sounds.length; n++)
                                            if (!e._howls[t]._sounds[n]._paused) return e;
                                return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function() { e.autoSuspend && (e._suspendTimer = null, e.state = "suspending", e.ctx.suspend().then(function() { e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume()) })) }, 3e4), e
                            }
                        },
                        _autoResume: function() { var e = this; if (e.ctx && void 0 !== e.ctx.resume && o.usingWebAudio) return "running" === e.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state ? (e.ctx.resume().then(function() { e.state = "running"; for (var t = 0; t < e._howls.length; t++) e._howls[t]._emit("resume") }), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e }
                    };
                    var o = new i,
                        a = function(e) { e.src && 0 !== e.src.length ? this.init(e) : console.error("An array of source files must be passed with any new Howl.") };
                    a.prototype = {
                        init: function(e) { var t = this; return o.ctx || d(), t._autoplay = e.autoplay || !1, t._format = "string" != typeof e.format ? e.format : [e.format], t._html5 = e.html5 || !1, t._muted = e.mute || !1, t._loop = e.loop || !1, t._pool = e.pool || 5, t._preload = "boolean" != typeof e.preload || e.preload, t._rate = e.rate || 1, t._sprite = e.sprite || {}, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._xhrWithCredentials = e.xhrWithCredentials || !1, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._playLock = !1, t._onend = e.onend ? [{ fn: e.onend }] : [], t._onfade = e.onfade ? [{ fn: e.onfade }] : [], t._onload = e.onload ? [{ fn: e.onload }] : [], t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : [], t._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : [], t._onpause = e.onpause ? [{ fn: e.onpause }] : [], t._onplay = e.onplay ? [{ fn: e.onplay }] : [], t._onstop = e.onstop ? [{ fn: e.onstop }] : [], t._onmute = e.onmute ? [{ fn: e.onmute }] : [], t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : [], t._onrate = e.onrate ? [{ fn: e.onrate }] : [], t._onseek = e.onseek ? [{ fn: e.onseek }] : [], t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : [], t._onresume = [], t._webAudio = o.usingWebAudio && !t._html5, void 0 !== o.ctx && o.ctx && o.mobileAutoEnable && o._enableMobileAudio(), o._howls.push(t), t._autoplay && t._queue.push({ event: "play", action: function() { t.play() } }), t._preload && t.load(), t },
                        load: function() {
                            var e = null;
                            if (o.noAudio) this._emit("loaderror", null, "No audio support.");
                            else {
                                "string" == typeof this._src && (this._src = [this._src]);
                                for (var t = 0; t < this._src.length; t++) {
                                    var n, r;
                                    if (this._format && this._format[t]) n = this._format[t];
                                    else { if ("string" != typeof(r = this._src[t])) { this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring."); continue }(n = /^data:audio\/([^;,]+);/i.exec(r)) || (n = /\.([^.]+)$/.exec(r.split("?", 1)[0])), n && (n = n[1].toLowerCase()) }
                                    if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && o.codecs(n)) { e = this._src[t]; break }
                                }
                                if (e) return this._src = e, this._state = "loading", "https:" === window.location.protocol && "http:" === e.slice(0, 5) && (this._html5 = !0, this._webAudio = !1), new s(this), this._webAudio && c(this), this;
                                this._emit("loaderror", null, "No codec support for selected audio sources.")
                            }
                        },
                        play: function(e, t) {
                            var n = this,
                                r = null;
                            if ("number" == typeof e) r = e, e = null;
                            else {
                                if ("string" == typeof e && "loaded" === n._state && !n._sprite[e]) return null;
                                if (void 0 === e) {
                                    e = "__default";
                                    for (var i = 0, a = 0; a < n._sounds.length; a++) n._sounds[a]._paused && !n._sounds[a]._ended && (i++, r = n._sounds[a]._id);
                                    1 === i ? e = null : r = null
                                }
                            }
                            var s = r ? n._soundById(r) : n._inactiveSound();
                            if (!s) return null;
                            if (r && !e && (e = s._sprite || "__default"), "loaded" !== n._state) { s._sprite = e, s._ended = !1; var u = s._id; return n._queue.push({ event: "play", action: function() { n.play(u) } }), u }
                            if (r && !s._paused) return t || n._loadQueue("play"), s._id;
                            n._webAudio && o._autoResume();
                            var c = Math.max(0, s._seek > 0 ? s._seek : n._sprite[e][0] / 1e3),
                                l = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - c),
                                h = 1e3 * l / Math.abs(s._rate);
                            if (s._paused = !1, s._ended = !1, s._sprite = e, s._seek = c, s._start = n._sprite[e][0] / 1e3, s._stop = (n._sprite[e][0] + n._sprite[e][1]) / 1e3, s._loop = !(!s._loop && !n._sprite[e][2]), !(s._seek >= s._stop)) {
                                var p = s._node;
                                if (n._webAudio) {
                                    var d = function() {
                                        n._refreshBuffer(s);
                                        var e = s._muted || n._muted ? 0 : s._volume;
                                        p.gain.setValueAtTime(e, o.ctx.currentTime), s._playStart = o.ctx.currentTime, void 0 === p.bufferSource.start ? s._loop ? p.bufferSource.noteGrainOn(0, c, 86400) : p.bufferSource.noteGrainOn(0, c, l) : s._loop ? p.bufferSource.start(0, c, 86400) : p.bufferSource.start(0, c, l), h !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h)), t || setTimeout(function() { n._emit("play", s._id) }, 0)
                                    };
                                    "running" === o.state ? d() : (n.once("resume", d), n._clearTimer(s._id))
                                } else {
                                    var f = function() { p.currentTime = c, p.muted = s._muted || n._muted || o._muted || p.muted, p.volume = s._volume * o.volume(), p.playbackRate = s._rate; try { var r = p.play(); if (r && "undefined" != typeof Promise && (r instanceof Promise || "function" == typeof r.then) ? (n._playLock = !0, r.then(function() { n._playLock = !1, t || n._emit("play", s._id) }).catch(function() { n._playLock = !1, n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.") })) : t || n._emit("play", s._id), p.playbackRate = s._rate, p.paused) return void n._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."); "__default" !== e || s._loop ? n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), h) : (n._endTimers[s._id] = function() { n._ended(s), p.removeEventListener("ended", n._endTimers[s._id], !1) }, p.addEventListener("ended", n._endTimers[s._id], !1)) } catch (e) { n._emit("playerror", s._id, e) } },
                                        m = window && window.ejecta || !p.readyState && o._navigator.isCocoonJS;
                                    if (p.readyState >= 3 || m) f();
                                    else {
                                        var v = function() { f(), p.removeEventListener(o._canPlayEvent, v, !1) };
                                        p.addEventListener(o._canPlayEvent, v, !1), n._clearTimer(s._id)
                                    }
                                }
                                return s._id
                            }
                            n._ended(s)
                        },
                        pause: function(e) {
                            var t = this;
                            if ("loaded" !== t._state || t._playLock) return t._queue.push({ event: "pause", action: function() { t.pause(e) } }), t;
                            for (var n = t._getSoundIds(e), r = 0; r < n.length; r++) {
                                t._clearTimer(n[r]);
                                var i = t._soundById(n[r]);
                                if (i && !i._paused && (i._seek = t.seek(n[r]), i._rateSeek = 0, i._paused = !0, t._stopFade(n[r]), i._node))
                                    if (t._webAudio) {
                                        if (!i._node.bufferSource) continue;
                                        void 0 === i._node.bufferSource.stop ? i._node.bufferSource.noteOff(0) : i._node.bufferSource.stop(0), t._cleanBuffer(i._node)
                                    } else isNaN(i._node.duration) && i._node.duration !== 1 / 0 || i._node.pause();
                                arguments[1] || t._emit("pause", i ? i._id : null)
                            }
                            return t
                        },
                        stop: function(e, t) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "stop", action: function() { n.stop(e) } }), n;
                            for (var r = n._getSoundIds(e), i = 0; i < r.length; i++) {
                                n._clearTimer(r[i]);
                                var o = n._soundById(r[i]);
                                o && (o._seek = o._start || 0, o._rateSeek = 0, o._paused = !0, o._ended = !0, n._stopFade(r[i]), o._node && (n._webAudio ? o._node.bufferSource && (void 0 === o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0), n._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0, o._node.pause())), t || n._emit("stop", o._id))
                            }
                            return n
                        },
                        mute: function(e, t) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "mute", action: function() { n.mute(e, t) } }), n;
                            if (void 0 === t) {
                                if ("boolean" != typeof e) return n._muted;
                                n._muted = e
                            }
                            for (var r = n._getSoundIds(t), i = 0; i < r.length; i++) {
                                var a = n._soundById(r[i]);
                                a && (a._muted = e, a._interval && n._stopFade(a._id), n._webAudio && a._node ? a._node.gain.setValueAtTime(e ? 0 : a._volume, o.ctx.currentTime) : a._node && (a._node.muted = !!o._muted || e), n._emit("mute", a._id))
                            }
                            return n
                        },
                        volume: function() {
                            var e, t, n, r = this,
                                i = arguments;
                            if (0 === i.length) return r._volume;
                            if (1 === i.length || 2 === i.length && void 0 === i[1] ? r._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : e = parseFloat(i[0]) : i.length >= 2 && (e = parseFloat(i[0]), t = parseInt(i[1], 10)), !(void 0 !== e && e >= 0 && e <= 1)) return (n = t ? r._soundById(t) : r._sounds[0]) ? n._volume : 0;
                            if ("loaded" !== r._state || r._playLock) return r._queue.push({ event: "volume", action: function() { r.volume.apply(r, i) } }), r;
                            void 0 === t && (r._volume = e), t = r._getSoundIds(t);
                            for (var a = 0; a < t.length; a++)(n = r._soundById(t[a])) && (n._volume = e, i[2] || r._stopFade(t[a]), r._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(e, o.ctx.currentTime) : n._node && !n._muted && (n._node.volume = e * o.volume()), r._emit("volume", n._id));
                            return r
                        },
                        fade: function(e, t, n, r) {
                            var i = this;
                            if ("loaded" !== i._state || i._playLock) return i._queue.push({ event: "fade", action: function() { i.fade(e, t, n, r) } }), i;
                            i.volume(e, r);
                            for (var a = i._getSoundIds(r), s = 0; s < a.length; s++) {
                                var u = i._soundById(a[s]);
                                if (u) {
                                    if (r || i._stopFade(a[s]), i._webAudio && !u._muted) {
                                        var c = o.ctx.currentTime,
                                            l = c + n / 1e3;
                                        u._volume = e, u._node.gain.setValueAtTime(e, c), u._node.gain.linearRampToValueAtTime(t, l)
                                    }
                                    i._startFadeInterval(u, e, t, n, a[s], void 0 === r)
                                }
                            }
                            return i
                        },
                        _startFadeInterval: function(e, t, n, r, i, o) {
                            var a = this,
                                s = t,
                                u = n - t,
                                c = Math.abs(u / .01),
                                l = Math.max(4, c > 0 ? r / c : r),
                                h = Date.now();
                            e._fadeTo = n, e._interval = setInterval(function() {
                                var i = (Date.now() - h) / r;
                                h = Date.now(), s += u * i, s = Math.max(0, s), s = Math.min(1, s), s = Math.round(100 * s) / 100, a._webAudio ? e._volume = s : a.volume(s, e._id, !0), o && (a._volume = s), (n < t && s <= n || n > t && s >= n) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, a.volume(n, e._id), a._emit("fade", e._id))
                            }, l)
                        },
                        _stopFade: function(e) { var t = this._soundById(e); return t && t._interval && (this._webAudio && t._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(t._interval), t._interval = null, this.volume(t._fadeTo, e), t._fadeTo = null, this._emit("fade", e)), this },
                        loop: function() {
                            var e, t, n, r = arguments;
                            if (0 === r.length) return this._loop;
                            if (1 === r.length) {
                                if ("boolean" != typeof r[0]) return !!(n = this._soundById(parseInt(r[0], 10))) && n._loop;
                                e = r[0], this._loop = e
                            } else 2 === r.length && (e = r[0], t = parseInt(r[1], 10));
                            for (var i = this._getSoundIds(t), o = 0; o < i.length; o++)(n = this._soundById(i[o])) && (n._loop = e, this._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = e, e && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop)));
                            return this
                        },
                        rate: function() {
                            var e, t, n, r = this,
                                i = arguments;
                            if (0 === i.length) t = r._sounds[0]._id;
                            else if (1 === i.length) { r._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : e = parseFloat(i[0]) } else 2 === i.length && (e = parseFloat(i[0]), t = parseInt(i[1], 10));
                            if ("number" != typeof e) return (n = r._soundById(t)) ? n._rate : r._rate;
                            if ("loaded" !== r._state || r._playLock) return r._queue.push({ event: "rate", action: function() { r.rate.apply(r, i) } }), r;
                            void 0 === t && (r._rate = e), t = r._getSoundIds(t);
                            for (var a = 0; a < t.length; a++)
                                if (n = r._soundById(t[a])) {
                                    n._rateSeek = r.seek(t[a]), n._playStart = r._webAudio ? o.ctx.currentTime : n._playStart, n._rate = e, r._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(e, o.ctx.currentTime) : n._node && (n._node.playbackRate = e);
                                    var s = r.seek(t[a]),
                                        u = 1e3 * ((r._sprite[n._sprite][0] + r._sprite[n._sprite][1]) / 1e3 - s) / Math.abs(n._rate);
                                    !r._endTimers[t[a]] && n._paused || (r._clearTimer(t[a]), r._endTimers[t[a]] = setTimeout(r._ended.bind(r, n), u)), r._emit("rate", n._id)
                                }
                            return r
                        },
                        seek: function() {
                            var e, t, n = this,
                                r = arguments;
                            if (0 === r.length) t = n._sounds[0]._id;
                            else if (1 === r.length) { n._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : n._sounds.length && (t = n._sounds[0]._id, e = parseFloat(r[0])) } else 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10));
                            if (void 0 === t) return n;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "seek", action: function() { n.seek.apply(n, r) } }), n;
                            var i = n._soundById(t);
                            if (i) {
                                if (!("number" == typeof e && e >= 0)) {
                                    if (n._webAudio) {
                                        var a = n.playing(t) ? o.ctx.currentTime - i._playStart : 0,
                                            s = i._rateSeek ? i._rateSeek - i._seek : 0;
                                        return i._seek + (s + a * Math.abs(i._rate))
                                    }
                                    return i._node.currentTime
                                }
                                var u = n.playing(t);
                                u && n.pause(t, !0), i._seek = e, i._ended = !1, n._clearTimer(t), !n._webAudio && i._node && (i._node.currentTime = e);
                                var c = function() { n._emit("seek", t), u && n.play(t, !0) };
                                if (u && !n._webAudio) {
                                    var l = function() { n._playLock ? setTimeout(l, 0) : c() };
                                    setTimeout(l, 0)
                                } else c()
                            }
                            return n
                        },
                        playing: function(e) {
                            if ("number" == typeof e) { var t = this._soundById(e); return !!t && !t._paused }
                            for (var n = 0; n < this._sounds.length; n++)
                                if (!this._sounds[n]._paused) return !0;
                            return !1
                        },
                        duration: function(e) {
                            var t = this._duration,
                                n = this._soundById(e);
                            return n && (t = this._sprite[n._sprite][1] / 1e3), t
                        },
                        state: function() { return this._state },
                        unload: function() {
                            for (var e = this, t = e._sounds, n = 0; n < t.length; n++) {
                                if (t[n]._paused || e.stop(t[n]._id), !e._webAudio) /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (t[n]._node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"), t[n]._node.removeEventListener("error", t[n]._errorFn, !1), t[n]._node.removeEventListener(o._canPlayEvent, t[n]._loadFn, !1);
                                delete t[n]._node, e._clearTimer(t[n]._id)
                            }
                            var r = o._howls.indexOf(e);
                            r >= 0 && o._howls.splice(r, 1);
                            var i = !0;
                            for (n = 0; n < o._howls.length; n++)
                                if (o._howls[n]._src === e._src) { i = !1; break }
                            return u && i && delete u[e._src], o.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null
                        },
                        on: function(e, t, n, r) { var i = this["_on" + e]; return "function" == typeof t && i.push(r ? { id: n, fn: t, once: r } : { id: n, fn: t }), this },
                        off: function(e, t, n) {
                            var r = this["_on" + e],
                                i = 0;
                            if ("number" == typeof t && (n = t, t = null), t || n)
                                for (i = 0; i < r.length; i++) { var o = n === r[i].id; if (t === r[i].fn && o || !t && o) { r.splice(i, 1); break } } else if (e) this["_on" + e] = [];
                                else { var a = Object.keys(this); for (i = 0; i < a.length; i++) 0 === a[i].indexOf("_on") && Array.isArray(this[a[i]]) && (this[a[i]] = []) }
                            return this
                        },
                        once: function(e, t, n) { return this.on(e, t, n, 1), this },
                        _emit: function(e, t, n) { for (var r = this["_on" + e], i = r.length - 1; i >= 0; i--) r[i].id && r[i].id !== t && "load" !== e || (setTimeout(function(e) { e.call(this, t, n) }.bind(this, r[i].fn), 0), r[i].once && this.off(e, r[i].fn, r[i].id)); return this._loadQueue(e), this },
                        _loadQueue: function(e) {
                            if (this._queue.length > 0) {
                                var t = this._queue[0];
                                t.event === e && (this._queue.shift(), this._loadQueue()), e || t.action()
                            }
                            return this
                        },
                        _ended: function(e) {
                            var t = e._sprite;
                            if (!this._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(this._ended.bind(this, e), 100), this;
                            var n = !(!e._loop && !this._sprite[t][2]);
                            if (this._emit("end", e._id), !this._webAudio && n && this.stop(e._id, !0).play(e._id), this._webAudio && n) {
                                this._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = o.ctx.currentTime;
                                var r = 1e3 * (e._stop - e._start) / Math.abs(e._rate);
                                this._endTimers[e._id] = setTimeout(this._ended.bind(this, e), r)
                            }
                            return this._webAudio && !n && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, this._clearTimer(e._id), this._cleanBuffer(e._node), o._autoSuspend()), this._webAudio || n || this.stop(e._id, !0), this
                        },
                        _clearTimer: function(e) {
                            if (this._endTimers[e]) {
                                if ("function" != typeof this._endTimers[e]) clearTimeout(this._endTimers[e]);
                                else {
                                    var t = this._soundById(e);
                                    t && t._node && t._node.removeEventListener("ended", this._endTimers[e], !1)
                                }
                                delete this._endTimers[e]
                            }
                            return this
                        },
                        _soundById: function(e) {
                            for (var t = 0; t < this._sounds.length; t++)
                                if (e === this._sounds[t]._id) return this._sounds[t];
                            return null
                        },
                        _inactiveSound: function() {
                            this._drain();
                            for (var e = 0; e < this._sounds.length; e++)
                                if (this._sounds[e]._ended) return this._sounds[e].reset();
                            return new s(this)
                        },
                        _drain: function() {
                            var e = this._pool,
                                t = 0,
                                n = 0;
                            if (!(this._sounds.length < e)) {
                                for (n = 0; n < this._sounds.length; n++) this._sounds[n]._ended && t++;
                                for (n = this._sounds.length - 1; n >= 0; n--) {
                                    if (t <= e) return;
                                    this._sounds[n]._ended && (this._webAudio && this._sounds[n]._node && this._sounds[n]._node.disconnect(0), this._sounds.splice(n, 1), t--)
                                }
                            }
                        },
                        _getSoundIds: function(e) { if (void 0 === e) { for (var t = [], n = 0; n < this._sounds.length; n++) t.push(this._sounds[n]._id); return t } return [e] },
                        _refreshBuffer: function(e) { return e._node.bufferSource = o.ctx.createBufferSource(), e._node.bufferSource.buffer = u[this._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, o.ctx.currentTime), this },
                        _cleanBuffer: function(e) { if (o._scratchBuffer && e.bufferSource) { e.bufferSource.onended = null, e.bufferSource.disconnect(0); try { e.bufferSource.buffer = o._scratchBuffer } catch (e) {} } return e.bufferSource = null, this }
                    };
                    var s = function(e) { this._parent = e, this.init() };
                    s.prototype = {
                        init: function() { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++o._counter, e._sounds.push(this), this.create(), this },
                        create: function() {
                            var e = this._parent,
                                t = o._muted || this._muted || this._parent._muted ? 0 : this._volume;
                            return e._webAudio ? (this._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), this._node.gain.setValueAtTime(t, o.ctx.currentTime), this._node.paused = !0, this._node.connect(o.masterGain)) : (this._node = new Audio, this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(o._canPlayEvent, this._loadFn, !1), this._node.src = e._src, this._node.preload = "auto", this._node.volume = t * o.volume(), this._node.load()), this
                        },
                        reset: function() { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++o._counter, this },
                        _errorListener: function() { this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1) },
                        _loadListener: function() {
                            var e = this._parent;
                            e._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), this._node.removeEventListener(o._canPlayEvent, this._loadFn, !1)
                        }
                    };
                    var u = {},
                        c = function(e) {
                            var t = e._src;
                            if (u[t]) return e._duration = u[t].duration, void p(e);
                            if (/^data:[^;]+;base64,/.test(t)) {
                                for (var n = atob(t.split(",")[1]), r = new Uint8Array(n.length), i = 0; i < n.length; ++i) r[i] = n.charCodeAt(i);
                                h(r.buffer, e)
                            } else {
                                var o = new XMLHttpRequest;
                                o.open("GET", t, !0), o.withCredentials = e._xhrWithCredentials, o.responseType = "arraybuffer", o.onload = function() { var t = (o.status + "")[0]; "0" === t || "2" === t || "3" === t ? h(o.response, e) : e._emit("loaderror", null, "Failed loading audio file with status: " + o.status + ".") }, o.onerror = function() { e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete u[t], e.load()) }, l(o)
                            }
                        },
                        l = function(e) { try { e.send() } catch (t) { e.onerror() } },
                        h = function(e, t) {
                            var n = function() { t._emit("loaderror", null, "Decoding audio data failed.") },
                                r = function(e) { e && t._sounds.length > 0 ? (u[t._src] = e, p(t, e)) : n() };
                            "undefined" != typeof Promise && 1 === o.ctx.decodeAudioData.length ? o.ctx.decodeAudioData(e).then(r).catch(n) : o.ctx.decodeAudioData(e, r, n)
                        },
                        p = function(e, t) { t && !e._duration && (e._duration = t.duration), 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()) },
                        d = function() {
                            try { "undefined" != typeof AudioContext ? o.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1 } catch (e) { o.usingWebAudio = !1 }
                            var e = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform),
                                t = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                n = t ? parseInt(t[1], 10) : null;
                            if (e && n && n < 9) {
                                var r = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                                (o._navigator && o._navigator.standalone && !r || o._navigator && !o._navigator.standalone && !r) && (o.usingWebAudio = !1)
                            }
                            o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : 1, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup()
                        };
                    void 0 === (r = function() { return { Howler: o, Howl: a } }.apply(t, [])) || (e.exports = r), t.Howler = o, t.Howl = a, "undefined" != typeof window ? (window.HowlerGlobal = i, window.Howler = o, window.Howl = a, window.Sound = s) : void 0 !== n && (n.HowlerGlobal = i, n.Howler = o, n.Howl = a, n.Sound = s)
                }(),
                function() {
                    "use strict";
                    var e;
                    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(e) { if (!this.ctx || !this.ctx.listener) return this; for (var t = this._howls.length - 1; t >= 0; t--) this._howls[t].stereo(e); return this }, HowlerGlobal.prototype.pos = function(e, t, n) { return this.ctx && this.ctx.listener ? (t = "number" != typeof t ? this._pos[1] : t, n = "number" != typeof n ? this._pos[2] : n, "number" != typeof e ? this._pos : (this._pos = [e, t, n], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, .1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, .1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, .1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this }, HowlerGlobal.prototype.orientation = function(e, t, n, r, i, o) { if (!this.ctx || !this.ctx.listener) return this; var a = this._orientation; return t = "number" != typeof t ? a[1] : t, n = "number" != typeof n ? a[2] : n, r = "number" != typeof r ? a[3] : r, i = "number" != typeof i ? a[4] : i, o = "number" != typeof o ? a[5] : o, "number" != typeof e ? a : (this._orientation = [e, t, n, r, i, o], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), this.ctx.listener.upX.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.upY.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.upZ.setTargetAtTime(n, Howler.ctx.currentTime, .1)) : this.ctx.listener.setOrientation(e, t, n, r, i, o), this) }, Howl.prototype.init = (e = Howl.prototype.init, function(t) { return this._orientation = t.orientation || [1, 0, 0], this._stereo = t.stereo || null, this._pos = t.pos || null, this._pannerAttr = { coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360, coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360, coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : 0, distanceModel: void 0 !== t.distanceModel ? t.distanceModel : "inverse", maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4, panningModel: void 0 !== t.panningModel ? t.panningModel : "HRTF", refDistance: void 0 !== t.refDistance ? t.refDistance : 1, rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : 1 }, this._onstereo = t.onstereo ? [{ fn: t.onstereo }] : [], this._onpos = t.onpos ? [{ fn: t.onpos }] : [], this._onorientation = t.onorientation ? [{ fn: t.onorientation }] : [], e.call(this, t) }), Howl.prototype.stereo = function(e, n) {
                        var r = this;
                        if (!r._webAudio) return r;
                        if ("loaded" !== r._state) return r._queue.push({ event: "stereo", action: function() { r.stereo(e, n) } }), r;
                        var i = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                        if (void 0 === n) {
                            if ("number" != typeof e) return r._stereo;
                            r._stereo = e, r._pos = [e, 0, 0]
                        }
                        for (var o = r._getSoundIds(n), a = 0; a < o.length; a++) {
                            var s = r._soundById(o[a]);
                            if (s) {
                                if ("number" != typeof e) return s._stereo;
                                s._stereo = e, s._pos = [e, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || t(s, i), "spatial" === i ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(e, 0, 0) : s._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), r._emit("stereo", s._id)
                            }
                        }
                        return r
                    }, Howl.prototype.pos = function(e, n, r, i) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({ event: "pos", action: function() { o.pos(e, n, r, i) } }), o;
                        if (n = "number" != typeof n ? 0 : n, r = "number" != typeof r ? -.5 : r, void 0 === i) {
                            if ("number" != typeof e) return o._pos;
                            o._pos = [e, n, r]
                        }
                        for (var a = o._getSoundIds(i), s = 0; s < a.length; s++) {
                            var u = o._soundById(a[s]);
                            if (u) {
                                if ("number" != typeof e) return u._pos;
                                u._pos = [e, n, r], u._node && (u._panner && !u._panner.pan || t(u, "spatial"), void 0 !== u._panner.positionX ? (u._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), u._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), u._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime)) : u._panner.setOrientation(e, n, r)), o._emit("pos", u._id)
                            }
                        }
                        return o
                    }, Howl.prototype.orientation = function(e, n, r, i) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({ event: "orientation", action: function() { o.orientation(e, n, r, i) } }), o;
                        if (n = "number" != typeof n ? o._orientation[1] : n, r = "number" != typeof r ? o._orientation[2] : r, void 0 === i) {
                            if ("number" != typeof e) return o._orientation;
                            o._orientation = [e, n, r]
                        }
                        for (var a = o._getSoundIds(i), s = 0; s < a.length; s++) {
                            var u = o._soundById(a[s]);
                            if (u) {
                                if ("number" != typeof e) return u._orientation;
                                u._orientation = [e, n, r], u._node && (u._panner || (u._pos || (u._pos = o._pos || [0, 0, -.5]), t(u, "spatial")), void 0 !== u._panner.orientationX ? (u._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), u._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), u._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime)) : u._panner.setOrientation(e, n, r)), o._emit("orientation", u._id)
                            }
                        }
                        return o
                    }, Howl.prototype.pannerAttr = function() {
                        var e, n, r, i = arguments;
                        if (!this._webAudio) return this;
                        if (0 === i.length) return this._pannerAttr;
                        if (1 === i.length) {
                            if ("object" != typeof i[0]) return (r = this._soundById(parseInt(i[0], 10))) ? r._pannerAttr : this._pannerAttr;
                            e = i[0], void 0 === n && (e.pannerAttr || (e.pannerAttr = { coneInnerAngle: e.coneInnerAngle, coneOuterAngle: e.coneOuterAngle, coneOuterGain: e.coneOuterGain, distanceModel: e.distanceModel, maxDistance: e.maxDistance, refDistance: e.refDistance, rolloffFactor: e.rolloffFactor, panningModel: e.panningModel }), this._pannerAttr = { coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : this._coneInnerAngle, coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : this._coneOuterAngle, coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : this._coneOuterGain, distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : this._distanceModel, maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : this._maxDistance, refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : this._refDistance, rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : this._rolloffFactor, panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : this._panningModel })
                        } else 2 === i.length && (e = i[0], n = parseInt(i[1], 10));
                        for (var o = this._getSoundIds(n), a = 0; a < o.length; a++)
                            if (r = this._soundById(o[a])) {
                                var s = r._pannerAttr;
                                s = { coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : s.coneInnerAngle, coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : s.coneOuterAngle, coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : s.coneOuterGain, distanceModel: void 0 !== e.distanceModel ? e.distanceModel : s.distanceModel, maxDistance: void 0 !== e.maxDistance ? e.maxDistance : s.maxDistance, refDistance: void 0 !== e.refDistance ? e.refDistance : s.refDistance, rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : s.rolloffFactor, panningModel: void 0 !== e.panningModel ? e.panningModel : s.panningModel };
                                var u = r._panner;
                                u ? (u.coneInnerAngle = s.coneInnerAngle, u.coneOuterAngle = s.coneOuterAngle, u.coneOuterGain = s.coneOuterGain, u.distanceModel = s.distanceModel, u.maxDistance = s.maxDistance, u.refDistance = s.refDistance, u.rolloffFactor = s.rolloffFactor, u.panningModel = s.panningModel) : (r._pos || (r._pos = this._pos || [0, 0, -.5]), t(r, "spatial"))
                            }
                        return this
                    }, Sound.prototype.init = function(e) {
                        return function() {
                            var t = this._parent;
                            this._orientation = t._orientation, this._stereo = t._stereo, this._pos = t._pos, this._pannerAttr = t._pannerAttr, e.call(this), this._stereo ? t.stereo(this._stereo) : this._pos && t.pos(this._pos[0], this._pos[1], this._pos[2], this._id)
                        }
                    }(Sound.prototype.init), Sound.prototype.reset = function(e) { return function() { var t = this._parent; return this._orientation = t._orientation, this._stereo = t._stereo, this._pos = t._pos, this._pannerAttr = t._pannerAttr, this._stereo ? t.stereo(this._stereo) : this._pos ? t.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, t._refreshBuffer(this)), e.call(this) } }(Sound.prototype.reset);
                    var t = function(e, t) { "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0) }
                }()
            }).call(t, n(49))
        }, function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }), t.lerp = function(e, t, n) { return e + (t - e) * n }, t.inverseLerp = function(e, t, n) { return (e - t) / (n - t) }, t.inverseLerpClamped = function(e, t, n) { var r = (e - t) / (n - t); return Math.min(Math.max(r, 0), 1) }, t.map = function(e, t, n, r, i) { return (e - t) * (i - r) / (n - t) + r }, t.mapClamped = function(e, t, n, r, i) {
                var o = e;
                o > n ? o = n : o < t && (o = t);
                return (o - t) * (i - r) / (n - t) + r
            }, t.clamp = function(e, t, n) { return Math.min(Math.max(e, t), n) }, t.clampEdges = function(e, t, n) {
                var r = Math.min(t, n),
                    i = Math.max(t, n);
                return Math.min(Math.max(e, r), i)
            }, t.TwoPI = void 0;
            var r = 2 * Math.PI;
            t.TwoPI = r
        }, , , , , , function(e, t) {
            e.exports = function(e) {
                var t = [];
                return t.toString = function() {
                    return this.map(function(t) {
                        var n = function(e, t) {
                            var n = e[1] || "",
                                r = e[3];
                            if (!r) return n;
                            if (t && "function" == typeof btoa) {
                                var i = (a = r, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(a)))) + " */"),
                                    o = r.sources.map(function(e) { return "/*# sourceURL=" + r.sourceRoot + e + " */" });
                                return [n].concat(o).concat([i]).join("\n")
                            }
                            var a;
                            return [n].join("\n")
                        }(t, e);
                        return t[2] ? "@media " + t[2] + "{" + n + "}" : n
                    }).join("")
                }, t.i = function(e, n) {
                    "string" == typeof e && (e = [
                        [null, e, ""]
                    ]);
                    for (var r = {}, i = 0; i < this.length; i++) { var o = this[i][0]; "number" == typeof o && (r[o] = !0) }
                    for (i = 0; i < e.length; i++) { var a = e[i]; "number" == typeof a[0] && r[a[0]] || (n && !a[2] ? a[2] = n : n && (a[2] = "(" + a[2] + ") and (" + n + ")"), t.push(a)) }
                }, t
            }
        }], [222]).default
    }
});